{
    "0": {
        "prompt": "Consider the following code:\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic final int P = 1_000_000_007;\n\n\tint count(int a, int b, int c, int d) {\n\t\treturn Math.max(Math.min(b, d) - Math.max(a, c) + 1, 0);\n\t}\n\n\tint count(int x, int y, int z) {\n\t\treturn (int) ((long) count(x - d, x + d, 0, a - 1)\n\t\t\t\t* count(y - d, y + d, 0, b - 1) % P\n\t\t\t\t* count(z - d, z + d, 0, c - 1) % P);\n\t}\n\n\tint countX(int x, int y, int z) {\n\t\treturn (int) ((long) count(x - d + 1, x + d, 0, a - 1)\n\t\t\t\t* count(y - d, y + d, 0, b - 1) % P\n\t\t\t\t* count(z - d, z + d, 0, c - 1) % P);\n\t}\n\n\tint countY(int x, int y, int z) {\n\t\treturn (int) ((long) count(x - d, x + d, 0, a - 1)\n\t\t\t\t* count(y - d + 1, y + d, 0, b - 1) % P\n\t\t\t\t* count(z - d, z + d, 0, c - 1) % P);\n\t}\n\n\tint countZ(int x, int y, int z) {\n\t\treturn (int) ((long) count(x - d, x + d, 0, a - 1)\n\t\t\t\t* count(y - d, y + d, 0, b - 1) % P\n\t\t\t\t* count(z - d + 1, z + d, 0, c - 1) % P);\n\t}\n\n\tstatic class Item implements Comparable<Item> {\n\t\tlong idx;\n\t\tint count;\n\n\t\tpublic Item(long idx, int count) {\n\t\t\tthis.idx = idx;\n\t\t\tthis.count = count;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Item o) {\n\t\t\treturn Long.compare(idx, o.idx);\n\t\t}\n\t}\n\t\n\tvoid checkX(int x, List<Item> lst, boolean rec) {\n\t\tif (x >= 0 && x < a - 1) {\n\t\t\tint y = (int) ((long) (x + 1) * b / a);\n\t\t\tint z = (int) ((long) (x + 1) * c / a);\n\t\t\tlst.add(new Item(1L + x + y + z, count(x + 1, y, z)\n\t\t\t\t\t- countX(x, y, z)));\n\t\t\tif (rec) {\n\t\t\t\tcheckY(y, lst, false);\n\t\t\t\tcheckZ(z, lst, false);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid checkY(int y, List<Item> lst, boolean rec) {\n\t\tif (y >= 0 && y < b - 1) {\n\t\t\tint x = (int) ((long) (y + 1) * a / b);\n\t\t\tint z = (int) ((long) (y + 1) * c / b);\n\t\t\tlst.add(new Item(1L + y + x + z, count(x, y + 1, z)\n\t\t\t\t\t- countY(x, y, z)));\n\t\t\tif (rec) {\n\t\t\t\tcheckX(x, lst, false);\n\t\t\t\tcheckZ(z, lst, false);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid checkZ(int z, List<Item> lst, boolean rec) {\n\t\tif (z >= 0 && z < c - 1) {\n\t\t\tint x = (int) ((long) (z + 1) * a / c);\n\t\t\tint y = (int) ((long) (z + 1) * b / c);\n\t\t\tlst.add(new Item(1L + z + x + y, count(x, y, z + 1)\n\t\t\t\t\t- countZ(x, y, z)));\n\t\t\tif (rec) {\n\t\t\t\tcheckX(x, lst, false);\n\t\t\t\tcheckY(y, lst, false);\n\t\t\t}\n\t\t}\n\t}\n\n\tint fast() {\n\t\tList<Item> lst = new ArrayList<>();\n\t\tfor (int coord = 0; coord <= d + 1; coord++) {\n\t\t\tcheckX(coord, lst, true);\n\t\t\tcheckY(coord, lst, true);\n\t\t\tcheckZ(coord, lst, true);\n\t\t\tcheckX(a - 1 - d + coord, lst, true);\n\t\t\tcheckY(b - 1 - d + coord, lst, true);\n\t\t\tcheckZ(c - 1 - d + coord, lst, true);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tlst.add(new Item(0, count(0, 0, 0)));\n\t\tlst.add(new Item((long)a + b + c - 2, 0));\n\n\t\tCollections.sort(lst);\n\t\tfor (int i = 0; i < lst.size() - 1; i++) {\n\t\t\tint what = lst.get(i).count;\n\t\t\tlong len = lst.get(i + 1).idx - lst.get(i).idx;\n\t\t\tif (what < 0) {\n\t\t\t\twhat += P;\n\t\t\t}\n\t\t\tret += (int) (len * what % P);\n\t\t\tif (ret >= P) {\n\t\t\t\tret -= P;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tint slow() {\n\t\tlong leftX = (long) b * c;\n\t\tlong leftY = (long) c * a;\n\t\tlong leftZ = (long) a * b;\n\n\t\tint x = 0, y = 0, z = 0;\n\n\t\tint ret = count(0, 0, 0);\n\t\twhile (x != a - 1 || y != b - 1 || z != c - 1) {\n\t\t\tif (leftX < leftY && leftX < leftZ) {\n\t\t\t\tret -= countX(x, y, z);\n\t\t\t\tleftY -= leftX;\n\t\t\t\tleftZ -= leftX;\n\t\t\t\tleftX = (long) b * c;\n\t\t\t\tx++;\n\t\t\t} else if (leftY < leftZ) {\n\t\t\t\tret -= countY(x, y, z);\n\t\t\t\tleftX -= leftY;\n\t\t\t\tleftZ -= leftY;\n\t\t\t\tleftY = (long) a * c;\n\t\t\t\ty++;\n\t\t\t} else {\n\t\t\t\tret -= countZ(x, y, z);\n\t\t\t\tleftX -= leftZ;\n\t\t\t\tleftY -= leftZ;\n\t\t\t\tleftZ = (long) a * b;\n\t\t\t\tz++;\n\t\t\t}\n\n\t\t\tif (ret < 0) {\n\t\t\t\tret += P;\n\t\t\t}\n\n\t\t\tret += count(x, y, z);\n\t\t\tif (ret >= P) {\n\t\t\t\tret -= P;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint a, b, c, d;\n\n\tvoid submit() {\n\t\ta = nextInt();\n\t\tb = nextInt();\n\t\tc = nextInt();\n\t\td = nextInt();\n\t\tout.println(fast());\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tint gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tstatic final int C = 20;\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tint[] tmp = { rand(1, C), rand(1, C), rand(1, C) };\n\t\t\tArrays.sort(tmp);\n\t\t\tif (gcd(tmp[0], tmp[1]) != 1 || gcd(tmp[0], tmp[2]) != 1\n\t\t\t\t\t|| gcd(tmp[1], tmp[2]) != 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tmp[0] == tmp[1] || tmp[1] == tmp[2]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta = tmp[0];\n\t\t\tb = tmp[1];\n\t\t\tc = tmp[2];\n\t\t\td = rand(0, C);\n\t\t\tif (fast() != slow()) {\n\t\t\t\tSystem.err.println(a + \" \" + b + \" \" + c + \" \" + d);\n\t\t\t\tSystem.err.println(fast());\n\t\t\t\tSystem.err.println(slow());\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n//\t\t stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\nGicen the following input:\n3 4 5 1\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "54\n",
        "predict": "0\nEND-OF-OUTPUT"
    }
}