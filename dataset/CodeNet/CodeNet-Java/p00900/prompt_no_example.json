{
    "0": {
        "prompt": "Consider the following code:\n\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint h, w, size;\n\tint[][] map;\n\tboolean[][] bomb;\n\tP[] ps;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt(); w = sc.nextInt();\n\t\t\tif((h|w) == 0) break;\n\t\t\t\n\t\t\tmap = new int[h][w];\n\t\t\tbomb = new boolean[h][w];\n\t\t\tArrayList<P> ps = new ArrayList<P>();\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\tString l = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\t\tswitch ( l.charAt(j) ) {\n\t\t\t\t\t\tcase '.': map[i][j] = -1; break;\n\t\t\t\t\t\tcase '*': map[i][j] = 0;  break;\n\t\t\t\t\t\tdefault:  map[i][j] = l.charAt(j) - '0';\n\t\t\t\t\t\t\t\t  ps.add(new P(j, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.ps = ps.toArray(new P[]{});\n\t\t\tsize = ps.size();\n\t\t\tmemo = new HashMap<Long, Integer>();\n\t\t\tpow10 = new long[size];\n\t\t\tpow10[0] = 100L; \n\t\t\tlong S = pow10[0] * map[this.ps[0].y][this.ps[0].x];\n\t\t\tfor(int i=1;i<size;i++) {\n\t\t\t\tpow10[i] = pow10[i-1] * 10L;\n\t\t\t\tS += pow10[i] * map[this.ps[i].y][this.ps[i].x];\n\t\t\t}\n//\t\t\tdebug(pow10);\n\t\t\tSystem.out.println(solve(S, 0));\n\t\t}\n\t}\n\t\n\tint[] dx = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\n\tint[] dy = {-1, 0, 1, -1, 0, 1, -1, 0, 1};\n\tlong[] pow10;\n\tHashMap<Long, Integer> memo;\n\tint solve(long S, int cnt) {\n\t\tint p = (int)(S % 100);\n//\t\tdebug(S, cnt, p);\n\t\tif(memo.containsKey(S)) return memo.get(S);\n\t\tif(S % 100 == size) {\n\t\t\tif(S / 100 == 0) return 0;\n\t\t\treturn INF;\n\t\t}\n\t\t\n\t\tif(cnt == 9) {\n\t\t\tif(S / pow10[p] % 10 == 0) {\n\t\t\t\tint ret = solve(S+1, 0);\n\t\t\t\tmemo.put(S, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\telse return INF;\n\t\t}\n\t\t\n\t\tint min = solve(S, cnt+1);\n\t\tint x = ps[p].x + dx[cnt], y = ps[p].y + dy[cnt];\n\t\t\n\t\tif(out(x, y) || bomb[y][x] || map[y][x] < 0) return min;\n\t\tlong next = S;\n\t\tbomb[y][x] = true;\n\t\t\n\t\tboolean ng = false;\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<9;j++){\n\t\t\tint tx = x + dx[j], ty = y + dy[j];\n\t\t\tif(out(tx, ty)) continue;\n\t\t\tP tar = new P(tx, ty);\n\t\t\tif(!ps[i].isEquals(tar)) continue;\n\t\t\tif(next / pow10[i] % 10 > 0) next -= pow10[i];\n\t\t\telse ng = true;\n\t\t}\n\n\t\tif(!ng) min = min(min, solve(next, cnt+1) + 1);\n\t\t\n\t\tbomb[y][x] = false;\n//\t\tdebug(\"\", x, y, next, min);\n\t\treturn min;\n\t}\n\t\n\tboolean out(int x, int y) {\n\t\treturn x < 0 || y < 0 || x >= w || y >= h;\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tboolean isEquals(P p) {\n\t\t\treturn x == p.x && y == p.y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}Gicen the following input:\n5 6\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "6\n"
    }
}