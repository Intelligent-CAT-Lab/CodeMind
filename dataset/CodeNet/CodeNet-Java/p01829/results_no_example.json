{
    "0": {
        "prompt": "Consider the following code:\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tchar[] ch;\n\tString S;\n\tboolean[] use = new boolean[10];\n\n\tlong minDiff = Long.MAX_VALUE;\n\tString ansStr;\n\tString startStr;\n\n\tpublic void dfs(int n)\n\t{\n\t\tif(n == ch.length){\n\t\t\tansStr = startStr;\n\t\t\treturn;\n\t\t}\n\n\t\tif(n == 0){\n\t\t\tuse[(ch[n] - '0' + 5) % 10] = true;\n\t\t\tstartStr = startStr + (char)((ch[n] - '0' + 5) % 10 + '0');\n\t\t\tdfs(n + 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif(!use[ch[n] - '0']){\n\t\t\tdfs2(n,\"\");\n\t\t\tuse[ch[n] - '0'] = true;\n\t\t\tstartStr = startStr + ch[n];\n\t\t\tdfs(n + 1);\n\t\t\treturn;\n\t\t}\n\t\tdfs2(n,\"\");\n\t}\n\n\tpublic void dfs2(int n,String s){\n\t\tif(n == ch.length){\n\t\t\tlong a = Long.valueOf(S.substring(startStr.length()));\n\t\t\tlong b = Long.valueOf(s);\n\n\t\t\tlong diff = Math.abs(a - b);\n\n\t\t\tif(minDiff > diff){\n\t\t\t\tansStr = startStr + s;\n\t\t\t\tminDiff = diff;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i = 0;i < 10;i++){\n\t\t\tif(use[i])continue;\n\t\t\tuse[i] = true;\n\t\t\tdfs2(n + 1,s + (char)(i + '0'));\n\t\t\tuse[i] = false;\n\t\t}\n\t}\n\n\tpublic void solve() {\n\t\tS = next();\n\t\tch = S.toCharArray();\n\t\tstartStr = \"\";\n\t\tansStr = \"\";\n\t\tdfs(0);\n\t\tout.println(ansStr);\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}Gicen the following input:\n201\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "701\n",
        "predict": "END-OF-OUTPUT"
    }
}