{
    "0": {
        "prompt": "Consider the following code:\n\nimport java.util.Arrays;\n\n\nclass SuffixArray {\n\n  \n  public static int[] suffixArray(char[] str, int W)\n  {\n      int n = str.length;\n      if(n <= 1)return new int[n];\n      int[] sa = new int[n];\n      int[] s = new int[n+3];\n      for(int i = 0;i < n;i++)s[i] = str[i] - 'a' + 1;\n      suffixArray(s, sa, n, W+1);\n      return sa;\n  }\n  \n  public static void suffixArray(int[] s, int[] sa, int n, int K)\n  {\n      int n0 = (n+2)/3, n1 = (n+1)/3, n2 = n/3, n02 = n0 + n2;\n      int[] s12 = new int[n02+3]; \n      int[] sa12 = new int[n02+3];\n      int[] s0 = new int[n0];\n      int[] sa0 = new int[n0];\n      \n      // generate positions of mod 1 and mod 2 suffixes\n      // the \"+(n0-n1)\" adds a dummy mod 1 suffix if n%3 == 1\n      int sup = n+(n0-n1);\n      for(int i = 0, j = 0;i < sup;i+=3){\n          if(i+1 < sup)s12[j++] = i+1;\n          if(i+2 < sup)s12[j++] = i+2;\n      }\n      \n      // lsb radix sort the mod 1 and mod 2 triples\n      radixPass(s12, sa12, s, 2, n02, K);\n      radixPass(sa12, s12, s, 1, n02, K);\n      radixPass(s12, sa12, s, 0, n02, K);\n\n      // find lexicographic names of triples\n      int name = 0, c0 = -1, c1 = -1, c2 = -1;\n      for(int i = 0;i < n02;i++){\n          if(s[sa12[i]] != c0 || s[sa12[i]+1] != c1 || s[sa12[i]+2] != c2){\n              name++;\n              c0 = s[sa12[i]];\n              c1 = s[sa12[i]+1];\n              c2 = s[sa12[i]+2];\n          }\n          if(sa12[i] % 3 == 1){\n              s12[sa12[i]/3] = name; // left half\n          }else{\n              s12[sa12[i]/3 + n0] = name; // right half\n          }\n      }\n      \n      // recurse if names are not yet unique\n      if(name < n02){\n          suffixArray(s12, sa12, n02, name);\n          // store unique names in s12 using the suffix array\n          for(int i = 0;i < n02;i++)s12[sa12[i]] = i+1;\n      }else{\n          // generate the suffix array of s12 directly\n          for(int i = 0;i < n02;i++)sa12[s12[i]-1] = i;\n      }\n      \n      // stably sort the mod 0 suffixes from sa12 by their first character\n      for(int i = 0, j = 0;i < n02;i++){\n          if(sa12[i] < n0)s0[j++] = 3 * sa12[i];\n      }\n      radixPass(s0, sa0, s, 0, n0, K);\n      \n      // merge sorted sa0 suffixes and sorted sa12 suffixes\n      for(int p = 0, t = n0-n1, k = 0;k < n;k++){\n          int i = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2; // pos of current offset 12 suffix\n          int j = sa0[p]; // pos of current offset 0 suffix\n          if(sa12[t] < n0 ?\n                  (s[i] < s[j] || s[i] == s[j] && s12[sa12[t]+n0] <= s12[j/3]) :\n                  (s[i] < s[j] || s[i] == s[j] && (s[i+1] < s[j+1] || s[i+1] == s[j+1] && s12[sa12[t]-n0+1] <= s12[j/3+n0]))\n                  ){\n              // suffix from a12 is smaller\n              sa[k] = i;\n              t++;\n              if(t == n02){\n                  // done --- only sa0 suffixes left\n                  for(k++;p < n0;p++,k++)sa[k] = sa0[p];\n              }\n          }else{\n              // suffix from sa0 is smaller\n              sa[k] = j; p++;\n              if(p == n0){\n                  // done --- only sa12 suffixes left\n                  for(k++; t < n02;t++,k++)sa[k] = sa12[t] < n0 ? sa12[t] * 3 + 1 : (sa12[t] - n0) * 3 + 2;\n              }\n          }\n      }\n  }\n  \n  /**\n   * radixsort a by r's value, and store a's index to b.\n   * @param a\n   * @param b\n   * @param r\n   * @param l\n   * @param n\n   * @param K\n   */\n  public static void radixPass(int[] a, int[] b, int[] r, int l, int n, int K)\n  {\n      int[] c = new int[K+1]; // counter array\n      for(int i = 0;i < n;i++)c[r[l+a[i]]]++; // count occurrences\n      for(int i = 0, sum = 0;i <= K;i++){ // exclusive prefix sums\n          int t = c[i]; c[i] = sum; sum += t;\n      }\n      for(int i = 0;i < n;i++)b[c[r[l+a[i]]]++] = a[i];\n  }\n  \n  static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n\n  /**\n   * \u901f\u3044SuffixArray\u306eLCP\u4f5c\u6210\n   * @param str\n   * @param sa\n   * @return\n   */\n  public static int[] buildLCP0(char[] str, int[] sa)\n  {\n      int n = str.length;\n      int h = 0;\n      int[] lcp = new int[n];\n      int[] b = new int[n];\n      for(int i = 0;i < n;i++)b[sa[i]] = i;\n      for(int i = 0;i < n;i++){\n          if(b[i] > 0){\n              for(int j = sa[b[i]-1]; j+h<n && i+h<n && str[j+h] == str[i+h]; h++);\n              lcp[b[i]] = h;\n          }else{\n              lcp[b[i]] = 0;\n          }\n          if(h > 0)h--;\n      }\n      return lcp;\n  }   \n}\n\npublic class Main {\n\n  private static void solve() {\n    char[] s = ns();\n    int[] sa = SuffixArray.suffixArray(s, 50);\n    int[] lcp = SuffixArray.buildLCP0(s, sa);\n    \n    int n = s.length;\n    int[] imos = new int[n + 1];\n    \n    for (int i = 0; i < n; i ++) {\n      imos[lcp[i]] ++;\n    }\n    \n    for (int i = 0; i < n; i ++) {\n      imos[i + 1] += imos[i];\n    }\n    \n    int max = 0;\n    for (int i = 0; i < n; i ++) {\n      max = Math.max(max, imos[i] - i);\n    }\n    \n    System.out.println(max);\n  }\n\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\nGicen the following input:\nabcabc\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "3\n"
    }
}