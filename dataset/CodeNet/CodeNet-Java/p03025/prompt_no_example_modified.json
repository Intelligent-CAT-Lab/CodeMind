{
    "0": {
        "prompt": "Consider the following code:\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\tprivate static void solve() {\n\t\tint n = nei();\n\t\tlong a = nei();\n\t\tlong b = nei();\n\t\tlong c = nei();\n\t\tlong na = 100 - a;\n\t\tlong nb = 100 - b;\n\t\tlong M = 1000000007;\n\t\tlong inv100 = modinv(100, M);\n\t\ta = a * inv100 % M;\n\t\tb = b * inv100 % M;\n\t\tc = c * inv100 % M;\n\t\tna = na * inv100 % M;\n\t\tnb = nb * inv100 % M;\n\t\tlong[] fa = new long[2 * n];\n\t\tlong[] fai = new long[2 * n];\n\t\tfa[0] = 1;\n\t\tfai[0] = 1;\n\t\tfor (int i = 1; i < 2 * n; i++) {\n\t\t\tfa[i] = fa[i - 1] * i % M;\n\t\t\tfai[i] = modinv(fa[i], M);\n\t\t}\n\t\tlong ans = 0;\n\t\t\n\t\tlong scale=modinv((a+b)%M,M);\n\n\t\tlong a2=a*scale%M;\n\t\tlong b2=b*scale%M;\n\t\tfor (int k = n; k < 2 * n; k++) {\n\t\t\tlong ak = modpow(a2, n, M) * modpow(b2, k - n, M) % M * modcomb(k - 1, n - 1, fa, fai, M) % M;\n\t\t\tlong bk = modpow(b2, n, M) * modpow(a2, k - n, M) % M * modcomb(k - 1, n - 1, fa, fai, M) % M;\n\t\t\tans = (ans + ak * k % M) % M;\n\t\t\tans = (ans + bk * k % M) % M;\n\t\t}\n\t\tans = ans * modinv((a + b) % M, M) % M;\n\t\tout(ans);\n\t}\n\n\t// returns (x, y, d) s.t. ax + by = d\n\tstatic long[] exgcd(long a, long b) {\n\t\tint sa = a < 0 ? -1 : 1;\n\t\tint sb = b < 0 ? -1 : 1;\n\t\ta *= sa;\n\t\tb *= sb;\n\t\tlong x = 1;\n\t\tlong y = 0;\n\t\tlong z = 0;\n\t\tlong w = 1;\n\t\twhile (b > 0) {\n\t\t\tlong q = a / b;\n\t\t\tlong t = z;\n\t\t\tz = x - q * z;\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = y - q * w;\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = a - q * b;\n\t\t\ta = t;\n\t\t}\n\t\treturn new long[] { x * sa, y * sb, a };\n\t}\n\n\tstatic int[] lis(int[] s) {\n\t\tint n = s.length;\n\t\tint[] dp = new int[n];\n\t\tint[] ids = new int[n];\n\t\tint[] pids = new int[n];\n\t\tdp[0] = s[0];\n\t\tint len = 1;\n\t\tint lidx = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint idx = bs(s[i], dp, 0, len);\n\t\t\tdp[idx] = s[i];\n\t\t\tids[idx] = i;\n\t\t\tif (idx == len) {\n\t\t\t\tlidx = i;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (idx > 0)\n\t\t\t\tpids[i] = ids[idx - 1];\n\t\t}\n\t\tint[] lis = new int[len];\n\t\tlis[len - 1] = s[lidx];\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tlis[i] = s[lidx];\n\t\t\tlidx = pids[lidx];\n\t\t}\n\t\treturn lis;\n\t}\n\n\tstatic int bs(int a, int[] as, int from, int num) {\n\t\tint min = from;\n\t\tint max = from + num - 1;\n\t\twhile (min < max) {\n\t\t\tint mid = min + max >> 1;\n\t\t\tif (as[mid] < a)\n\t\t\t\tmin = mid + 1;\n\t\t\telse if (as[mid] > a)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\treturn mid;\n\t\t}\n\t\treturn as[min] < a ? min + 1 : min;\n\t}\n\n\tstatic int gcd(int x, int y) {\n\t\tx = (x ^ x >> 31) - (x >> 31);\n\t\ty = (y ^ y >> 31) - (y >> 31);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tint z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long gcd(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tlong z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long modinv(long a, long mod) {\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\n\tstatic long modpow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif ((b & 1) == 0) {\n\t\t\tlong sqrt = modpow(a, b >> 1, mod);\n\t\t\treturn sqrt * sqrt % mod;\n\t\t}\n\t\treturn a * modpow(a, b - 1, mod) % mod;\n\t}\n\n\tstatic long fact(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modfact(long n, long mod) {\n\t\tif (n <= 1)\n\t\t\treturn 1 % mod;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\t// returns facts([0]) and invfacts([1])\n\tstatic long[][] enumfacts(int n, long mod) {\n\t\tint num = n + 10;\n\t\tlong[][] res = new long[2][num];\n\t\tlong[] facts = res[0];\n\t\tlong[] invfacts = res[1];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (i <= 1) {\n\t\t\t\tfacts[i] = 1;\n\t\t\t\tinvfacts[i] = 1;\n\t\t\t} else {\n\t\t\t\tfacts[i] = facts[i - 1] * i % mod;\n\t\t\t\tinvfacts[i] = modinv(facts[i], mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modcomb(long n, long m, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tif (m > n - m) {\n\t\t\tm = n - m;\n\t\t}\n\t\tlong numer = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tnumer = numer * (n - i) % mod;\n\t\t}\n\t\tlong denom = modfact(m, mod);\n\t\treturn numer * modinv(denom, mod) % mod;\n\t}\n\n\tstatic long modcomb(int n, int m, long[] facts, long[] invfacts, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tlong numer = facts[n];\n\t\tlong denom = invfacts[m] * invfacts[n - m] % mod;\n\t\treturn numer * denom % mod;\n\t}\n\n\t// res[i][0]: prime factor, res[i][1]: exponent\n\tstatic int[][] factorize(int n) {\n\t\tint[][] pfs = new int[32][2];\n\t\tint num = 0;\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tint count = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\tpfs[num][0] = i;\n\t\t\t\tpfs[num][1] = count;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tpfs[num][0] = n;\n\t\t\tpfs[num][1] = 1;\n\t\t\tnum++;\n\t\t}\n\t\tint[][] res = new int[num][2];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tres[i][0] = pfs[i][0];\n\t\t\tres[i][1] = pfs[i][1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long lcm(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\treturn x / gcd(x, y) * y;\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic double clamp(double a, double min, double max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\nclass Rev<A extends Comparable<A>> implements Comparable<Rev<A>> {\n\tA a;\n\n\tRev(A a) {\n\t\tthis.a = a;\n\t}\n\n\tstatic <A extends Comparable<A>> Rev<A> make(A a) {\n\t\treturn new Rev<A>(a);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof Rev))\n\t\t\treturn false;\n\t\tRev<?> r = (Rev<?>) o;\n\t\treturn a == null ? r.a == null : a.equals(r.a);\n\t}\n\n\tpublic int compareTo(Rev<A> o) {\n\t\treturn -a.compareTo(o.a);\n\t}\n\n\tpublic String toString() {\n\t\treturn \"-(\" + a.toString() + \")\";\n\t}\n}\n\nclass Flat<A> implements Comparable<Flat<A>> {\n\tA a;\n\n\tFlat(A a) {\n\t\tthis.a = a;\n\t}\n\n\tstatic <A> Flat<A> make(A a) {\n\t\treturn new Flat<A>(a);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof Flat))\n\t\t\treturn false;\n\t\tFlat<?> r = (Flat<?>) o;\n\t\treturn a == null ? r.a == null : a.equals(r.a);\n\t}\n\n\tpublic int compareTo(Flat<A> o) {\n\t\treturn 0;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"0(\" + a.toString() + \")\";\n\t}\n}\n\nclass UP<A, B> { // Unordered Pair\n\tA a;\n\tB b;\n\n\tUP(A a, B b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic <A, B> UP<A, B> make(A a, B b) {\n\t\treturn new UP<A, B>(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UP))\n\t\t\treturn false;\n\t\tUP<?, ?> p = (UP<?, ?>) o;\n\t\tboolean aok = a == null ? p.a == null : a.equals(p.a);\n\t\tboolean bok = b == null ? p.b == null : b.equals(p.b);\n\t\treturn aok && bok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \")\";\n\t}\n}\n\nclass P<A extends Comparable<A>, B extends Comparable<B>> extends UP<A, B> implements Comparable<P<A, B>> { // Pair\n\tP(A a, B b) {\n\t\tsuper(a, b);\n\t}\n\n\tstatic <A extends Comparable<A>, B extends Comparable<B>> P<A, B> make(A a, B b) {\n\t\treturn new P<A, B>(a, b);\n\t}\n\n\tpublic int compareTo(P<A, B> o) {\n\t\tint sa = a.compareTo(o.a);\n\t\tint sb = b.compareTo(o.b);\n\t\treturn sa != 0 ? sa : sb;\n\t}\n}\n\nclass UT<A, B, C> { // Unordered Tuple\n\tA a;\n\tB b;\n\tC c;\n\n\tUT(A a, B b, C c) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n\n\tstatic <A, B, C> UT<A, B, C> make(A a, B b, C c) {\n\t\treturn new UT<A, B, C>(a, b, c);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UT))\n\t\t\treturn false;\n\t\tUT<?, ?, ?> t = (UT<?, ?, ?>) o;\n\t\tboolean aok = a == null ? t.a == null : a.equals(t.a);\n\t\tboolean bok = b == null ? t.b == null : b.equals(t.b);\n\t\tboolean cok = c == null ? t.c == null : c.equals(t.c);\n\t\treturn aok && bok && cok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \")\";\n\t}\n}\n\nclass T<A extends Comparable<A>, B extends Comparable<B>, C extends Comparable<C>> extends UT<A, B, C> implements\n\t\tComparable<T<A, B, C>> { // Tuple\n\tT(A a, B b, C c) {\n\t\tsuper(a, b, c);\n\t}\n\n\tstatic <A extends Comparable<A>, B extends Comparable<B>, C extends Comparable<C>> T<A, B, C> make(A a, B b, C c) {\n\t\treturn new T<A, B, C>(a, b, c);\n\t}\n\n\tpublic int compareTo(T<A, B, C> o) {\n\t\tint sa = a.compareTo(o.a);\n\t\tint sb = b.compareTo(o.b);\n\t\tint sc = c.compareTo(o.c);\n\t\treturn sa != 0 ? sa : sb != 0 ? sb : sc;\n\t}\n}\n\ninterface F1<A> {\n\tA f();\n}\n\ninterface F2<A, B> {\n\tB f(A a);\n}\n\ninterface F3<A, B, C> {\n\tC f(A a, B b);\n}\n\ninterface F4<A, B, C, D> {\n\tD f(A a, B b, C c);\n}\n\ninterface F5<A, B, C, D, E> {\n\tE f(A a, B b, C c, D d);\n}\n\ninterface F1V<A> {\n\tvoid f(A a);\n}\n\ninterface F2V<A, B> {\n\tvoid f(A a, B b);\n}\n\ninterface F3V<A, B, C> {\n\tvoid f(A a, B b, C c);\n}\n\ninterface F4V<A, B, C, D> {\n\tvoid f(A a, B b, C c, D d);\n}\n\ninterface F5V<A, B, C, D, E> {\n\tvoid f(A a, B b, C c, D d, E e);\n}\n\nclass U { // Utilities\n\tstatic <A> ArrayList<A> make(int n, F2<Integer, A> maker) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres.add(maker.f(i));\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> filter(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (A a : as)\n\t\t\tif (pred.f(a))\n\t\t\t\tres.add(a);\n\t\treturn res;\n\t}\n\n\tstatic <A> int count(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tint res = 0;\n\t\tfor (A a : as)\n\t\t\tif (pred.f(a))\n\t\t\t\tres++;\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> concat(ArrayList<A> as, ArrayList<A> bs) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tres.addAll(as);\n\t\tres.addAll(bs);\n\t\treturn res;\n\t}\n\n\tstatic <A> boolean any(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tfor (A a : as)\n\t\t\tif (pred.f(a))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tstatic <A> boolean all(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tfor (A a : as)\n\t\t\tif (!pred.f(a))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tstatic <A> ArrayList<A> flatten(ArrayList<ArrayList<A>> ass) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (ArrayList<A> as : ass)\n\t\t\tres.addAll(as);\n\t\treturn res;\n\t}\n\n\tstatic <A, B> B foldl(ArrayList<A> as, F3<B, A, B> f, B e) {\n\t\tB res = e;\n\t\tfor (A a : as)\n\t\t\tres = f.f(res, a);\n\t\treturn res;\n\t}\n\n\tstatic <A, B> B foldr(ArrayList<A> as, F3<A, B, B> f, B e) {\n\t\tB res = e;\n\t\tfor (int i = as.size() - 1; i >= 0; i--)\n\t\t\tres = f.f(as.get(i), res);\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> reverse(ArrayList<A> as) {\n\t\tint size = as.size();\n\t\treturn make(size, i -> as.get(size - 1 - i));\n\t}\n\n\tstatic <A> void forEach(ArrayList<A> as, F1V<A> f) {\n\t\tfor (A a : as)\n\t\t\tf.f(a);\n\t}\n\n\tstatic <A extends Comparable<A>> UP<TreeMap<A, Integer>, ArrayList<A>> compress(ArrayList<A> as) {\n\t\tTreeSet<A> set = new TreeSet<A>(as);\n\t\tTreeMap<A, Integer> map = new TreeMap<A, Integer>();\n\t\tArrayList<A> imap = new ArrayList<A>();\n\t\tint i = 0;\n\t\tfor (A a : set) {\n\t\t\tmap.put(a, i++);\n\t\t\timap.add(a);\n\t\t}\n\t\treturn UP.make(map, imap);\n\t}\n\n\tstatic <A, B> ArrayList<B> map(ArrayList<A> as, F2<A, B> f) {\n\t\treturn make(as.size(), (i) -> f.f(as.get(i)));\n\t}\n\n\tstatic <A, B> ArrayList<UP<A, B>> zip(ArrayList<A> as, ArrayList<B> bs) {\n\t\treturn make(min(as.size(), bs.size()), (i) -> UP.make(as.get(i), bs.get(i)));\n\t}\n\n\tstatic <A extends Comparable<A>> A min(A a, A b) {\n\t\treturn a.compareTo(b) < 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A max(A a, A b) {\n\t\treturn a.compareTo(b) > 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A clamp(A a, A min, A max) {\n\t\treturn a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;\n\t}\n\n\tstatic <A> A[] doubleSize(A[] as) {\n\t\treturn Arrays.copyOf(as, as.length << 1);\n\t}\n}\n\n@SuppressWarnings(\"unchecked\")\nclass G<V, E> { // Graph\n\tprivate int vSize;\n\tprivate Object[] vs; // V\n\tprivate Object[] esFrom; // EdgeSet\n\tprivate Object[] esTo; // EdgeSet\n\tprivate Object[] pool; // UP<Object, Integer>\n\tprivate Integer[] ints;\n\tprivate int poolCounter;\n\n\tprivate class EdgeSet {\n\t\tHashMap<Integer, E> map;\n\t\tInteger[] is;\n\t\tObject[] es;\n\t\tint size;\n\n\t\tEdgeSet() {\n\t\t\tis = new Integer[2];\n\t\t\tes = new Object[2];\n\t\t\tsize = 0;\n\t\t}\n\n\t\tvoid add(Integer i, E e) {\n\t\t\tif (size > 16) {\n\t\t\t\tmap.put(i, e);\n\t\t\t\tsize++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (size == is.length) {\n\t\t\t\tis = Arrays.copyOf(is, size << 1);\n\t\t\t\tes = Arrays.copyOf(es, size << 1);\n\t\t\t}\n\t\t\tis[size] = i;\n\t\t\tes[size] = e;\n\t\t\tif (++size > 16) {\n\t\t\t\tmap = new HashMap<Integer, E>();\n\t\t\t\tfor (int j = 0; j < size; j++) {\n\t\t\t\t\tmap.put(is[j], (E) es[j]);\n\t\t\t\t}\n\t\t\t\tis = null;\n\t\t\t\tes = null;\n\t\t\t}\n\t\t}\n\n\t\tvoid iter(F2V<Integer, E> f) {\n\t\t\tif (map == null)\n\t\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\t\tf.f(is[i], (E) es[i]);\n\t\t\telse\n\t\t\t\tfor (Entry<Integer, E> e : map.entrySet())\n\t\t\t\t\tf.f(e.getKey(), e.getValue());\n\t\t}\n\t}\n\n\tG() {\n\t\tvs = new Object[64];\n\t\tesFrom = new Object[64];\n\t\tesTo = new Object[64];\n\t\tpool = new Object[64];\n\t\tints = new Integer[64];\n\t\tvSize = 0;\n\t}\n\n\tV getV(int i) {\n\t\treturn i < 0 || i >= vs.length ? null : (V) vs[i];\n\t}\n\n\tArrayList<V> getSortedVs() {\n\t\tArrayList<V> res = new ArrayList<V>();\n\t\tfor (int i = 0; i < vs.length; i++) {\n\t\t\tif (vs[i] != null)\n\t\t\t\tres.add((V) vs[i]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid addV(int i, V v) {\n\t\tif (getV(i) != null)\n\t\t\tthrow new RuntimeException(\"duplicate vtx: \" + i);\n\t\twhile (vs.length <= i) {\n\t\t\tvs = U.doubleSize(vs);\n\t\t\tints = U.doubleSize(ints);\n\t\t\tesFrom = U.doubleSize(esFrom);\n\t\t\tesTo = U.doubleSize(esTo);\n\t\t\tpool = U.doubleSize(pool);\n\t\t}\n\t\tvSize = U.max(vSize, i + 1);\n\t\tvs[i] = v;\n\t\tints[i] = Integer.valueOf(i);\n\t\tesFrom[i] = new EdgeSet();\n\t\tesTo[i] = new EdgeSet();\n\t\tpool[i] = UP.make(null, 0);\n\t}\n\n\tvoid setV(int i, V v) {\n\t\tif (getV(i) == null)\n\t\t\tthrow new RuntimeException(\"no such vtx: \" + i);\n\t\tvs[i] = v;\n\t}\n\n\tvoid addE(int from, int to, E e) {\n\t\t((EdgeSet) esFrom[from]).add(ints[to], e);\n\t\t((EdgeSet) esTo[to]).add(ints[from], e);\n\t}\n\n\tvoid addUE(int i, int j, E e) {\n\t\taddE(i, j, e);\n\t\taddE(j, i, e);\n\t}\n\n\t<State> void dfs(int firstIdx, State firstS, F5<State, Integer, Integer, E, State> nextState,\n\t\t\tF3V<State, Integer, ArrayList<Integer>> visit) {\n\t\tArrayDeque<UP<Object, Integer>> deque = new ArrayDeque<UP<Object, Integer>>();\n\t\tsearch(firstIdx, firstS, nextState, visit, deque::push, deque::pop, deque::isEmpty);\n\t}\n\n\t<State> void bfs(int firstIdx, State firstS, F5<State, Integer, Integer, E, State> nextState,\n\t\t\tF3V<State, Integer, ArrayList<Integer>> visit) {\n\t\tArrayDeque<UP<Object, Integer>> deque = new ArrayDeque<UP<Object, Integer>>();\n\t\tsearch(firstIdx, firstS, nextState, visit, deque::addLast, deque::pollFirst, deque::isEmpty);\n\t}\n\n\tprivate <State> void search(int firstIdx, State firstS, F5<State, Integer, Integer, E, State> nextState,\n\t\t\tF3V<State, Integer, ArrayList<Integer>> visit, F1V<UP<Object, Integer>> push, F1<UP<Object, Integer>> pop,\n\t\t\tF1<Boolean> isEmpty) {\n\t\tboolean[] visited = new boolean[vSize];\n\t\tArrayList<Integer> movedTo = new ArrayList<Integer>();\n\t\tpush.f(UP.make(firstS, firstIdx));\n\t\tvisited[firstIdx] = true;\n\t\twhile (!isEmpty.f()) {\n\t\t\tUP<Object, Integer> si = pop.f();\n\t\t\tState s = (State) si.a;\n\t\t\tInteger i = si.b;\n\t\t\tmovedTo.clear();\n\t\t\t((EdgeSet) esFrom[i]).iter((j, e) -> {\n\t\t\t\tif (visited[j])\n\t\t\t\t\treturn;\n\t\t\t\tState ns = nextState.f(s, i, j, e);\n\t\t\t\tif (ns != null) {\n\t\t\t\t\tmovedTo.add(j);\n\t\t\t\t\tpush.f(pick(ns, j));\n\t\t\t\t\tvisited[j] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tvisit.f(s, i, movedTo);\n\t\t}\n\t}\n\n\tprivate UP<Object, Integer> pick(Object o, Integer i) {\n\t\treturn UP.make(o, i);\n\t}\n}\n\nWhat would be the output of the code execution given the following input:\n1 25 25 50\n \nPrint the answer and end your response with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "2\n"
    }
}