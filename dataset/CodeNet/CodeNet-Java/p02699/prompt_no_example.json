{
    "0": {
        "prompt": "Consider the following code:\nimport java.io.*;\nimport java.util.*;\n\nclass Main{\n    final static long INF = Long.MAX_VALUE / 2;\n    final static int MOD = 1_000_000_007;\n    final static int SIZE = 1_000_000;\n    long[] fac = new long[SIZE];\n    long[] inv = new long[SIZE];\n    long[] finv = new long[SIZE];\n    FastScanner sc = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    void solve(){\n\n        int s = sc.nextInt();\n        int w = sc.nextInt();\n\n        if(w >= s) System.out.println(\"unsafe\");\n        else System.out.println(\"safe\");\n\n    }\n\n    long gcd(long a, long b){ // return a\u3068b\u306e\u6700\u5927\u516c\u7d04\u6570\n        if(b == 0){\n          return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b){ // return a\u3068b\u306e\u6700\u5c0f\u516c\u500d\u6570\n        return a * b / gcd(a, b);\n    }\n\n    long inv(long a){ // return a\u306e\u9006\u5143 (mod MOD)\n        return pow(a, MOD - 2);\n    }\n\n    long pow(long a, long r){ // return a^r (mod MOD)\n        long sum = 1;\n        while(r > 0){\n            if((r & 1) == 1){ // 2\u9032\u6570\u8868\u8a18\u3067\u672b\u5c3e1\u306e\u6642\n                sum *= a;\n                sum %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            r >>= 1;\n        }\n        return sum;\n    }\n\n    long modFact(long n){ // retur n! (mod MOD)\n        if(n == 0){\n            return 1;\n        }\n        return n * modFact(n - 1) % MOD;\n    }\n\n    long fact(long n){ // return n!\n        if(n == 0){\n            return 1;\n        }\n        return n * fact(n - 1);\n    }\n\n    void initCOMB(){\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for(int i = 2; i < SIZE; i++){\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    long modComb(int n, int r){ // return nCr (\u5148\u306binitCOMB()\u5fc5\u8981)\n        if(n < r || n < 0 || r < 0) return 0;\n        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;\n    }\n\n    long comb(long n, long r){ // return nCr\n        long num = 1;\n        for(long i = 1; i <= r; i++){\n            num = num * (n - i + 1) / i;\n        }\n        return num;\n    }\n\n    boolean isPrime(long a){ // a\u306e\u7d20\u6570\u5224\u5b9a\n        if(a <= 1) return false;\n        for(int i = 2; i * i <= a; i++){\n            if(a % i == 0) return false;\n        }\n        return true;\n    }\n\n    String nextPermutation(String s){ // return s\u306e\u6b21\u306e\u9806\u5217\n        ArrayList<Character> list = new ArrayList<>();\n        for(int i = 0; i < s.length(); i++) list.add(s.charAt(i));\n\n        int pivotPos = -1;\n        char pivot = 0;\n        for(int i = list.size() - 2; i >= 0; i--){\n            if(list.get(i) < list.get(i+1)){\n    \t\t\tpivotPos = i;\n    \t\t\tpivot = list.get(i);\n    \t\t\tbreak;\n    \t\t}\n    \t}\n\n        if(pivotPos == -1 && pivot == 0) return null;\n\n        int L = pivotPos + 1;\n        int R = list.size() - 1;\n    \tint minPos = -1;\n    \tchar min = Character.MAX_VALUE;\n    \tfor(int i = R; i >= L; i--){\n    \t\tif(pivot < list.get(i)){\n    \t\t\tif(list.get(i) < min){\n    \t\t\t\tmin = list.get(i);\n    \t\t\t\tminPos = i;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tCollections.swap(list, pivotPos, minPos);\n    \tCollections.sort(list.subList(L, R + 1));\n\n    \tStringBuilder sb = new StringBuilder();\n    \tfor(int i=0; i<list.size(); i++) sb.append(list.get(i));\n\n    \treturn sb.toString();\n    }\n\n    boolean nextPermutation(long[] a){\n        for(int i = a.length - 1; i > 0; i--){\n            if(a[i - 1] < a[i]){\n                int swapIndex = find(a[i - 1], a, i, a.length - 1);\n                long temp = a[swapIndex];\n                a[swapIndex] = a[i - 1];\n                a[i - 1] = temp;\n                Arrays.sort(a, i, a.length);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int find(long dest, long[] a, int s, int e){\n        if(s == e){\n            return s;\n        }\n        int m = (s + e + 1) / 2;\n        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n    }\n\n    void elimination(int[][] a, int[] b) {\n        int n = a.length;\n        double f;\n        for(int k = 0; k < n - 1; k++){\n            for(int i = k + 1; i < n; i++){\n                f = - a[i][k] / a[k][k];\n                for(int j = k + 1; j < n; j++){\n                    a[i][j] += f * a[k][j];\n                }\n                b[i] += f * b[k];\n            }\n            for(int i = n - 1; i >= 0; i--){\n                for(int j = i + 1; j < n; j++){\n                    b[i] -= a[i][j] * b[j];\n                }\n                b[i] = b[i] / a[i][i];\n            }\n        }\n   }\n\n}\n\n\n\nclass Pair implements Comparable<Pair>{\n    long a, b;\n    public Pair(long i, long j){\n        a = i;\n        b = j;\n    }\n\n    @Override\n    public int compareTo(Pair p){\n        if(this.b < p.b) return -1;\n        else if(this.b > p.b) return 1;\n        else return 0;\n    }\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte(){\n        if(ptr < buflen){\n            return true;\n        }else{\n            ptr = 0;\n            try{\n                buflen = in.read(buffer);\n            }catch(IOException e){\n                e.printStackTrace();\n            }\n            if(buflen <= 0){\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte(){\n        if(hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n    private static boolean isPrintableChar(int c){\n        return 33 <= c && c <= 126;\n    }\n    public boolean hasNext(){\n        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n    public String next(){\n        if(!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong(){\n        if(!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        if(b < '0' || '9' < b){\n            throw new NumberFormatException();\n        }\n        while(true){\n            if('0' <= b && b <= '9'){\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt(){\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble(){\n        return Double.parseDouble(next());\n    }\n}\nGicen the following input:\n4 5\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "unsafe\n"
    }
}