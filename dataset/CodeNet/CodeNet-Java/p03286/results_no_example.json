{
    "0": {
        "prompt": "Consider the following code:\n/**\n * Created at 00:15 on 2019-06-28\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n\n  static int[] dx = {0, 1, 0, -1};\n  static int[] dy = {-1, 0, 1, 0};\n\n  static long MOD = (long) (1e9 + 7);\n\n  public static void main(String[] args) {\n\n    new Main().run();\n\n  }\n\n  public void run() {\n\n    long N = sc.nextLong();\n\n    String ans = (N == 0 ? \"0\" : \"\");\n    while(N != 0) {\n      long q = q(N, -2);\n      long r = r(N, -2);\n      ans = r + ans;\n      N = q;\n    }\n\n    System.out.println(ans);\n\n  }\n\n  public long q(long a, long b) {\n    if (b > 0) {\n      return floor(a, b);\n    } else {\n      return ceil(a, b);\n    }\n  }\n\n  public long r(long a, long b) {\n    return a - q(a, b) * b;\n  }\n\n  /*\n   * n <= a/b \u306a\u308b\u6700\u5927\u306e\u6574\u6570n\u3092\u8fd4\u3059\n   */\n  public long floor(long a, long b) {\n    if (b < 0) {\n      a *= -1;\n      b *= -1;\n    }\n\n    if (a > 0) {\n      //\u7d76\u5bfe\u5024\u306e\u5c0f\u3055\u3044\u65b9\u306b\u4e38\u3081\u3089\u308c\u308b(\u6b63\u306a\u3089\u8ca0\u306e\u65b9\u5411)\n      return a/b;\n    } else {\n      //\u3088\u304f\u3042\u308b\u5207\u308a\u4e0a\u3052\u306e\u30c6\u30af\u30cb\u30c3\u30af\u306e\u5207\u308a\u6368\u3066\u7248\n      return (a-b+1)/b;\n    }\n  }\n\n\n  /*\n   * n >= a/b \u306a\u308b\u6700\u5c0f\u306e\u6574\u6570n\u3092\u8fd4\u3059\n   */\n  public long ceil(long a, long b) {\n    if (b < 0) {\n      a *= -1;\n      b *= -1;\n    }\n\n    if (a > 0) {\n      //\u3088\u304f\u3042\u308b\u5207\u308a\u4e0a\u3052\u306e\u30c6\u30af\u30cb\u30c3\u30af\n      return (a+b-1)/b;\n    } else {\n      //\u7d76\u5bfe\u5024\u306e\u5c0f\u3055\u3044\u65b9\u306b\u4e38\u3081\u3089\u308c\u308b(\u8ca0\u306a\u3089\u6b63\u306e\u65b9\u5411)\n      return a/b;\n    }\n  }\n\n\n  public static class Mathf {\n\n    public static int max(int[] a) {\n      int M = a[0];\n      for (int i = 1; i < a.length; i++) {\n        M = Math.max(M, a[i]);\n      }\n      return M;\n    }\n\n    public static int min(int[] a) {\n      int m = a[0];\n      for (int i = 1; i < a.length; i++) {\n        m = Math.min(m, a[i]);\n      }\n      return m;\n    }\n\n    public static long max(long[] a) {\n      long M = a[0];\n      for (int i = 1; i < a.length; i++) {\n        M = Math.max(M, a[i]);\n      }\n      return M;\n    }\n\n    public static long min(long[] a) {\n      long m = a[0];\n      for (int i = 1; i < a.length; i++) {\n        m = Math.min(m, a[i]);\n      }\n      return m;\n    }\n\n  }\n\n  /*\n    add()\u3067\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u6307\u5b9a\u3057\u306a\u3044\u5834\u5408\u6307\u5b9a\u3055\u308c\u305f\u30bd\u30fc\u30c8\u9806\u306b\u9055\u308f\u306a\u3044\u4f4d\u7f6e\u306b\u8ffd\u52a0\u3059\u308b\n    (\u305f\u3060\u3057\u30bd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u304c\u524d\u63d0\u3068\u306a\u308b)\n    Comparator\u304c0\u3092\u8fd4\u3057\u305f\u3068\u304d\u3001\u305d\u308c\u3089\u306e\u9806\u5e8f\u306f\u4fdd\u8a3c\u3057\u306a\u3044\n    (TreeSet, TreeMap\u3068\u9055\u3044\u524a\u9664\u306f\u3057\u306a\u3044)\n   */\n  static class TreeList<E> extends ArrayList<E> {\n\n    Comparator<? super E> comparator;\n\n    TreeList(Comparator<? super E> c) {\n      super();\n      comparator = c;\n    }\n\n    /*\n      \u30bd\u30fc\u30c8\u6e08\u307f\u306e\u30ea\u30b9\u30c8\u306b\u8981\u7d20\u3092\u8ffd\u52a0\u3059\u308b\n     */\n    public boolean add(E e) {\n      int lowIndex = 0;\n      int highIndex = size() - 1;\n      int index = 0;\n\n      if (size() == 0) {\n        super.add(e);\n        return true;\n      }\n\n      if (comparator.compare(e, get(0)) < 0) {\n        index = 0;\n      } else if (comparator.compare(e, get(highIndex)) > 0) {\n        index = highIndex + 1;\n      } else {\n        while (lowIndex <= highIndex) {\n\n          if (highIndex == lowIndex + 1 || highIndex == lowIndex) {\n            index = highIndex;\n            break;\n          }\n\n          int midIndex = (lowIndex + highIndex) / 2;\n          ;\n\n          if (comparator.compare(e, get(midIndex)) > 0) {\n            lowIndex = midIndex;\n          } else {\n            highIndex = midIndex;\n          }\n\n        }\n      }\n\n      super.add(index, e);\n      return true;\n    }\n\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n}\nGicen the following input:\n-9\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "1011\n",
        "predict": "1001END-OF-OUTPUT"
    }
}