{
    "0": {
        "prompt": "Consider the following code:\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final long MOD = 998244353;\n\n\tpublic static void main(String[] args) {\n\t\tchar[] S = sc.next().toCharArray();\n\t\tint N = S.length;\n\t\tlong[] pow3 = new long[N + 1];\n\t\tpow3[0] = 1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpow3[i + 1] = pow3[i] * 3 % MOD;\n\t\t}\n\t\tBits bsf1 = new Bits(N + 64);\n\t\tBits bsf2 = new Bits(N + 64);\n\t\tBits bsb1 = new Bits(N + 64);\n\t\tBits bsb2 = new Bits(N + 64);\n\t\tint Q = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (S[i] == 'G') {\n\t\t\t\tbsf1.set(i);\n\t\t\t} else if (S[i] == '?') {\n\t\t\t\tbsf2.set(i);\n\t\t\t\tQ++;\n\t\t\t}\n\t\t\tif (S[N - 1 - i] == 'U') {\n\t\t\t\tbsb1.set(i);\n\t\t\t} else if (S[N - 1 - i] == '?') {\n\t\t\t\tbsb2.set(i);\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tlong[] buff1 = new long[bsf1.bits.length];\n\t\tlong[] buff2 = new long[bsf1.bits.length];\n\t\tlong[] bufb1 = new long[bsf2.bits.length];\n\t\tlong[] bufb2 = new long[bsf2.bits.length];\n\t\tfor (int i = 1; i < N - 1; i++) {\n\t\t\tif (S[i] == 'M' || S[i] == '?') {\n\t\t\t\tint q = S[i] == 'M' ? Q : Q - 1;\n\t\t\t\tbsf1.copy(buff1, i + 1);\n\t\t\t\tbsf2.copy(buff2, i + 1);\n\t\t\t\tbsb1.copy(bufb1, N - i);\n\t\t\t\tbsb2.copy(bufb2, N - i);\n\t\t\t\tint len = (Math.min(N - 1 - i, i) + 63) / 64;\n\t\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\t\tans += Long.bitCount(buff1[j] & bufb1[j]) * pow3[q];\n\t\t\t\t\tif (q >= 1) {\n\t\t\t\t\t\tans += Long.bitCount(buff1[j] & bufb2[j]) * pow3[q - 1];\n\t\t\t\t\t\tans += Long.bitCount(buff2[j] & bufb1[j]) * pow3[q - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (q >= 2) {\n\t\t\t\t\t\tans += Long.bitCount(buff2[j] & bufb2[j]) * pow3[q - 2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class Bits {\n\t\tlong[] bits;\n\n\t\tBits(int size) {\n\t\t\tbits = new long[(size + 63) / 64];\n\t\t}\n\n\t\tvoid copy(long[] buf, int from) {\n\t\t\tint start = from >> 6;\n\t\t\tint rem = from & 63;\n\t\t\tif (rem == 0) {\n\t\t\t\tfor (int i = start; i < bits.length; i++) {\n\t\t\t\t\tbuf[i - start] = bits[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = start; i < bits.length; i++) {\n\t\t\t\t\tbuf[i - start] = bits[i] >>> rem;\n\t\t\t\t\tif (i < bits.length - 1) {\n\t\t\t\t\t\tbuf[i - start] |= bits[i + 1] << (64 - rem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (start > 0) buf[bits.length - start] = 0;\n\t\t}\n\n\t\tvoid shiftLOr(int shift) {\n\t\t\tint m1 = shift >> 6;\n\t\t\tint m2 = shift & 63;\n\t\t\tif (m2 == 0) {\n\t\t\t\tfor (int i = bits.length - 1 - m1; i >= 0; i--) {\n\t\t\t\t\tbits[i + m1] |= bits[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = bits.length - 1 - m1; i >= 0; i--) {\n\t\t\t\t\tint p1 = i + m1 + 1;\n\t\t\t\t\tint p2 = i + m1;\n\t\t\t\t\tlong v1 = bits[i] >>> (64 - m2);\n\t\t\t\t\tlong v2 = bits[i] << m2;\n\t\t\t\t\tif (p1 < bits.length) {\n\t\t\t\t\t\tbits[p1] |= v1;\n\t\t\t\t\t}\n\t\t\t\t\tbits[p2] |= v2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean get(int pos) {\n\t\t\treturn ((bits[pos >> 6] >>> (pos & 63)) & 1) != 0;\n\t\t}\n\n\t\tvoid set(int pos) {\n\t\t\tbits[pos >> 6] |= (1L << (pos & 63));\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < bits.length; i++) {\n\t\t\t\tsb.append(Long.toString(bits[i], 16));\n\t\t\t\tsb.append(',');\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n}\n\nGicen the following input:\n?MG?\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "3\n",
        "predict": "0\nEND-OF-OUTPUT"
    }
}