{
    "0": {
        "prompt": "Instruction: I want to act as a Java code executor. I will give you a piece of Java code and its input. You need to print the output of the code.\nFor example:\nConsider the following code:\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\t\tBufferedReader br = new BufferedReader(isr);\n\t\t\tString strArr[] = br.readLine().split(\" \");\n\n\t\t\tint n = Integer.parseInt(strArr[0]);\n\t\t\tint a = Integer.parseInt(strArr[1]);\n\t\t\tint b = Integer.parseInt(strArr[2]);\n\t\t\tint answer = 0;\n\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tint num = i;\n\t\t\t\tint sum = 0;\n\n\t\t\t\twhile (num != 0) {\n\t\t\t\t\tsum += num % 10;\n\t\t\t\t\tnum /= 10;\n\t\t\t\t}\n\n\t\t\t\tif (sum >= a && sum <= b ) {\n\t\t\t\t\tanswer = answer + i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\nWhat would be the output of the code execution given the following input:\n20 2 5\nNow think step by step:\nThe variable n, variable a and variable b are initialized with 20, 2 and 5 respectively according to the input. And variable sum is initialized with 0.\nIt enters a for loop and it iterates from 1 to 20 to check each integer i in this range. The value of variable i is also passed to variable num.\nInside the for loop, it calculates the sum of the digits of the current interger num by repeatedlly extracting the digits of number with a while loop and adding it to variable sum.\nThen it checks if the calculated variable sum falls within the range [2, 5]. If it does, it adds the current interger i to variable answer. The condition is met when i is 2,3,4,5,11,12,13,14 and 20.\nAfter the loop finishes, it print the fianl value of variable answer as output, which is 84.\n\nPrint the output of code execution and end your response with \"END-OF-OUTPUT\":\n84\nEND-OF-OUTPUT",
        "status": "NAN"
    },
    "1": {
        "prompt": "Consider the following code:\n\n\n\n\nimport java.awt.Point;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.function.BinaryOperator;\nimport java.util.function.UnaryOperator;\n\npublic class Main implements Runnable{\n\n\tprivate void solve(FastIO io, String[] args) {\n\t\t/*\n\t\t * author: 31536000\n\t\t * AGC041 C\u554f\u984c\n\t\t * \u8003\u5bdf\u30e1\u30e2\n\t\t * \u307e\u305a\u306f\u3001\u69cb\u7bc9\u53ef\u80fd\u306a\u6761\u4ef6\u3092\u8003\u3048\u308b\n\t\t * \u624b\u5143\u3067\u691c\u8a3c\u7d50\u679c\u3001N=3,4,5,6\u306f\u69cb\u7bc9\u53ef\u80fd\n\t\t * \u3068\u308a\u3042\u3048\u305a\u3001N=2\u3092\u9664\u3044\u3066\u307b\u307c\u69cb\u7bc9\u53ef\u80fd\u3068\u8003\u3048\u308b\n\t\t * \u3055\u3066\u3001\u307e\u305a\u69cb\u7bc9\u3067\u304d\u306a\u3044\u5834\u5408\u306e\u6761\u4ef6\u3092\u8003\u3048\u308b\n\t\t * \u7e26\u3068\u6a2a\u304c\u7b49\u3057\u3044\u3068\u3044\u3046\u3053\u3068\u306f\u3069\u3046\u3044\u3046\u3053\u3068\u304b\uff1f\n\t\t * \u5206\u304b\u3089\u306a\u3044\u306d\u3001\u3068\u308a\u3042\u3048\u305a\u30c6\u30b9\u30c8\u30b1\u30fc\u30b9\u7279\u5b9a\u3057\u3066\u3044\u304f\u304b\n\t\t *\n\t\t */\n\t\tint N = io.nextInt();\n\t\tif (N == 2) {\n\t\t\tio.println(-1);\n\t\t} else if (N == 3) {\n\t\t\tio.println(\"aab\");\n\t\t\tio.println(\"b.b\");\n\t\t\tio.println(\"baa\");\n\t\t} else if (N == 5) {\n\t\t\tio.println(\"aabba\");\n\t\t\tio.println(\"bc..a\");\n\t\t\tio.println(\"bc..b\");\n\t\t\tio.println(\"a.ccb\");\n\t\t\tio.println(\"abbaa\");\n\t\t} else if (N % 2 == 0) {\n\t\t\tfor (int y = 0;y < N;++ y) {\n\t\t\t\tfor (int x = 0;x < N;++ x) {\n\t\t\t\t\tif (y / 2 == x / 2) io.print(y % 2 == 0 ? 'a' : 'b');\n\t\t\t\t\telse if ((y + 2) % N / 2 == x / 2) io.print(x % 2 == 0 ? 'c' : 'd');\n\t\t\t\t\telse io.print('.');\n\t\t\t\t}\n\t\t\t\tio.println();\n\t\t\t}\n\t\t} else if ((N - 1) % 6 != 0) {\n\t\t\tchar[][] ans = new char[N][N];\n\t\t\tfor (char[] i : ans) Arrays.fill(i, '.');\n\t\t\tboolean isInner = (N - 5) % 6 == 0;\n\t\t\tif (isInner) {\n\t\t\t\tN -= 2;\n\t\t\t\tfor (int x = 0;x < N;x += 2) {\n\t\t\t\t\tans[0][x] = ans[0][x + 1] = x % 4 == 0 ? 'e' : 'f';\n\t\t\t\t\tans[N + 1][N - x + 1] = ans[N + 1][N - x] = x % 4 == 0 ? 'e' : 'f';\n\t\t\t\t}\n\t\t\t\tfor (int y = 0;y < N;y += 2) {\n\t\t\t\t\tans[y][N + 1] = ans[y + 1][N + 1] = y % 4 == 0 ? 'g' : 'h';\n\t\t\t\t\tans[N - y + 1][0] = ans[N - y][0] = y % 4 == 0 ? 'g' : 'h';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int n = 0;n < (N - 1) / 6;++ n) {\n\t\t\t\tfor (int y = isInner ? 1 : 0;y < (N - 1);y += 2) {\n\t\t\t\t\tint x = (y + 4 * n) % (N - 1);\n\t\t\t\t\tans[y][x] = ans[y][x + 1] = 'a';\n\t\t\t\t\tans[y + 1][x] = ans[y + 1][x + 1] = 'b';\n\t\t\t\t\tx = (y + 2 + 4 * n) % (N - 1);\n\t\t\t\t\tans[y][x] = ans[y + 1][x] = 'c';\n\t\t\t\t\tans[y][x + 1] = ans[y + 1][x + 1] = 'd';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int x = 0;x < (N - 1);x += 2) {\n\t\t\t\tans[isInner ? N : N - 1][isInner ? 1 + x : x] = ans[isInner ? N : N - 1][isInner ? 2 + x : 1 + x] = x % 4 == 0 ? 'i' : 'j';\n\t\t\t}\n\t\t\tfor (int y = 0;y < (N - 1);y += 2) {\n\t\t\t\tans[isInner ? 1 + y : y][isInner ? N : N - 1] = ans[isInner ? 2 + y : 1 + y][isInner ? N : N - 1] = y % 4 == 0 ? 'i' : 'j';\n\t\t\t}\n\t\t\tio.println(ans, \"\\n\", \"\");\n\t\t} else {\n\t\t\tchar[][] ans = new char[N][N];\n\t\t\tfor (char[] i : ans) Arrays.fill(i, '.');\n\t\t\t-- N;\n\t\t\tfor (int y1 = 0;y1 < N;y1 += 6) {\n\t\t\t\tfor (int x1 = 0;x1 < N;x1 += 6) {\n\t\t\t\t\tif (x1 == y1) {\n\t\t\t\t\t\tans[y1][x1] = ans[y1 + 1][x1] = 'a';\n\t\t\t\t\t\tans[y1 + 4][x1 + 4] = ans[y1 + 5][x1 + 4] = 'a';\n\t\t\t\t\t\tans[y1][x1 + 1] = ans[y1 + 1][x1 + 1] = 'b';\n\t\t\t\t\t\tans[y1 + 4][x1 + 5] = ans[y1 + 5][x1 + 5] = 'b';\n\t\t\t\t\t\tans[y1 + 2][x1] = ans[y1 + 2][x1 + 1] = 'c';\n\t\t\t\t\t\tans[y1 + 3][x1 + 2] = ans[y1 + 3][x1 + 3] = 'c';\n\t\t\t\t\t\tans[y1 + 2][x1 + 2] = ans[y1 + 2][x1 + 3] = 'd';\n\t\t\t\t\t\tans[y1 + 3][x1 + 4] = ans[y1 + 3][x1 + 5] = 'd';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tans[y1][x1] = ans[y1 + 1][x1] = (y1 + x1) % 2 == 0 ? 'i' : 'e';\n\t\t\t\t\t\tans[y1 + 2][x1 + 2] = ans[y1 + 3][x1 + 2] = (y1 + x1) % 2 == 0 ? 'i' : 'e';\n\t\t\t\t\t\tans[y1 + 4][x1 + 4] = ans[y1 + 5][x1 + 4] = (y1 + x1) % 2 == 0 ? 'i' : 'e';\n\t\t\t\t\t\tans[y1][x1 + 1] = ans[y1 + 1][x1 + 1] = (y1 + x1) % 2 == 0 ? 'j' : 'f';\n\t\t\t\t\t\tans[y1 + 2][x1 + 3] = ans[y1 + 3][x1 + 3] = (y1 + x1) % 2 == 0 ? 'j' : 'f';\n\t\t\t\t\t\tans[y1 + 4][x1 + 5] = ans[y1 + 5][x1 + 5] = (y1 + x1) % 2 == 0 ? 'j' : 'f';\n\t\t\t\t\t\tans[y1 + 2][x1] = ans[y1 + 2][x1 + 1] = (y1 + x1) % 2 == 0 ? 'k' : 'g';\n\t\t\t\t\t\tans[y1 + 4][x1 + 2] = ans[y1 + 4][x1 + 3] = (y1 + x1) % 2 == 0 ? 'k' : 'g';\n\t\t\t\t\t\tans[y1][x1 + 4] = ans[y1][x1 + 5] = (y1 + x1) % 2 == 0 ? 'k' : 'g';\n\t\t\t\t\t\tans[y1 + 3][x1] = ans[y1 + 3][x1 + 1] = (y1 + x1) % 2 == 0 ? 'l' : 'h';\n\t\t\t\t\t\tans[y1 + 5][x1 + 2] = ans[y1 + 5][x1 + 3] = (y1 + x1) % 2 == 0 ? 'l' : 'h';\n\t\t\t\t\t\tans[y1 + 1][x1 + 4] = ans[y1 + 1][x1 + 5] =  (y1 + x1) % 2 == 0 ? 'l' : 'h';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int x = 0;x < N;x += 2) {\n\t\t\t\tans[N][x] = ans[N][x + 1] = x % 4 == 0 ? 'm' : 'n';\n\t\t\t}\n\t\t\tfor (int y = 0;y < N;y += 2) {\n\t\t\t\tans[y][N] = ans[y + 1][N] = y % 4 == 0 ? 'm' : 'n';\n\t\t\t}\n\t\t\tio.println(ans, \"\\n\", \"\");\n\t\t}\n\n\t}\n\n\t/** \u30c7\u30d0\u30c3\u30b0\u7528\u30b3\u30fc\u30c9\u306e\u304a\u4f9b\u306b */\n\tprivate static boolean DEBUG = false;\n\t/** \u78ba\u4fdd\u3059\u308b\u30e1\u30e2\u30ea\u306e\u5927\u304d\u3055(\u5358\u4f4d: MB)*/\n\tprivate static final long MEMORY = 64;\n\tprivate final FastIO io;\n\tprivate final String[] args;\n\n\tpublic static void main(String[] args) {\n\t        Thread.setDefaultUncaughtExceptionHandler((t, e) -> e.printStackTrace());\n\t        new Thread(null, new Main(args), \"\", MEMORY * 1048576).start();\n\t}\n\n\tpublic Main(String[] args) {\n\t\tthis(new FastIO(), args);\n\t}\n\n\tpublic Main(FastIO io, String... args) {\n\t\tthis.io = io;\n\t\tthis.args = args;\n\t\tif (DEBUG) io.setAutoFlush(true);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tsolve(io, args);\n\t\tio.flush();\n\t}\n\n\t// \u4ee5\u4e0b\u3001\u30e9\u30a4\u30d6\u30e9\u30ea\n\n\t/**\n\t * \u9ad8\u901f\u306a\u5165\u51fa\u529b\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class FastIO {\n\t\tprivate InputStream in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tprivate PrintWriter out;\n\t\tprivate PrintWriter err;\n\t\tprivate boolean autoFlush = false;\n\n\t\tpublic FastIO() {\n\t\t\tthis(System.in, System.out, System.err);\n\t\t}\n\n\t\tpublic FastIO(InputStream in, PrintStream out, PrintStream err) {\n\t\t\tthis.in = in;\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setInputStream(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tpublic final void setInputStream(File in) {\n\t\t\ttry {\n\t\t\t\tthis.in = new FileInputStream(in);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setOutputStream(PrintStream out) {\n\t\t\tthis.out = new PrintWriter(out, false);\n\t\t}\n\n\t\tpublic final void setOutputStream(File out) {\n\t\t\ttry {\n\t\t\t\tthis.out = new PrintWriter(new FileOutputStream(out), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setErrorStream(PrintStream err) {\n\t\t\tthis.err = new PrintWriter(err, false);\n\t\t}\n\n\t\tpublic final void setErrorStream(File err) {\n\t\t\ttry {\n\t\t\t\tthis.err = new PrintWriter(new FileOutputStream(err), false);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic final void setAutoFlush(boolean flush) {\n\t\t\tautoFlush = flush;\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[read++] : -1;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate static boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic final boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic final char nextChar() {\n\t\t\tif (!hasNextByte())  throw new NoSuchElementException();\n\t\t\treturn (char)readByte();\n\t\t}\n\n\t\tpublic final char[][] nextChar(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile (isPrintableChar(b = readByte())) sb.appendCodePoint(b);\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final String nextLine() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile(!isPrintableChar(b = readByte()));\n\t\t\tdo sb.appendCodePoint(b); while(isPrintableChar(b = readByte()) || b == ' ');\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic final long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (!isNumber(b)) throw new NumberFormatException();\n\t\t\twhile (true) {\n\t\t\t\tif (isNumber(b)) {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic final int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic final double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic final int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[] nextInts() {\n\t\t\treturn nextInts(\" \");\n\t\t}\n\n\t\tpublic final int[] nextInts(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tint[] ret = new int[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[] nextLongs() {\n\t\t\treturn nextLongs(\" \");\n\t\t}\n\n\t\tpublic final long[] nextLongs(String parse) {\n\t\t\tString[] get = nextLine().split(parse);\n\t\t\tlong[] ret = new long[get.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic final Point nextPoint() {\n\t\t\treturn new Point(nextInt(), nextInt());\n\t\t}\n\n\t\tpublic final Point[] nextPoint(int width) {\n\t\t\tPoint[] ret = new Point[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextPoint();\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic final boolean print(boolean b) {\n\t\t\tout.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object print(boolean b, Object t, Object f) {\n\t\t\treturn b ? print(t) : print(f);\n\t\t}\n\n\t\tpublic final char print(char c) {\n\t\t\tout.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] print(char[] s) {\n\t\t\tout.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double print(double d) {\n\t\t\tout.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double print(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\tout.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\tout.print((long)d);\n\t\t\tout.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\tout.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float print(float f) {\n\t\t\tout.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int print(int i) {\n\t\t\tout.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long print(long l) {\n\t\t\tout.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object print(Object obj) {\n\t\t\tif (obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) print(obj, \"\\n\", \" \");\n\t\t\t\telse print(obj, \" \");\n\t\t\t} else {\n\t\t\t\tout.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String print(String s) {\n\t\t\tout.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object print(Object array, String... parse) {\n\t\t\tprint(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object print(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tprint(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tprint(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tprint(str);\n\t\t\t\t\tprint(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] print(String parse, Object... args) {\n\t\t\tprint(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tprint(parse);\n\t\t\t\tprint(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void println() {\n\t\t\tout.println();\n\t\t\tif (autoFlush) flush();\n\t\t}\n\n\t\tpublic final boolean println(boolean b) {\n\t\t\tout.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object println(boolean b, Object t, Object f) {\n\t\t\treturn b ? println(t) : println(f);\n\t\t}\n\n\t\tpublic final char println(char c) {\n\t\t\tout.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] println(char[] s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double println(double d) {\n\t\t\tout.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double println(double d, int length) {\n\t\t\tprint(d, length);\n\t\t\tprintln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float println(float f) {\n\t\t\tout.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int println(int i) {\n\t\t\tout.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long println(long l) {\n\t\t\tout.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object println(Object obj) {\n\t\t\tprint(obj);\n\t\t\tprintln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String println(String s) {\n\t\t\tout.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object println(Object array, String... parse) {\n\t\t\tprint(array, parse);\n\t\t\tprintln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final boolean debug(boolean b) {\n\t\t\terr.print(b);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debug(boolean b, Object t, Object f) {\n\t\t\treturn b ? debug(t) : debug(f);\n\t\t}\n\n\t\tpublic final char debug(char c) {\n\t\t\terr.print(c);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debug(char[] s) {\n\t\t\terr.print(s);\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debug(double d) {\n\t\t\terr.print(d);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debug(double d, int length) {\n\t\t\tif (d < 0) {\n\t\t\t\terr.print('-');\n\t\t\t\td = -d;\n\t\t\t}\n\t\t\td += Math.pow(10, -length) / 2;\n\t\t\terr.print((long)d);\n\t\t\terr.print('.');\n\t\t\td -= (long)d;\n\t\t\tfor (int i = 0;i < length;++ i) {\n\t\t\t\td *= 10;\n\t\t\t\terr.print((int)d);\n\t\t\t\td -= (int)d;\n\t\t\t}\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debug(float f) {\n\t\t\terr.print(f);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debug(int i) {\n\t\t\terr.print(i);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debug(long l) {\n\t\t\terr.print(l);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debug(Object obj) {\n\t\t\tif (obj.getClass().isArray()) {\n\t\t\t\tif (obj instanceof boolean[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof byte[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof short[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof int[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof long[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof float[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof double[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof char[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse if (obj instanceof Object[][]) debug(obj, \"\\n\", \" \");\n\t\t\t\telse debug(obj, \" \");\n\t\t\t} else {\n\t\t\t\terr.print(obj);\n\t\t\t\tif (autoFlush) flush();\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debug(String s) {\n\t\t\terr.print(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debug(Object array, String... parse) {\n\t\t\tdebug(array, 0, parse);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn array;\n\t\t}\n\n\t\tprivate final Object debug(Object array, int check, String... parse) {\n\t\t\tif (check >= parse.length) {\n\t\t\t\tif (array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\t\tdebug(array);\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tString str = parse[check];\n\t\t\tif (array instanceof Object[]) {\n\t\t\t\tObject[] obj = (Object[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0], check + 1, parse);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i], check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (array instanceof Collection) {\n\t\t\t\tIterator<?> iter = ((Collection<?>)array).iterator();\n\t\t\t\tif (!iter.hasNext()) return array;\n\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\twhile(iter.hasNext()) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(iter.next(), check + 1, parse);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t}\n\t\t\tif (!array.getClass().isArray()) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (check != parse.length - 1) throw new IllegalArgumentException(\"not equal dimension\");\n\t\t\tif (array instanceof boolean[]) {\n\t\t\t\tboolean[] obj = (boolean[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof byte[]) {\n\t\t\t\tbyte[] obj = (byte[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t} else if (array instanceof short[]) {\n\t\t\t\tshort[] obj = (short[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof int[]) {\n\t\t\t\tint[] obj = (int[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof long[]) {\n\t\t\t\tlong[] obj = (long[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof float[]) {\n\t\t\t\tfloat[] obj = (float[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof double[]) {\n\t\t\t\tdouble[] obj = (double[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else if (array instanceof char[]) {\n\t\t\t\tchar[] obj = (char[]) array;\n\t\t\t\tif (obj.length == 0) return array;\n\t\t\t\tdebug(obj[0]);\n\t\t\t\tfor (int i = 1;i < obj.length;++ i) {\n\t\t\t\t\tdebug(str);\n\t\t\t\t\tdebug(obj[i]);\n\t\t\t\t}\n\t\t\t} else throw new AssertionError();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final Object[] debug(String parse, Object... args) {\n\t\t\tdebug(args[0]);\n\t\t\tfor (int i = 1;i < args.length;++ i) {\n\t\t\t\tdebug(parse);\n\t\t\t\tdebug(args[i]);\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object[] debugf(String format, Object... args) {\n\t\t\terr.printf(format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final Object debugf(Locale l, String format, Object... args) {\n\t\t\terr.printf(l, format, args);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn args;\n\t\t}\n\n\t\tpublic final void debugln() {\n\t\t\terr.println();\n\t\t\tif (autoFlush) flush();\n\t\t}\n\n\t\tpublic final boolean debugln(boolean b) {\n\t\t\terr.println(b);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic final Object debugln(boolean b, Object t, Object f) {\n\t\t\treturn b ? debugln(t) : debugln(f);\n\t\t}\n\n\t\tpublic final char debugln(char c) {\n\t\t\terr.println(c);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic final char[] debugln(char[] s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final double debugln(double d) {\n\t\t\terr.println(d);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final double debugln(double d, int length) {\n\t\t\tdebug(d, length);\n\t\t\tdebugln();\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic final float debugln(float f) {\n\t\t\terr.println(f);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn f;\n\t\t}\n\n\t\tpublic final int debugln(int i) {\n\t\t\terr.println(i);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic final long debugln(long l) {\n\t\t\terr.println(l);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn l;\n\t\t}\n\n\t\tpublic final Object debugln(Object obj) {\n\t\t\tdebug(obj);\n\t\t\tdebugln();\n\t\t\treturn obj;\n\t\t}\n\n\t\tpublic final String debugln(String s) {\n\t\t\terr.println(s);\n\t\t\tif (autoFlush) flush();\n\t\t\treturn s;\n\t\t}\n\n\t\tpublic final Object debugln(Object array, String... parse) {\n\t\t\tdebug(array, parse);\n\t\t\tdebugln();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic final void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = -4702828934863023392L;\n\t\tprotected C lower;\n\t\tprotected C upper;\n\t\tprotected BoundType lowerType;\n\t\tprotected BoundType upperType;\n\t\tprivate Comparator<? super C> comparator;\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tthis(lower, lowerType, upper, upperType, null);\n\t\t}\n\n\t\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tthis.lowerType = lowerType;\n\t\t\tthis.upperType = upperType;\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = lower.compareTo(upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN))return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\n\t\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\t\tif (lower != null && upper != null) {\n\t\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\t\tif (comp > 0) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t\t}\n\n\t\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\t\treturn range((C)null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\t\tC lower = values.iterator().next();\n\t\t\tC upper = lower;\n\t\t\tfor (C i : values) {\n\t\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t\t}\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t\t}\n\n\t\tprotected int compareLower(C value) {\n\t\t\treturn compareLower(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C value, BoundType boundType) {\n\t\t\treturn compareLower(lower, lowerType, value, boundType);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\t\tif (lower == null) return value == null ? 0 : -1;\n\t\t\telse if (value == null) return 1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(lower, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tprotected int compareUpper(C value) {\n\t\t\treturn compareUpper(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C value, BoundType boundType) {\n\t\t\treturn compareUpper(upper, upperType, value, boundType);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\t\tif (upper == null) return value == null ? 0 : 1;\n\t\t\tif (value == null) return -1;\n\t\t\tint compare;\n\t\t\tif (comparator == null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\t\tcompare = comp.compareTo(value);\n\t\t\t} else compare = comparator.compare(upper, value);\n\t\t\tif (compare == 0) {\n\t\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t\t}\n\t\t\treturn compare;\n\t\t}\n\n\t\tpublic boolean hasLowerBound() {\n\t\t\treturn lower != null;\n\t\t}\n\n\t\tpublic C lowerEndpoint() {\n\t\t\tif (hasLowerBound()) return lower;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType lowerBoundType() {\n\t\t\tif (hasLowerBound()) return lowerType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic boolean hasUpperBound() {\n\t\t\treturn upper != null;\n\t\t}\n\n\t\tpublic C upperEndpoint() {\n\t\t\tif (hasUpperBound()) return upper;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\tpublic BoundType upperBoundType() {\n\t\t\tif (hasUpperBound()) return upperType;\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t/**\n\t\t * \u3053\u306e\u533a\u9593\u304c\u7a7a\u96c6\u5408\u304b\u5224\u5b9a\u3057\u307e\u3059\u3002\n\t\t * @return \u7a7a\u96c6\u5408\u306a\u3089\u3070true\n\t\t */\n\t\tpublic boolean isEmpty() {\n\t\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t\t}\n\n\t\t/**\n\t\t * \u4e0e\u3048\u3089\u308c\u305f\u5f15\u6570\u304c\u533a\u9593\u306e\u5de6\u5074\u306b\u4f4d\u7f6e\u3059\u308b\u304b\u5224\u5b9a\u3057\u307e\u3059\u3002<br>\n\t\t * \u63a5\u3059\u308b\u5834\u5408\u306f\u533a\u9593\u306e\u5de6\u5074\u3067\u306f\u306a\u3044\u3068\u5224\u5b9a\u3057\u307e\u3059\u3002\n\t\t * @param value \u8abf\u3079\u308b\u5f15\u6570\n\t\t * @return \u533a\u9593\u306e\u5de6\u5074\u306b\u4f4d\u7f6e\u3059\u308b\u306a\u3089true\n\t\t */\n\t\tpublic boolean isLess(C value) {\n\t\t\treturn isLess(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprotected boolean isLess(C value, BoundType boundType) {\n\t\t\treturn compareLower(value, boundType) > 0;\n\t\t}\n\n\t\t/**\n\t\t * \u4e0e\u3048\u3089\u308c\u305f\u5f15\u6570\u304c\u533a\u9593\u306e\u53f3\u5074\u306b\u4f4d\u7f6e\u3059\u308b\u304b\u5224\u5b9a\u3057\u307e\u3059\u3002<br>\n\t\t * \u63a5\u3059\u308b\u5834\u5408\u306f\u533a\u9593\u306e\u53f3\u5074\u3067\u306f\u306a\u3044\u3068\u5224\u5b9a\u3057\u307e\u3059\u3002\n\t\t * @param value \u8abf\u3079\u308b\u5f15\u6570\n\t\t * @return \u533a\u9593\u306e\u53f3\u5074\u306b\u4f4d\u7f6e\u3059\u308b\u306a\u3089true\n\t\t */\n\t\tpublic boolean isGreater(C value) {\n\t\t\treturn isGreater(value, BoundType.CLOSED);\n\t\t}\n\n\t\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\t\treturn compareUpper(value, boundType) < 0;\n\t\t}\n\n\t\t/**\n\t\t * \u4e0e\u3048\u3089\u308c\u305f\u5f15\u6570\u304c\u533a\u9593\u5185\u306b\u4f4d\u7f6e\u3059\u308b\u304b\u5224\u5b9a\u3057\u307e\u3059\u3002<br>\n\t\t * \u63a5\u3059\u308b\u5834\u5408\u3082\u533a\u9593\u5185\u306b\u4f4d\u7f6e\u3059\u308b\u3068\u5224\u5b9a\u3057\u307e\u3059\u3002\n\t\t * @param value \u8abf\u3079\u308b\u5f15\u6570\n\t\t * @return \u533a\u9593\u5185\u306b\u4f4d\u7f6e\u3059\u308b\u306a\u3089true\n\t\t */\n\t\tpublic boolean contains(C value) {\n\t\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t\t}\n\n\t\t/**\n\t\t * \u4e0e\u3048\u3089\u308c\u305f\u5f15\u6570\u3059\u3079\u3066\u304c\u533a\u9593\u5185\u306b\u4f4d\u7f6e\u3059\u308b\u304b\u5224\u5b9a\u3057\u307e\u3059\u3002<br>\n\t\t * \u63a5\u3059\u308b\u5834\u5408\u3082\u533a\u9593\u5185\u306b\u4f4d\u7f6e\u3059\u308b\u3068\u5224\u5b9a\u3057\u307e\u3059\u3002\n\t\t * @param value \u8abf\u3079\u308b\u8981\u7d20\n\t\t * @return \u5168\u3066\u306e\u8981\u7d20\u304c\u533a\u9593\u5185\u306b\u4f4d\u7f6e\u3059\u308b\u306a\u3089true\n\t\t */\n\t\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\t\tfor (C i : values) if (!contains(i)) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * \u4e0e\u3048\u3089\u308c\u305f\u533a\u9593\u304c\u3053\u306e\u533a\u9593\u306b\u5185\u5305\u3055\u308c\u308b\u304b\u5224\u5b9a\u3057\u307e\u3059\u3002<br>\n\t\t *\n\t\t * @param other\n\t\t * @return \u4e0e\u3048\u3089\u308c\u305f\u533a\u9593\u304c\u3053\u306e\u533a\u9593\u306b\u5185\u5305\u3055\u308c\u308b\u306a\u3089true\n\t\t */\n\t\tpublic boolean encloses(Range<C> other) {\n\t\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t\t}\n\n\t\t/**\n\t\t * \u4e0e\u3048\u3089\u308c\u305f\u533a\u9593\u304c\u3053\u306e\u533a\u9593\u3068\u516c\u5dee\u3059\u308b\u304b\u5224\u5b9a\u3057\u307e\u3059\u3002<br>\n\t\t * \u63a5\u3059\u308b\u5834\u5408\u306f\u516c\u5dee\u3059\u308b\u3082\u306e\u3068\u3057\u307e\u3059\u3002\n\t\t * @param value \u8abf\u3079\u308b\u5f15\u6570\n\t\t * @return \u533a\u9593\u304c\u4ea4\u5dee\u3059\u308b\u306a\u3089true\n\t\t */\n\t\tpublic boolean isConnected(Range<C> other) {\n\t\t\tif (this.isEmpty() || other.isEmpty()) return false;\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (lower == null || upper == null) return true;\n\t\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\t\treturn comp <= 0;\n\t\t}\n\t\t/**\n\t\t * \u3053\u306e\u533a\u9593\u3068\u306e\u7a4d\u96c6\u5408\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param connectedRange \u7a4d\u96c6\u5408\u3092\u6c42\u3081\u308b\u533a\u9593\n\t\t * @return \u7a4d\u96c6\u5408\n\t\t */\n\t\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\t\tif (this.isEmpty() || connectedRange.isEmpty()) {\n\t\t\t\tif (comparator == null) return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t\treturn empty(comparator);\n\t\t\t}\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\t\tlower = connectedRange.lower;\n\t\t\t\tlowerType = connectedRange.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\t\tupper = connectedRange.upper;\n\t\t\t\tupperType = connectedRange.upperType;\n\t\t\t} else {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t}\n\t\t\tif (comparator == null) {\n\t\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t\t}\n\t\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t/**\n\t\t * \u3053\u306e\u533a\u9593\u3068\u306e\u548c\u96c6\u5408\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param other \u548c\u96c6\u5408\u3092\u6c42\u3081\u308b\u533a\u9593\n\t\t * @return \u548c\u96c6\u5408\n\t\t */\n\t\tpublic Range<C> span(Range<C> other) {\n\t\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\t\tC lower, upper;\n\t\t\tBoundType lowerType, upperType;\n\t\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\t\tlower = this.lower;\n\t\t\t\tlowerType = this.lowerType;\n\t\t\t} else {\n\t\t\t\tlower = other.lower;\n\t\t\t\tlowerType = other.lowerType;\n\t\t\t}\n\t\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\t\tupper = this.upper;\n\t\t\t\tupperType = this.upperType;\n\t\t\t} else {\n\t\t\t\tupper = other.upper;\n\t\t\t\tupperType = other.upperType;\n\t\t\t}\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object object) {\n\t\t\tif (this == object) return true;\n\t\t\tif (object instanceof Range) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tif (lower == null && upper == null) return 0;\n\t\t\telse if (lower == null) return upper.hashCode();\n\t\t\telse if (upper == null) return lower.hashCode();\n\t\t\treturn lower.hashCode() ^ upper.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isEmpty()) return \"()\";\n\t\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t\t}\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = 9065915259748260688L;\n\t\tprotected UnaryOperator<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, UnaryOperator<C> func) {\n\t\t\tif (lower == null || upper == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\tif (lower == null) return new IterableRange<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\treturn range(func.apply(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, UnaryOperator<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, UnaryOperator<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprotected class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprotected class EmptyIter implements Iterator<C> {\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic C next() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.apply(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = 5623995336491967216L;\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements UnaryOperator<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer apply(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange() {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(UnaryOperator<Integer> func) {\n\t\t\tsuper(null, BoundType.CLOSED, null, BoundType.CLOSED, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange();\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, UnaryOperator<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, UnaryOperator<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, UnaryOperator<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.apply(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn lower == null || upper == null ? new EmptyIter() : useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u7d50\u5408\u6cd5\u5247\u3092\u6e80\u305f\u3059\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface Associative<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * repeat\u500b\u306eelement\u3092\u9806\u6b21\u6f14\u7b97\u3057\u305f\u5024\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param element \u6f14\u7b97\u3059\u308b\u5024\n\t\t * @param repeat \u7e70\u308a\u8fd4\u3059\u56de\u6570\u30011\u4ee5\u4e0a\u3067\u3042\u308b\u3053\u3068\n\t\t * @return \u6f14\u7b97\u3092+\u3068\u3057\u3066\u3001element + element + ... + element\u3068\u6f14\u7b97\u3092repeat-1\u56de\u884c\u3063\u305f\u5024\n\t\t */\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 1) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = element;\n\t\t\t-- repeat;\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t* \u3053\u306e\u6f14\u7b97\u304c\u9006\u5143\u3092\u6301\u3064\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface Inverse<T> extends BinaryOperator<T>{\n\t\tpublic T inverse(T element);\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u4ea4\u63db\u6cd5\u5247\u3092\u6e80\u305f\u3059\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface Commutative<T> extends BinaryOperator<T>{\n\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u5358\u4f4d\u5143\u3092\u6301\u3064\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface Identity<T> extends BinaryOperator<T>{\n\t\t/**\n\t\t * \u5358\u4f4d\u5143\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @return \u5358\u4f4d\u5143\n\t\t */\n\t\tpublic T identity();\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u7fa4\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface Group<T> extends Monoid<T>, Inverse<T>{\n\t\t/**\n\t\t * repeat\u500b\u306eelement\u3092\u9806\u6b21\u6f14\u7b97\u3057\u305f\u5024\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param element \u6f14\u7b97\u3059\u308b\u5024\n\t\t * @param repeat \u7e70\u308a\u8fd4\u3059\u56de\u6570\n\t\t * @return \u6f14\u7b97\u3092+\u3068\u3057\u3066\u3001element + element + ... + element\u3068\u6f14\u7b97\u3092repeat-1\u56de\u884c\u3063\u305f\u5024\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tT ret = identity();\n\t\t\tif (repeat < 0) {\n\t\t\t\trepeat = -repeat;\n\t\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\t\treturn inverse(ret);\n\t\t\t}\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u30e2\u30ce\u30a4\u30c9\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface Monoid<T> extends Associative<T>, Identity<T> {\n\t\t/**\n\t\t * repeat\u500b\u306eelement\u3092\u9806\u6b21\u6f14\u7b97\u3057\u305f\u5024\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param element \u6f14\u7b97\u3059\u308b\u5024\n\t\t * @param repeat \u7e70\u308a\u8fd4\u3059\u56de\u6570\u30010\u4ee5\u4e0a\u3067\u3042\u308b\u3053\u3068\n\t\t * @return \u6f14\u7b97\u3092+\u3068\u3057\u3066\u3001element + element + ... + element\u3068\u6f14\u7b97\u3092repeat-1\u56de\u884c\u3063\u305f\u5024\n\t\t */\n\t\t@Override\n\t\tpublic default T hyper(T element, int repeat) {\n\t\t\tif (repeat < 0) throw new IllegalArgumentException(\"undefined operation\");\n\t\t\tT ret = identity();\n\t\t\tfor (T mul = element;repeat > 0;repeat >>= 1, mul = apply(mul, mul)) if ((repeat & 1) != 0) ret = apply(ret, mul);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u53ef\u63db\u30e2\u30ce\u30a4\u30c9\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface CommutativeMonoid<T> extends Monoid<T>, Commutative<T> {\n\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u30a2\u30fc\u30d9\u30eb\u7fa4(\u53ef\u63db\u7fa4)\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t */\n\tpublic interface Abelian<T> extends Group<T>, CommutativeMonoid<T> {\n\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u534a\u74b0\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface Semiring<T, A extends CommutativeMonoid<T>, M extends Monoid<T>> {\n\t\tpublic A getAddition();\n\t\tpublic M getMultiplication();\n\t\tpublic default T add(T left, T right) {\n\t\t\treturn getAddition().apply(left, right);\n\t\t}\n\n\t\tpublic default T multiply(T left, T right) {\n\t\t\treturn getMultiplication().apply(left, right);\n\t\t}\n\n\t\tpublic default T additiveIdentity() {\n\t\t\treturn getAddition().identity();\n\t\t}\n\n\t\tpublic default T multipleIdentity() {\n\t\t\treturn getMultiplication().identity();\n\t\t}\n\n\t\tpublic default int characteristic() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u74b0\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface Ring<T, A extends Abelian<T>, M extends Monoid<T>> extends Semiring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u53ef\u63db\u74b0\u306b\u5c5e\u3059\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface CommutativeRing<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends Ring<T, A, M>{\n\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u6574\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface IntegralDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends CommutativeRing<T, A, M>{\n\t\tpublic boolean isDivisible(T left, T right);\n\t\tpublic T divide(T left, T right);\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u6574\u9589\u6574\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface IntegrallyClosedDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegralDomain<T, A, M>{\n\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304cGCD\u6574\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface GCDDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends IntegrallyClosedDomain<T, A, M>{\n\t\tpublic T gcd(T left, T right);\n\t\tpublic T lcm(T left, T right);\n\t}\n\n\t/**\n\t * \u7d20\u5143\u3092\u63d0\u4f9b\u3057\u307e\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u6f14\u7b97\u306e\u578b\n\t */\n\tpublic static class PrimeElement<T> {\n\t\tpublic final T element;\n\t\tpublic PrimeElement(T element) {\n\t\t\tthis.element = element;\n\t\t}\n\t}\n\n\tpublic interface MultiSet<E> extends Collection<E>{\n\t\tpublic int add(E element, int occurrences);\n\t\tpublic int count(Object element);\n\t\tpublic Set<E> elementSet();\n\t\tpublic boolean remove(Object element, int occurrences);\n\t\tpublic int setCount(E element, int count);\n\t\tpublic boolean setCount(E element, int oldCount, int newCount);\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u4e00\u610f\u5206\u89e3\u6574\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface UniqueFactorizationDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends GCDDomain<T, A, M>{\n\t\tpublic MultiSet<PrimeElement<T>> PrimeFactorization(T x);\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u4e3b\u30a4\u30c7\u30a2\u30eb\u6574\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface PrincipalIdealDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends UniqueFactorizationDomain<T, A, M> {\n\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u6574\u57df\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface EuclideanDomain<T, A extends Abelian<T>, M extends CommutativeMonoid<T>> extends PrincipalIdealDomain<T, A, M>{\n\t\tpublic T reminder(T left, T right);\n\t}\n\n\t/**\n\t * \u6f14\u7b97\u304c\u4f53\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u305f\u3081\u306b\u4f7f\u7528\u3059\u308b\u30de\u30fc\u30ab\u30fc\u30fb\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u3059\u3002\n\t * @author 31536000\n\t *\n\t * @param <T> \u4e8c\u9805\u6f14\u7b97\u306e\u578b\n\t * @param <A> \u548c\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t * @param <M> \u7a4d\u306b\u95a2\u3059\u308b\u6f14\u7b97\n\t */\n\tpublic interface Field<T, A extends Abelian<T>, M extends Abelian<T>> extends EuclideanDomain<T, A, M>{\n\t\t@Override\n\t\tpublic default boolean isDivisible(T left, T right) {\n\t\t\treturn !right.equals(additiveIdentity());\n\t\t}\n\n\t\t@Override\n\t\tpublic default T divide(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn multiply(left, getMultiplication().inverse(right));\n\t\t}\n\n\t\t@Override\n\t\tpublic default T reminder(T left, T right) {\n\t\t\tif (isDivisible(left, right)) throw new ArithmeticException(\"divide by Additive Identify\");\n\t\t\treturn additiveIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T gcd(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default T lcm(T left, T right) {\n\t\t\treturn multipleIdentity();\n\t\t}\n\n\t\t@Override\n\t\tpublic default MultiSet<PrimeElement<T>> PrimeFactorization(T x) {\n\t\t\tHashMultiSet<PrimeElement<T>> ret = HashMultiSet.create(1);\n\t\t\tret.add(new PrimeElement<T>(x));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class HashMultiSet<E> implements MultiSet<E>, Serializable{\n\n\t\tprivate static final long serialVersionUID = -8378919645386251159L;\n\t\tprivate final transient HashMap<E, Integer> map;\n\t\tprivate transient int size;\n\n\t\tprivate HashMultiSet() {\n\t\t\tmap = new HashMap<>();\n\t\t\tsize = 0;\n\t\t}\n\n\t\tprivate HashMultiSet(int distinctElements) {\n\t\t\tmap = new HashMap<>(distinctElements);\n\t\t\tsize = 0;\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create() {\n\t\t\treturn new HashMultiSet<>();\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(int distinctElements) {\n\t\t\treturn new HashMultiSet<>(distinctElements);\n\t\t}\n\n\t\tpublic static <E> HashMultiSet<E> create(Iterable<? extends E> elements) {\n\t\t\tHashMultiSet<E> ret = new HashMultiSet<>();\n\t\t\tfor (E i : elements) ret.map.compute(i, (v, e) -> e == null ? 1 : ++e);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean contains(Object o) {\n\t\t\treturn map.containsKey(o);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<E> {\n\n\t\t\tprivate final Iterator<Entry<E, Integer>> iter = map.entrySet().iterator();\n\t\t\tprivate E value;\n\t\t\tprivate int count = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (count > 0) return true;\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\tEntry<E, Integer> entry = iter.next();\n\t\t\t\t\tvalue = entry.getKey();\n\t\t\t\t\tcount = entry.getValue();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic E next() {\n\t\t\t\t-- count;\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<E> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] toArray() {\n\t\t\tObject[] ret = new Object[size];\n\t\t\tint read = 0;\n\t\t\tfor (Entry<E, Integer> i : map.entrySet()) Arrays.fill(ret, read, read += i.getValue(), i.getKey());\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T[] toArray(T[] a) {\n\t\t\tObject[] src = toArray();\n\t\t\tif (a.length < src.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(src, 0, src.length, a.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(src, 0, a, 0, src.length);\n\t\t\treturn a;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(E e) {\n\t\t\tadd(e, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object o) {\n\t\t\treturn remove(o, 1);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean containsAll(Collection<?> c) {\n\t\t\tboolean ret = true;\n\t\t\tfor (Object i : c) ret |= contains(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean addAll(Collection<? extends E> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (E i : c) ret |= add(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean removeAll(Collection<?> c) {\n\t\t\tboolean ret = false;\n\t\t\tfor (Object i : c) ret |= remove(i);\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean retainAll(Collection<?> c) {\n\t\t\treturn removeAll(c);\n\t\t}\n\n\t\t@Override\n\t\tpublic void clear() {\n\t\t\tmap.clear();\n\t\t\tsize = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int add(E element, int occurrences) {\n\t\t\tsize += occurrences;\n\t\t\treturn map.compute(element, (k, v) -> v == null ? occurrences : v + occurrences) - occurrences;\n\t\t}\n\n\t\t@Override\n\t\tpublic int count(Object element) {\n\t\t\treturn map.getOrDefault(element, 0);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<E> elementSet() {\n\t\t\treturn map.keySet();\n\t\t}\n\n\t\tpublic Set<Entry<E, Integer>> entrySet() {\n\t\t\treturn map.entrySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean remove(Object element, int occurrences) {\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tE put = (E) element;\n\t\t\t\treturn map.compute(put, (k, v) -> {\n\t\t\t\t\tif (v == null) return null;\n\t\t\t\t\tif (v < occurrences) {\n\t\t\t\t\t\tsize -= v;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tsize -= occurrences;\n\t\t\t\t\treturn v - occurrences;\n\t\t\t\t}) != null;\n\t\t\t} catch (ClassCastException E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int setCount(E element, int count) {\n\t\t\tInteger ret = map.put(element, count);\n\t\t\tint ret2 = ret == null ? 0 : ret;\n\t\t\tsize += count - ret2;\n\t\t\treturn ret2;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean setCount(E element, int oldCount, int newCount) {\n\t\t\tboolean ret = map.replace(element, oldCount, newCount);\n\t\t\tif (ret) size += newCount - oldCount;\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic static class ModInteger extends Number implements Field<ModInteger, Abelian<ModInteger>, Abelian<ModInteger>>{\n\n\t\tprivate static final long serialVersionUID = -8595710127161317579L;\n\t\tprivate final int mod;\n\t\tprivate int num;\n\n\t\tprivate final Addition add;\n\t\tprivate final Multiplication mul;\n\n\t\tprivate class Addition implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.mod - element.num);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).addEqual(right);\n\t\t\t}\n\t\t}\n\n\t\tprivate class Multiplication implements Abelian<ModInteger> {\n\n\t\t\t@Override\n\t\t\tpublic ModInteger identity() {\n\t\t\t\treturn new ModInteger(mod, 1);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger apply(ModInteger left, ModInteger right) {\n\t\t\t\treturn new ModInteger(left).multiplyEqual(right);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ModInteger inverse(ModInteger element) {\n\t\t\t\treturn new ModInteger(element, element.inverse(element.num));\n\t\t\t}\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int characteristic() {\n\t\t\treturn mod;\n\t\t}\n\n\t\tpublic ModInteger(int mod) {\n\t\t\tthis.mod = mod;\n\t\t\tnum = 0;\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(int mod, int num) {\n\t\t\tthis.mod = mod;\n\t\t\tthis.num = validNum(num);\n\t\t\tadd = new Addition();\n\t\t\tmul = new Multiplication();\n\t\t}\n\n\t\tpublic ModInteger(ModInteger n) {\n\t\t\tmod = n.mod;\n\t\t\tnum = n.num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate ModInteger(ModInteger n, int num) {\n\t\t\tmod = n.mod;\n\t\t\tthis.num = num;\n\t\t\tadd = n.add;\n\t\t\tmul = n.mul;\n\t\t}\n\n\t\tprivate int validNum(int n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn n;\n\t\t}\n\n\t\tprivate int validNum(long n) {\n\t\t\tn %= mod;\n\t\t\tif (n < 0) n += mod;\n\t\t\treturn (int)n;\n\t\t}\n\n\t\tprotected int inverse(int n) {\n\t\t\tint m = mod, u = 0, v = 1, t;\n\t\t\twhile(n != 0) {\n\t\t\t\tt = m / n;\n\t\t\t\tm -= t * n;\n\t\t\t\tu -= t * v;\n\t\t\t\tif (m != 0) {\n\t\t\t\t\tt = n / m;\n\t\t\t\t\tn -= t * m;\n\t\t\t\t\tv -= t * u;\n\t\t\t\t} else {\n\t\t\t\t\tv %= mod;\n\t\t\t\t\tif (v < 0) v += mod;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu %= mod;\n\t\t\tif (u < 0) u += mod;\n\t\t\treturn u;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\tif ((n & 1) == 0) return false; // \u5076\u6570\n\t\t\tfor (int i = 3, j = 8, k = 9;k <= n;i += 2, k += j += 8) if (n % i == 0) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn num;\n\t\t}\n\n\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\treturn new ModInteger(mod);\n\t\t}\n\n\t\tpublic ModInteger add(int n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(long n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger add(ModInteger n) {\n\t\t\treturn getNewInstance(this).addEqual(n);\n\t\t}\n\n\t\tpublic ModInteger addEqual(int n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(long n) {\n\t\t\tnum = validNum(num + n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger addEqual(ModInteger n) {\n\t\t\tif ((num += n.num) >= mod) num -= mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtract(int n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(long n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtract(ModInteger n) {\n\t\t\treturn getNewInstance(this).subtractEqual(n);\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(int n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(long n) {\n\t\t\tnum = validNum(num - n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger subtractEqual(ModInteger n) {\n\t\t\tif ((num -= n.num) < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiply(int n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(long n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiply(ModInteger n) {\n\t\t\treturn getNewInstance(this).multiplyEqual(n);\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(int n) {\n\t\t\tnum = (int)((long)num * n % mod);\n\t\t\tif (num < 0) num += mod;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(long n) {\n\t\t\treturn multiplyEqual((int) (n % mod));\n\t\t}\n\n\t\tpublic ModInteger multiplyEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.num % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divide(int n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(long n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divide(ModInteger n) {\n\t\t\treturn getNewInstance(this).divideEqual(n);\n\t\t}\n\n\t\tpublic ModInteger divideEqual(int n) {\n\t\t\tnum = (int)((long)num * inverse(validNum(n)) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger divideEqual(long n) {\n\t\t\treturn divideEqual((int)(n % mod));\n\t\t}\n\n\t\tpublic ModInteger divideEqual(ModInteger n) {\n\t\t\tnum = (int)((long)num * n.inverse(n.num) % mod);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger pow(int n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(long n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger pow(ModInteger n) {\n\t\t\treturn getNewInstance(this).powEqual(n);\n\t\t}\n\n\t\tpublic ModInteger powEqual(int n) {\n\t\t\tlong ans = 1, num = this.num;\n\t\t\tif (n < 0) {\n\t\t\t\tn = -n;\n\t\t\t\twhile (n != 0) {\n\t\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tn >>>= 1;\n\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\tthis.num = inverse((int)ans);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\twhile (n != 0) {\n\t\t\t\tif ((n & 1) != 0) ans = ans * num % mod;\n\t\t\t\tn >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\tthis.num = (int)ans;\n\t\t\treturn this;\n\t\t}\n\t\tpublic ModInteger powEqual(long n) {\n\t\t\treturn powEqual((int)(n % (mod - 1)));\n\t\t}\n\n\t\tpublic ModInteger powEqual(ModInteger n) {\n\t\t\tlong num = this.num;\n\t\t\tthis.num = 1;\n\t\t\tint mul = n.num;\n\t\t\twhile (mul != 0) {\n\t\t\t\tif ((mul & 1) != 0) this.num *= num;\n\t\t\t\tmul >>>= 1;\n\t\t\t\tnum *= num;\n\t\t\t\tnum %= mod;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(int n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(long n) {\n\t\t\tnum = validNum(n);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ModInteger equal(ModInteger n) {\n\t\t\tnum = n.num;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int toInt() {\n\t\t\treturn num;\n\t\t}\n\n\t\tpublic int getMod() {\n\t\t\treturn mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object x) {\n\t\t\tif (x instanceof ModInteger) return ((ModInteger)x).num == num && ((ModInteger)x).mod == mod;\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn num ^ mod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(num);\n\t\t}\n\n\t\t@Deprecated\n\t\tpublic String debug() {\n\t\t\tint min = num, ans = 1;\n\t\t\tfor (int i = 2;i < min;++ i) {\n\t\t\t\tint tmp = multiply(i).num;\n\t\t\t\tif (min > tmp) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn min + \"/\" + ans;\n\t\t}\n\n\t\t@Override\n\t\tpublic Addition getAddition() {\n\t\t\treturn add;\n\t\t}\n\n\t\t@Override\n\t\tpublic Multiplication getMultiplication() {\n\t\t\treturn mul;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u3092\u6cd5\u3068\u3059\u308b\u6f14\u7b97\u4e0a\u3067\u3001\u7d44\u307f\u5408\u308f\u305b\u306e\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u884c\u3044\u307e\u3059\u3002\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class ModUtility {\n\t\tprivate final int mod;\n\t\tprivate int[] fact, inv, invfact;\n\n\t\t/**\n\t\t * mod\u3092\u6cd5\u3068\u3057\u3066\u3001\u6f14\u7b97\u3092\u884c\u3044\u307e\u3059\u3002\n\t\t * @param mod \u6cd5\u3068\u3059\u308b\u7d20\u6570\n\t\t */\n\t\tpublic ModUtility(Prime mod) {\n\t\t\tthis(mod, 2);\n\t\t}\n\n\t\t/**\n\t\t * mod\u3092\u6cd5\u3068\u3057\u3066\u3001\u6f14\u7b97\u3092\u884c\u3044\u307e\u3059\u3002\n\t\t * @param mod \u6cd5\u3068\u3059\u308b\u7d20\u6570\n\t\t * @param calc \u4e88\u3081\u524d\u8a08\u7b97\u3057\u3066\u304a\u304f\u5927\u304d\u3055\n\t\t */\n\t\tpublic ModUtility(Prime mod, int calc) {\n\t\t\tthis.mod = mod.prime;\n\t\t\tprecalc(calc);\n\t\t}\n\n\t\t/**\n\t\t * calc\u306e\u5927\u304d\u3055\u3060\u3051\u3001\u524d\u8a08\u7b97\u3092\u884c\u3044\u307e\u3059\u3002\n\t\t * @param calc \u524d\u8a08\u7b97\u3092\u3059\u308b\u5927\u304d\u3055\n\t\t */\n\t\tpublic void precalc(int calc) {\n\t\t\t++ calc;\n\t\t\tif (calc < 2) calc = 2;\n\t\t\tfact = new int[calc];\n\t\t\tinv = new int[calc];\n\t\t\tinvfact = new int[calc];\n\t\t\tfact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n\t\t\tfor (int i = 2;i < calc;++ i) {\n\t\t\t\tfact[i] = (int)((long)fact[i - 1] * i % mod);\n\t\t\t\tinv[i] = (int)(mod - (long)inv[mod % i] * (mod / i) % mod);\n\t\t\t\tinvfact[i] = (int)((long)invfact[i - 1] * inv[i] % mod);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\u3092\u6cd5\u3068\u3059\u308b\u5270\u4f59\u74b0\u4e0a\u3067\u632f\u821e\u3046\u6574\u6570\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @return mod\u3092\u6cd5\u3068\u3059\u308b\u6574\u6570\u3001\u521d\u671f\u5024\u306f0\n\t\t */\n\t\tpublic ModInteger create() {\n\t\t\treturn new ModInt();\n\t\t}\n\n\t\t/**\n\t\t * mod\u3092\u6cd5\u3068\u3059\u308b\u5270\u4f59\u74b0\u4e0a\u3067\u632f\u821e\u3046\u6574\u6570\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param n \u521d\u671f\u5024\n\t\t * @return mod\u3092\u6cd5\u3068\u3059\u308b\u6574\u6570\n\t\t */\n\t\tpublic ModInteger create(int n) {\n\t\t\treturn new ModInt(n);\n\t\t}\n\n\t\tprivate class ModInt extends ModInteger {\n\n\t\t\tprivate static final long serialVersionUID = -2435281861935422575L;\n\n\t\t\tpublic ModInt() {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\tpublic ModInt(int n) {\n\t\t\t\tsuper(mod, n);\n\t\t\t}\n\n\t\t\tpublic ModInt(ModInteger mod) {\n\t\t\t\tsuper(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected ModInteger getNewInstance(ModInteger mod) {\n\t\t\t\treturn new ModInt(mod);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected int inverse(int n) {\n\t\t\t\treturn ModUtility.this.inverse(n);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * mod\u3092\u6cd5\u3068\u3057\u3066\u3001n\u306e\u9006\u5143\u3092\u8fd4\u3057\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(log n)\u3067\u3059\u3002\n\t\t * @param n \u9006\u5143\u3092\u6c42\u3081\u305f\u3044\u5024\n\t\t * @return \u9006\u5143\n\t\t */\n\t\tpublic int inverse(int n) {\n\t\t\ttry {\n\t\t\t\tif (inv.length > n) return inv[n];\n\t\t\t\t int m = mod, u = 0, v = 1, t;\n\t\t\t\t while(n != 0) {\n\t\t\t\t\t t = m / n;\n\t\t\t\t\t m -= t * n;\n\t\t\t\t\t u -= t * v;\n\t\t\t\t\t if (m != 0) {\n\t\t\t\t\t\t t = n / m;\n\t\t\t\t\t\t n -= t * m;\n\t\t\t\t\t\t v -= t * u;\n\t\t\t\t\t } else {\n\t\t\t\t\t\t v %= mod;\n\t\t\t\t\t\t if (v < 0) v += mod;\n\t\t\t\t\t\t return v;\n\t\t\t\t\t }\n\t\t\t\t }\n\t\t\t\t u %= mod;\n\t\t\t\t if (u < 0) u += mod;\n\t\t\t\t return u;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * n!\u3092\u3001mod\u3092\u6cd5\u3068\u3057\u3066\u6c42\u3081\u305f\u5024\u3092\u8fd4\u3057\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(n)\u3067\u3059\u3002\n\t\t * @param n \u968e\u4e57\u3092\u6c42\u3081\u305f\u3044\u5024\n\t\t * @return n\u306e\u968e\u4e57\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int factorial(int n) {\n\t\t\ttry {\n\t\t\t\tif (fact.length > n) return fact[n];\n\t\t\t\tlong ret = fact[fact.length - 1];\n\t\t\t\tfor (int i = fact.length;i <= n;++ i) ret = ret * i % mod;\n\t\t\t\treturn (int)ret;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * nPk\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(n-k)\u3067\u3059\u3002\n\t\t * @param n \u5de6\u8fba\n\t\t * @param k \u53f3\u8fba\n\t\t * @return nPk\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int permutation(int n, int k) {\n\t\t\tif (k < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * nCk\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(n-k)\u3067\u3059\u3002\n\t\t * @param n \u5de6\u8fba\n\t\t * @param k \u53f3\u8fba\n\t\t * @return nCk\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int combination(int n, int k) {\n\t\t\tif (k < 0) throw new IllegalArgumentException();\n\t\t\tif (n < k) return 0;\n\t\t\tif (fact.length > n) return (int)((long)fact[n] * invfact[k] % mod * invfact[n - k] % mod);\n\t\t\tlong ret = 1;\n\t\t\tif (n < 2 * k) k = n - k;\n\t\t\tif (invfact.length > k) ret = invfact[k];\n\t\t\telse ret = inverse(factorial(k));\n\t\t\tfor (int i = n - k + 1;i <= n;++ i) ret = ret * i % mod;\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * \u4ed6\u9805\u4fc2\u6570\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u307e\u3059\u3002<br>]\n\t\t * \u8a08\u7b97\u91cf\u306fO(n)\u3067\u3059\u3002\n\t\t * @param n \u5de6\u8fba\n\t\t * @param k \u53f3\u8fba\u3001\u5408\u8a08\u304cn\u4ee5\u4e0b\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\n\t\t * @return \u4ed6\u9805\u4fc2\u6570\n\t\t */\n\t\tpublic int multinomial(int n, int... k) {\n\t\t\tint sum = 0;\n\t\t\tfor (int i : k) sum += i;\n\t\t\tlong ret = factorial(n);\n\t\t\tif (fact.length > n) {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tret = ret * invfact[i] % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tret = ret * invfact[n - sum] % mod;\n\t\t\t} else {\n\t\t\t\tfor (int i : k) {\n\t\t\t\t\tif (i < 0) throw new IllegalArgumentException();\n\t\t\t\t\tif (invfact.length > i) ret = ret * invfact[i] % mod;\n\t\t\t\t\telse ret = ret * inverse(factorial(i)) % mod;\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (sum > n) return 0;\n\t\t\t\tif (invfact.length > n - sum) ret = ret * invfact[n - sum] % mod;\n\t\t\t\telse ret = ret * inverse(factorial(n - sum)) % mod;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\n\t\t/**\n\t\t * n\u500b\u304b\u3089k\u500b\u3092\u9078\u3076\u91cd\u8907\u7d44\u307f\u5408\u308f\u305bnHk\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(min(n, k))\u3067\u3059\u3002\n\t\t * @param n \u5de6\u8fba\n\t\t * @param k \u53f3\u8fba\n\t\t * @return nHk\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int multichoose(int n, int k) {\n\t\t\treturn combination(mod(n + k - 1), k);\n\t\t}\n\n\t\t/**\n\t\t * \u30ab\u30bf\u30e9\u30f3\u6570C(n)\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(n)\u3067\u3059\u3002\n\t\t * @param n \u6c42\u3081\u305f\u3044\u30ab\u30bf\u30e9\u30f3\u6570\u306e\u756a\u53f7\n\t\t * @return \u30ab\u30bf\u30e9\u30f3\u6570\n\t\t */\n\t\tpublic int catalan(int n) {\n\t\t\treturn divide(combination(mod(2 * n), n), mod(n + 1));\n\t\t}\n\n\t\t/**\n\t\t * n\u306em\u4e57\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(log m)\u3067\u3059\u3002\n\t\t * @param n \u5e8a\n\t\t * @param m \u51aa\u6307\u6570\n\t\t * @return n^m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int pow(int n, int m) {\n\t\t\tlong ans = 1, num = n;\n\t\t\tif (m < 0) {\n\t\t\t\tm = -m;\n\t\t\t\twhile (m != 0) {\n\t\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\t\tm >>>= 1;\n\t\t\t\t\tnum = num * num % mod;\n\t\t\t\t}\n\t\t\t\treturn inverse((int)ans);\n\t\t\t}\n\t\t\twhile (m != 0) {\n\t\t\t\tif ((m & 1) != 0) ans = ans * num % mod;\n\t\t\t\tm >>>= 1;\n\t\t\t\tnum = num * num % mod;\n\t\t\t}\n\t\t\treturn (int)ans;\n\t\t}\n\n\t\t/**\n\t\t * n\u306em\u4e57\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(log m)\u3067\u3059\u3002\n\t\t * @param n \u5e8a\n\t\t * @param m \u51aa\u6307\u6570\n\t\t * @return n^m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int pow(long n, long m) {\n\t\t\treturn pow((int)(n % mod), (int)(n % (mod - 1)));\n\t\t}\n\n\t\t/**\n\t\t * \u73fe\u5728\u306emod\u5024\u306e\u30c8\u30fc\u30b7\u30a7\u30f3\u30c8\u6570\u3092\u8fd4\u3057\u307e\u3059\u3002<br>\n\t\t * \u306a\u304a\u3001\u3053\u308c\u306fmod-1\u306b\u7b49\u3057\u3044\u3067\u3059\u3002\n\t\t * @return \u30c8\u30fc\u30b7\u30a7\u30f3\u30c8\u6570\n\t\t */\n\t\tpublic int totient() {\n\t\t\treturn mod - 1;\n\t\t}\n\n\t\t/**\n\t\t * n\u306e\u30c8\u30fc\u30b7\u30a7\u30f3\u30c8\u6570\u3092\u8fd4\u3057\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(sqrt n)\u3067\u3059\u3002\n\t\t * @param n \u30c8\u30fc\u30b7\u30a7\u30f3\u30c8\u6570\u3092\u6c42\u3081\u305f\u3044\u5024\n\t\t * @return n\u306e\u30c8\u30fc\u30b7\u30a7\u30f3\u30c8\u6570\n\t\t */\n\t\tpublic static int totient(int n) {\n\t\t\tint totient = n;\n\t\t\tfor (int i = 2;i * i <= n;++ i) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\ttotient = totient / i * (i - 1);\n\t\t\t\t\twhile ((n %= i) % i == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n != 1) totient = totient / n * (n - 1);\n\t\t\treturn totient;\n\t\t}\n\n\t\t/**\n\t\t * n\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param n \u6f14\u7b97\u3059\u308b\u5024\n\t\t * @return n\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int mod(int n) {\n\t\t\treturn (n %= mod) < 0 ? n + mod : n;\n\t\t}\n\n\t\t/**\n\t\t * n\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param n \u6f14\u7b97\u3059\u308b\u5024\n\t\t * @return n\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int mod(long n) {\n\t\t\treturn (int)((n %= mod) < 0 ? n + mod : n);\n\t\t}\n\n\t\t/**\n\t\t * n+m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param n \u8db3\u3055\u308c\u308b\u5024\n\t\t * @param m \u8db3\u3059\u5024\n\t\t * @return n+m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int add(int n, int m) {\n\t\t\treturn mod(n + m);\n\t\t}\n\n\t\t/**\n\t\t * n-m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param n \u5f15\u304b\u308c\u308b\u5024\n\t\t * @param m \u5f15\u304f\u5024\n\t\t * @return n-m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int subtract(int n, int m) {\n\t\t\treturn mod(n - m);\n\t\t}\n\n\t\t/**\n\t\t * n*m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param n \u639b\u3051\u3089\u308c\u308b\u5024\n\t\t * @param m \u639b\u3051\u308b\u5024\n\t\t * @return n*m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int multiply(int n, int m) {\n\t\t\tint ans = (int)((long)n * m % mod);\n\t\t\treturn ans < 0 ? ans + mod : ans;\n\t\t}\n\n\t\t/**\n\t\t * n/m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3057\u307e\u3059\u3002\n\t\t * @param n \u5272\u3089\u308c\u308b\u5024\n\t\t * @param m \u5272\u308b\u5024\n\t\t * @return n/m\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic int divide(int n, int m) {\n\t\t\treturn multiply(n, inverse(m));\n\t\t}\n\n\t\t/**\n\t\t * f\u3092\u901a\u308b\u3053\u3068\u304c\u5206\u304b\u3063\u3066\u3044\u308bf\u306e\u8981\u7d20\u6570-1\u6b21\u306e\u95a2\u6570\u306b\u3064\u3044\u3066\u3001x\u306e\u4f4d\u7f6e\u306b\u304a\u3051\u308b\u5024\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u8fd4\u3057\u307e\u3059\u3002<br>\n\t\t * \u8a08\u7b97\u91cf\u306fO(f)\u3067\u3059\u3002\n\t\t * @param f \u95a2\u6570\u306e\u5f62\n\t\t * @param x \u6c42\u3081\u308b\u4f4d\u7f6e\n\t\t * @return \u6c42\u3081\u305f\u3044\u5024\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a\n\t\t */\n\t\tpublic ModInteger lagrangePolynomial(ModInteger[] f, int x) {\n\t\t\tif (f.length > x) return f[x];\n\t\t\tif (x > fact.length) precalc(x);\n\t\t\tModInteger ret = create(0);\n\t\t\tModInteger[] dp = new ModInteger[f.length], dp2 = new ModInteger[f.length];\n\t\t\tdp[0] = create(1);\n\t\t\tdp2[f.length - 1] = create(1);\n\t\t\tfor (int i = 1;i < f.length;++ i) {\n\t\t\t\tdp[i] = dp[i - 1].multiply(x - i - 1);\n\t\t\t\tdp2[f.length - i - 1] = dp2[f.length - i].multiply(x - f.length + i);\n\t\t\t}\n\t\t\tfor (int i = 0;i < f.length;++ i) {\n\t\t\t\tModInteger tmp = f[i].multiply(dp[i]).multiplyEqual(dp2[i]).multiplyEqual(inv[i]).multiplyEqual(inv[f.length - 1 - i]);\n\t\t\t\tif ((f.length - i & 1) == 0) ret.addEqual(tmp);\n\t\t\t\telse ret.subtractEqual(tmp);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u3092\u6e21\u3059\u305f\u3081\u306e\u30af\u30e9\u30b9\u3067\u3059\u3002<br>\n\t * \u4e2d\u8eab\u304c\u78ba\u5b9f\u306b\u7d20\u6570\u3067\u3042\u308b\u3053\u3068\u3092\u4fdd\u8a3c\u3059\u308b\u3068\u304d\u306b\u4f7f\u3063\u3066\u304f\u3060\u3055\u3044\u3002\n\t *\n\t * @author 31536000\n\t *\n\t */\n\tpublic static class Prime extends Number{\n\n\t\tprivate static final long serialVersionUID = 8216169308184181643L;\n\t\tpublic final int prime;\n\n\t\t/**\n\t\t * \u7d20\u6570\u3092\u8a2d\u5b9a\u3057\u307e\u3059\u3002\n\t\t *\n\t\t * @param prime \u7d20\u6570\n\t\t * @throws IllegalArgumentException \u7d20\u6570\u4ee5\u5916\u3092\u6e21\u3057\u305f\u6642\n\t\t */\n\t\tpublic Prime(int prime) {\n\t\t\tif (!isPrime(prime)) throw new IllegalArgumentException(prime + \" is not prime\");\n\t\t\tthis.prime = prime;\n\t\t}\n\n\t\tprivate static final int bases[] = {15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620, 560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462, 10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298, 1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746, 2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373, 6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371, 658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969, 4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435, 165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354, 4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873, 1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222, 2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725, 3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867, 10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029, 8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115, 368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333, 3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845, 8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304, 272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922, 350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412, 1559, 194};\n\n\t\tprivate static boolean isSPRP(int n, int a) {\n\t\t\tint d = n - 1, s = 0;\n\t\t\twhile ((d & 1) == 0) {\n\t\t\t\t++s;\n\t\t\t\td >>= 1;\n\t\t\t}\n\t\t\tlong cur = 1, pw = d;\n\t\t\twhile (pw != 0) {\n\t\t\t\tif ((pw & 1) != 0) cur = (cur * a) % n;\n\t\t\t\ta = (int)(((long)a * a) % n);\n\t\t\t\tpw >>= 1;\n\t\t\t}\n\t\t\tif (cur == 1) return true;\n\t\t\tfor (int r = 0; r < s; r++ ) {\n\t\t\t\tif (cur == n - 1) return true;\n\t\t\t\tcur = (cur * cur) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * \u4e0e\u3048\u3089\u308c\u305f\u5024\u304c\u7d20\u6570\u304b\u5426\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\u3002<br>\n\t\t * \u3053\u306e\u5b9f\u88c5\u306fhttp://ceur-ws.org/Vol-1326/020-Forisek.pdf\u306b\u57fa\u3065\u304d\u307e\u3059\u3002\n\t\t * @param x \u5224\u5b9a\u3057\u305f\u3044\u5024\n\t\t * @return x\u304c\u7d20\u6570\u306a\u3089true\n\t\t */\n\t\tpublic static boolean isPrime(int x) {\n\t\t\tif (x == 2 || x == 3 || x == 5 || x == 7) return true;\n\t\t\tif ((x & 1) == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;\n\t\t\tif (x < 121) return x > 1;\n\t\t\tlong h = x;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) * 0x45d9f3b;\n\t\t\th = ((h >> 16) ^ h) & 0xFF;\n\t\t\treturn isSPRP(x, bases[(int)h]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int intValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic long longValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic float floatValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic double doubleValue() {\n\t\t\treturn prime;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.valueOf(prime);\n\t\t}\n\t}\n\n\tpublic static class AbstractArray<T> extends AbstractList<T> implements RandomAccess{\n\n\t\tprivate final Object[] array;\n\n\t\tpublic AbstractArray(int size) {\n\t\t\tarray = new Object[size];\n\t\t}\n\n\t\tpublic AbstractArray(T[] array) {\n\t\t\tthis(array.length);\n\t\t\tSystem.arraycopy(array, 0, this.array, 0, array.length);\n\t\t}\n\n\t\t@Override\n\t\tpublic T set(int index, T element) {\n\t\t\tT ret = get(index);\n\t\t\tarray[index] = element;\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic T get(int index) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT ret = (T)array[index];\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Object[] get() {\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic T[] get(T[] array) {\n\t\t\tif (array.length < this.array.length) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tT[] ret  = (T[])Arrays.copyOfRange(this.array, 0, this.array.length, array.getClass());\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tSystem.arraycopy(this.array, 0, array, 0, this.array.length);\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int size() {\n\t\t\treturn array.length;\n\t\t}\n\n\t\tpublic int length() {\n\t\t\treturn size();\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\n\t\tprivate class Iter implements Iterator<T> {\n\t\t\tprivate int index;\n\n\t\t\tprivate Iter() {\n\t\t\t\tindex = 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn index < array.length;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic T next() {\n\t\t\t\treturn get(index++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\t}\n\n\tpublic static class Array<T> extends AbstractArray<T> implements Serializable{\n\n\t\tprivate static final long serialVersionUID = 2749604433067098063L;\n\n\t\tpublic Array(int size) {\n\t\t\tsuper(size);\n\t\t}\n\n\t\tpublic Array(T[] array) {\n\t\t\tsuper(array);\n\t\t}\n\n\t\tpublic T front() {\n\t\t\treturn get(0);\n\t\t}\n\n\t\tpublic T back() {\n\t\t\treturn get(size() - 1);\n\t\t}\n\t}\n}\n\nWhat would be the output of the code execution given the following input:\n6\nNow think step by step:",
        "status": "NAN"
    },
    "2": {
        "prompt": "Print the output of code execution and end your response with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "aabb..\nb..zz.\nba....\n.a..aa\n..a..b\n..a..b\n"
    }
}