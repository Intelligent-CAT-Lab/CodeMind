{
    "0": {
        "prompt": "Consider the following code:\nimport java.awt.*;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigDecimal;\nimport java.util.*;\nimport java.util.List;\nimport java.util.concurrent.DelayQueue;\nimport java.util.function.IntFunction;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner();\n        int x= scanner.nextInt();\n        int y= scanner.nextInt();\n        put(x+y/2);\n\n\n    }\n\n\n    public static int upper_bound(int[] a,int val){\n        return upper_bound(a,0,a.length,val);\n    }\n    public static int upper_bound(int[] a,int l,int r,int val){\n        if(r-l==1){\n            if(a[l]>val) return l;\n            return r;\n        }\n        int mid=(l+r)/2;\n        if(a[mid]>val){\n            return upper_bound(a,l,mid,val);\n        }else{\n            return upper_bound(a,mid,r,val);\n        }\n    }\n    public static int lower_bound(int[] a,int val){\n        return lower_bound(a,0,a.length,val);\n    }\n    public static int lower_bound(int[] a,int l,int r,int val){\n        if(r-l==1){\n            if(a[l]<val) return r;\n            return l;\n        }\n        int mid=(l+r)/2;\n        if(a[mid]<val){\n            return lower_bound(a,mid,r,val);\n        }else{\n            return lower_bound(a,l,mid,val);\n        }\n\n    }\n\n\n    public static int max(int a,int b){\n        return Math.max(a,b);\n    }\n    public static long max(long a,long b){\n        return Math.max(a,b);\n    }\n    public static int min(int a,int b){\n        return Math.min(a,b);\n    }\n    public static long min(long a,long b){\n        return Math.min(a,b);\n    }\n    public static int abs(int a){\n        return Math.abs(a);\n    }\n    public static long abs(long a){\n        return Math.abs(a);\n    }\n    public static void print(Object object){\n        System.out.print(object);\n    }\n    public static void put(Object object) {\n        System.out.println(object);\n    }\n    public static void put(){\n        System.out.println();\n    }\n    public static String format(String string, Object... args) {\n        return String.format(string, args);\n    }\n}\n\nfinal class Scanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte())\n            return buffer[ptr++];\n        else\n            return -1;\n    }\n\n    private boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n            ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n            throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\nfinal class FixedPair {\n    final private int x, y;\n    final static public FixedPair ZEROS=new FixedPair(0,0);\n    FixedPair(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    @Override\n    public int hashCode() {\n        return x+y;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        boolean result=super.equals(obj);\n        if(obj.getClass()!=this.getClass()){\n            return false;\n        }\n        FixedPair pair=(FixedPair)obj;\n        if(this.x==pair.x&&this.y==pair.y) return true;\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"(%d,%d)\", x, y);\n    }\n}\nfinal class Tuple<T,V>{\n    //immutabl1\u3067\u306a\u3044\u3053\u3068\u306b\u6ce8\u610f(T,V\u304cmutable\u306e\u5834\u5408\u5909\u66f4\u53ef\u80fd)\n    final private T t;\n    final private V v;\n    Tuple(T t,V v){\n        this.t=t;\n        this.v=v;\n    }\n\n    public T getT() {\n        return t;\n    }\n\n    public V getV() {\n        return v;\n    }\n\n    @Override\n    public int hashCode() {\n        return (t.hashCode()+v.hashCode());\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean equals(Object obj) {\n        if(obj.getClass()!=this.getClass()){\n            return false;\n        }\n        Tuple<T,V> tuple=(Tuple<T, V>) obj;\n        return tuple.t.equals(this.t)&&tuple.v.equals(this.v);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"<Tuple>=<%s,%s>\",t,v);\n    }\n}\nfinal class LowerBoundComparator<T extends Comparable<? super T>>\n        implements Comparator<T>\n{\n    public int compare(T x, T y)\n    {\n        return (x.compareTo(y) >= 0) ? 1 : -1;\n    }\n}\n\nfinal class UpperBoundComparator<T extends Comparable<? super T>>\n        implements Comparator<T>\n{\n    public int compare(T x, T y)\n    {\n        return (x.compareTo(y) > 0) ? 1 : -1;\n    }\n}\nfinal class Util {\n    static long gcd(long a,long b){\n        if(a%b==0)return b;\n        return gcd(b,a%b);\n    }\n    static long lcm(long a,long b){\n        long gcd=gcd(a,b);\n        long result=b/gcd;\n        return a*result;\n    }\n    static long kaijoMod(int n,int mod){\n        if(n<1) return -1;\n        long result=1;\n        for(int i=n;i>1;i--){\n            result*=i;\n            result%=mod;\n        }\n        return result;\n    }\n    static <T extends Comparable<T>> Map<T,Integer> count(List<T> list){\n        //\u526f\u4f5c\u7528\n        Collections.sort(list);\n        Map<T,Integer> result=new HashMap<>();\n        int l=0,r=0;\n        while(l<list.size()){\n            while(r<list.size()-1&&list.get(r).equals(r+1)){\n                r++;\n            }\n            result.put(list.get(r),r-l+1);\n            r++;\n            l=r;\n        }\n        return result;\n\n    }\n    static Map<Integer,Integer> count(int[] array){\n        //\u526f\u4f5c\u7528\n        Arrays.sort(array);\n        Map<Integer,Integer> result=new HashMap<>();\n        int l=0,r=0;\n        while(l<array.length){\n            while(r<array.length-1&&array[r]==array[r+1]){\n                r++;\n            }\n            result.put(array[l],r-l+1);\n            r++;\n            l=r;\n        }\n        return result;\n    }\n    static <T> String toStringBWS(Iterable<T> iterable){\n        Iterator<T> ite=iterable.iterator();\n        return toStringBWS(ite);\n    }\n    static <T> String toStringBWS(Iterator<T> ite){\n        StringBuilder sb=new StringBuilder();\n        sb.append(ite.next());\n        while(ite.hasNext()){\n            sb.append(\" \");\n            sb.append(ite.next());\n        }\n        return sb.toString();\n    }\n    static String toStringBWS(int[] array){\n        StringBuilder sb=new StringBuilder();\n        for(int i=0;i<array.length-1;i++){\n            sb.append(array[i]);\n            sb.append(\" \");\n        }\n        sb.append(array[array.length-1]);\n        return sb.toString();\n    }\n    static String toStringBWS(long[] array){\n        StringBuilder sb=new StringBuilder();\n        for(int i=0;i<array.length-1;i++){\n            sb.append(array[i]);\n            sb.append(\" \");\n        }\n        sb.append(array[array.length-1]);\n        return sb.toString();\n    }\n}\nGicen the following input:\n81 58\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "110\n"
    }
}