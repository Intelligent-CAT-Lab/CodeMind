{
    "0": {
        "prompt": "Instructions: You will be presented a piece of Java code and its input. You need to print the output of the code.\nFor example:\nConsider the following code:\nimport java.util.Scanner;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner scan=new Scanner(System.in);\n        int X =scan.nextInt();\n        switch(X%7){\n            case 4:\n                System.out.println(\"mon\");\n                break;\n            case 5:\n                System.out.println(\"tue\");\n                break;\n            case 6:\n                System.out.println(\"wed\");\n                break;\n            case 0:\n                System.out.println(\"thu\");\n                break;\n            case 1:\n                System.out.println(\"fri\");\n                break;\n            case 2:\n                System.out.println(\"sat\");\n                break;\n            case 3:\n                System.out.println(\"sun\");\n                break;    \n        }\n        \n    }\n\n}\n\nGien the following input:\n4\nPrint only the output of the code, ends with END-OF-OUTPUT:\nmon\nEND-OF-OUTPUT",
        "status": "NAN"
    },
    "1": {
        "prompt": "Consider the following code:\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint H = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tdouble a_x = 1.0 * A * Math.sin(Math.PI * 2 * (H * 60 + M) / 720);\n\t\tdouble b_x = 1.0 * B * Math.sin(Math.PI * 2 * M / 60);\n\t\tdouble a_y = 1.0 * A * Math.cos(Math.PI * 2 * (H * 60 + M) / 720);\n\t\tdouble b_y = 1.0 * B * Math.cos(Math.PI * 2 * M / 60);\n\t\tSystem.out.println(Math.sqrt((a_x - b_x) * (a_x - b_x) + (a_y - b_y) * (a_y - b_y)));\n\t}\n\n\tclass Scanner {\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int index;\n\t\tprivate int length;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate boolean isDigit(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (index < length) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t\tindex = 0;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn length > 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[index])) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[index++] : -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tlong value = 0L;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tvalue = value * 10 + (b - '0');\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn minus ? -value : value;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tinterface CombCalculator {\n\t\tlong comb(int n, int m);\n\t}\n\n\tinterface MobiusFunction {\n\t\tint get(int n);\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3063\u307d\u304f\u524d\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(1)\u3067\u3001\u524d\u8a08\u7b97\u3067O(N logN)\u3067\u3059\u3002\n\t */\n\tclass SieveMobiusFunction implements MobiusFunction {\n\t\tint size;\n\t\tint[] mobiusFunctionValues;\n\n\t\tpublic SieveMobiusFunction(int size) {\n\t\t\tthis.size = size;\n\t\t\tmobiusFunctionValues = new int[size];\n\n\t\t\tmobiusFunctionValues[0] = 0;\n\t\t\tmobiusFunctionValues[1] = 1;\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 2; i * i < size; i++) {\n\t\t\t\tfor (int k = 1; i * i * k < size; k++) {\n\t\t\t\t\tmobiusFunctionValues[i * i * k] *= 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tif (mobiusFunctionValues[i] == 1) {\n\t\t\t\t\tfor (int k = 1; i * k < size; k++) {\n\t\t\t\t\t\tmobiusFunctionValues[i * k] *= -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] > 1) {\n\t\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] < -1) {\n\t\t\t\t\tmobiusFunctionValues[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn mobiusFunctionValues[n];\n\t\t}\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u5b9a\u7fa9\u901a\u308a\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(logN)\u3067\u3059\u3002\n\t */\n\tclass PrimeFactorizationMobiusFunction implements MobiusFunction {\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 2; i < n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t\tnum++;\n\t\t\t\t\tif (n % i == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num % 2 == 0 ? -1 : 1;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u968e\u4e57\u306e\u5024\u3067\u884c\u3046\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306f\u524d\u8a08\u7b97\u3057\u3066\u30c6\u30fc\u30d6\u30eb\u306b\u683c\u7d0d\u3057\u307e\u3059\u3002\n\t * C(N, N) % M \u306e\u8a08\u7b97\u91cf\u306f O(1)\u3001 \u524d\u8a08\u7b97\u3067O(max(N, logM))\u3067\u3059\u3002\n\t * size\u30921e8\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\t * \u307e\u305f\u7d20\u6570\u4ee5\u5916\u306eMOD\u306b\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093(\u9006\u5143\u306e\u8a08\u7b97\u306b\u7d20\u6570\u306e\u5270\u4f59\u74b0\u306e\u6027\u8cea\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081)\u3002\n\t */\n\tclass FactorialTableCombCalculator implements CombCalculator {\n\t\tint size;\n\t\tlong[] factorialTable;\n\t\tlong[] inverseFactorialTable;\n\t\tlong mod;\n\n\t\tpublic FactorialTableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\tfactorialTable = new long[size + 1];\n\t\t\tinverseFactorialTable = new long[size + 1];\n\t\t\tthis.mod = mod;\n\n\t\t\tfactorialTable[0] = 1L;\n\t\t\tfor (int i = 1; i <= size; i++) {\n\t\t\t\tfactorialTable[i] = (factorialTable[i - 1] * i) % mod;\n\t\t\t}\n\t\t\tinverseFactorialTable[size] = inverse(factorialTable[size], mod);\n\t\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\t\tinverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n\t\t\t}\n\t\t}\n\n\t\tprivate long inverse(long n, long mod) {\n\t\t\treturn pow(n, mod - 2, mod);\n\t\t}\n\n\t\tprivate long pow(long n, long p, long mod) {\n\t\t\tif (p == 0) {\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\tlong half = pow(n, p / 2, mod);\n\t\t\tlong ret = (half * half) % mod;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tret = (ret * n) % mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn (((factorialTable[n] * inverseFactorialTable[m]) % mod) * inverseFactorialTable[n - m]) % mod;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u30c6\u30fc\u30d6\u30eb\u3067\u5b9f\u88c5\u3057\u305f\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u524d\u8a08\u7b97\u3067O(N^2), comb\u306fO(1)\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\n\t * size\u30922 * 1e4\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\n\t */\n\tclass TableCombCalculator implements CombCalculator {\n\t\tlong[][] table;\n\t\tint size;\n\n\t\tpublic TableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\ttable = new long[size + 1][];\n\n\t\t\ttable[0] = new long[1];\n\t\t\ttable[0][0] = 1L;\n\t\t\tfor (int n = 1; n <= size; n++) {\n\t\t\t\ttable[n] = new long[n + 1];\n\t\t\t\ttable[n][0] = 1L;\n\t\t\t\tfor (int m = 1; m < n; m++) {\n\t\t\t\t\ttable[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n\t\t\t\t}\n\t\t\t\ttable[n][n] = 1L;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn table[n][m];\n\t\t}\n\t}\n\n\tinterface Graph {\n\t\tvoid link(int from, int to, long cost);\n\t\tOptional<Long> getCost(int from, int to);\n\t\tint getVertexNum();\n\t}\n\n\tinterface FlowResolver {\n\t\tlong maxFlow(int from, int to);\n\t}\n\n\t/**\n\t * \u30b0\u30e9\u30d5\u306e\u884c\u5217\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u63a5\u70b9\u6570\u306e\u5927\u304d\u3044\u30b0\u30e9\u30d5\u3067\u4f7f\u3046\u3068MLE\u3067\u6b7b\u306b\u305d\u3046\n\t */\n\tclass ArrayGraph implements Graph {\n\t\tprivate Long[][] costArray;\n\t\tprivate int vertexNum;\n\n\t\tpublic ArrayGraph(int n) {\n\t\t\tcostArray = new Long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcostArray[i] = new Long[n];\n\t\t\t}\n\t\t\tvertexNum = n;\n\t\t}\n\n\t\t@Override\n\t\tpublic void link(int from, int to, long cost) {\n\t\t\tcostArray[from][to] = new Long(cost);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Long> getCost(int from, int to) {\n\t\t\treturn Optional.ofNullable(costArray[from][to]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getVertexNum() {\n\t\t\treturn vertexNum;\n\t\t}\n\t}\n\n\t/**\n\t * DFS(\u6df1\u3055\u512a\u5148\u63a2\u7d22)\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u8a08\u7b97\u91cf\u306fO(E*MaxFlow)\u306e\u306f\u305a (E:\u8fba\u306e\u6570, MaxFlow:\u6700\u5927\u30d5\u30ed\u30fc)\n\t */\n\tclass DfsFlowResolver implements FlowResolver {\n\t\tprivate Graph graph;\n\t\tpublic DfsFlowResolver(Graph graph) {\n\t\t\tthis.graph = graph;\n\t\t}\n\n\t\t/**\n\t\t * \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\u3092\u6c42\u3081\u308b\n\t\t * @param from \u59cb\u70b9(source)\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @return \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\n\t\t */\n\t\tpublic long maxFlow(int from, int to) {\n\t\t\tlong sum = 0L;\n\t\t\tlong currentFlow;\n\t\t\tdo {\n\t\t\t\tcurrentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n\t\t\t\tsum += currentFlow;\n\t\t\t} while (currentFlow > 0);\n\t\t\treturn sum;\n\t\t}\n\n\t\t/**\n\t\t * \u30d5\u30ed\u30fc\u306e\u5b9f\u884c \u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3082\u884c\u3046\n\t\t * @param from \u73fe\u5728\u3044\u308b\u7bc0\u70b9\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @param current_flow \u3053\u3053\u307e\u3067\u306e\u6d41\u91cf\n\t\t * @param passed \u65e2\u306b\u901a\u3063\u305f\u7bc0\u70b9\u304b\u5426\u304b\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\n\t\t * @return \u7d42\u70b9(target)\u306b\u6d41\u3057\u305f\u6d41\u91cf/\u623b\u308a\u306e\u30b0\u30e9\u30d5\u306e\u6d41\u91cf\n\t\t */\n\t\tprivate long flow(int from, int to, long current_flow, boolean[] passed) {\n\t\t\tpassed[from] = true;\n\t\t\tif (from == to) {\n\t\t\t\treturn current_flow;\n\t\t\t}\n\t\t\tfor (int id = 0; id < graph.getVertexNum(); id++) {\n\t\t\t\tif (passed[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tOptional<Long> cost = graph.getCost(from, id);\n\t\t\t\tif (cost.orElse(0L) > 0) {\n\t\t\t\t\tlong nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n\t\t\t\t\tlong returnFlow = flow(id, to, nextFlow, passed);\n\t\t\t\t\tif (returnFlow > 0) {\n\t\t\t\t\t\tgraph.link(from, id, cost.get() - returnFlow);\n\t\t\t\t\t\tgraph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n\t\t\t\t\t\treturn returnFlow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306eBIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree {\n\t\tprivate long[] array;\n\n\t\tpublic BinaryIndexedTree(int size) {\n\t\t\tthis.array = new long[size + 1];\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index, long value) {\n\t\t\tfor (int i = index; i < array.length; i += (i & -i)) {\n\t\t\t\tarray[i] += value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 1\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @return 1\u301cindex\u307e\u3067\u306e\u548c\n\t\t */\n\t\tpublic long getSum(int index) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i = index; i > 0; i -= (i & -i)) {\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306e2\u6b21\u5143BIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree2D {\n\t\tprivate long[][] array;\n\n\t\tpublic BinaryIndexedTree2D(int size1, int size2) {\n\t\t\tthis.array = new long[size1 + 1][];\n\t\t\tfor (int i = 1; i <= size1; i++) {\n\t\t\t\tthis.array[i] = new long[size2 + 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index1, int index2, long value) {\n\t\t\tfor (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n\t\t\t\t\tarray[i1][i2] += value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * (1,1)\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u77e9\u5f62\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @return (1,1)\u301c(index1,index2)\u307e\u3067\u306e\u77e9\u5f62\u548c\n\t\t */\n\t\tpublic long getSum(int index1, int index2) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n\t\t\t\t\tsum += array[i1][i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\tinterface UnionFind {\n\t\tvoid union(int A, int B);\n\t\tboolean judge(int A, int B);\n\t\tSet<Integer> getSet(int id);\n\t}\n\n\t/**\n\t * ArrayUnionFind\u306e\u62e1\u5f35\n\t * MapSet\u3067\u6839\u306e\u6dfb\u5b57\u304b\u3089\u6839\u306b\u3076\u3089\u4e0b\u304c\u308b\u9802\u70b9\u306e\u96c6\u5408\u304c\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u3092O(logN * logN)\u306b\u843d\u3068\u305b\u3066\u3044\u308b\u306f\u305a\n\t * \u305f\u3060\u3057union\u30e1\u30bd\u30c3\u30c9\u306f2\u500d\u306e\u8a08\u7b97\u91cf\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f(\u30aa\u30fc\u30c0\u30fc\u306f\u5909\u308f\u3089\u306a\u3044\u306f\u305a)\n\t */\n\tclass SetUnionFind extends ArrayUnionFind {\n\t\tMap<Integer, Set<Integer>> map;\n\t\tpublic SetUnionFind(int size) {\n\t\t\tsuper(size);\n\t\t\tmap = new HashMap<>();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmap.put(i, new HashSet<>());\n\t\t\t\tmap.get(i).add(i);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tsuper.unionTo(source, dest);\n\t\t\tmap.get(dest).addAll(map.get(source));\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\treturn map.get(root(id));\n\t\t}\n\t}\n\n\t/**\n\t * \u914d\u5217\u306b\u3088\u308bUnionFind\u306e\u5b9f\u88c5\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u306fO(NlogN)\u306a\u306e\u3067TLE\u306b\u6ce8\u610f\n\t */\n\tclass ArrayUnionFind implements UnionFind {\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint size;\n\t\tpublic ArrayUnionFind(int size) {\n\t\t\tparent = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t\trank = new int[size];\n\t\t\tthis.size = size;\n\t\t}\n\n\t\t@Override\n\t\tpublic void union(int A, int B) {\n\t\t\tint rootA = root(A);\n\t\t\tint rootB = root(B);\n\t\t\tif (rootA != rootB) {\n\t\t\t\tif (rank[rootA] < rank[rootB]) {\n\t\t\t\t\tunionTo(rootA, rootB);\n\t\t\t\t} else {\n\t\t\t\t\tunionTo(rootB, rootA);\n\t\t\t\t\tif (rank[rootA] == rank[rootB]) {\n\t\t\t\t\t\trank[rootA]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tparent[source] = dest;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean judge(int A, int B) {\n\t\t\treturn root(A) == root(B);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tIntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n\t\t\treturn set;\n\t\t}\n\n\t\tprotected int root(int id) {\n\t\t\tif (parent[id] == id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tparent[id] = root(parent[id]);\n\t\t\treturn parent[id];\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u306e\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\n\t */\n\tclass PrimeNumberUtils {\n\t\tboolean[] isPrimeArray;\n\t\tList<Integer> primes;\n\n\t\t/**\n\t\t * \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650\u3068\u306a\u308b\u5024\u3092\u6307\u5b9a\u3057\u3066\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u521d\u671f\u5316\n\t\t * @param limit \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650(\u3053\u306e\u5024\u4ee5\u4e0a\u304c\u7d20\u6570\u3067\u3042\u308b\u304b\u5224\u5b9a\u3057\u306a\u3044)\n\t\t */\n\t\tpublic PrimeNumberUtils(int limit) {\n\t\t\tif (limit > 10000000) {\n\t\t\t\tSystem.err.println(\"\u4e0a\u9650\u306e\u5024\u304c\u9ad8\u3059\u304e\u308b\u305f\u3081\u7d20\u6570\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u521d\u671f\u5316\u3067TLE\u3059\u308b\u53ef\u80fd\u6027\u304c\u5927\u5909\u9ad8\u3044\u3067\u3059\");\n\t\t\t}\n\t\t\tprimes = new ArrayList<>();\n\t\t\tisPrimeArray = new boolean[limit];\n\t\t\tif (limit > 2) {\n\t\t\t\tprimes.add(2);\n\t\t\t\tisPrimeArray[2] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 3; i < limit; i += 2) {\n\t\t\t\tif (isPrime(i, primes)) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tisPrimeArray[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Integer> getPrimeNumberList() {\n\t\t\treturn primes;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn isPrimeArray[n];\n\t\t}\n\n\t\tprivate boolean isPrime(int n, List<Integer> primes) {\n\t\t\tfor (int prime : primes) {\n\t\t\t\tif (n % prime == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (prime > Math.sqrt(n)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinterface BitSet {\n\t\tvoid set(int index, boolean bit);\n\t\tboolean get(int index);\n\t\tvoid shiftRight(int num);\n\t\tvoid shiftLeft(int num);\n\t\tvoid or(BitSet bitset);\n\t\tvoid and(BitSet bitset);\n\t}\n\n\t/**\n\t * Long\u306e\u914d\u5217\u306b\u3088\u308bBitSet\u306e\u5b9f\u88c5\n\t * get/set\u306fO(1)\n\t * shift/or/and\u306fO(size / 64)\n\t */\n\tclass LongBit implements BitSet {\n\t\tlong[] bitArray;\n\n\t\tpublic LongBit(int size) {\n\t\t\tbitArray = new long[((size + 63) / 64)];\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(int index, boolean bit) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\tif (bit) {\n\t\t\t\tbitArray[segment] |= 1L << inIndex;\n\t\t\t} else {\n\t\t\t\tbitArray[segment] &= ~(1L << inIndex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int index) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\treturn (bitArray[segment] & (1L << inIndex)) != 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftRight(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tint sourceSeg = segment + shiftSeg;\n\t\t\t\tif (sourceSeg < bitArray.length) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftLeft(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = bitArray.length - 1; segment >= 0; segment--) {\n\t\t\t\tint sourceSeg = segment - shiftSeg;\n\t\t\t\tif (sourceSeg >= 0) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] << shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg > 0) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long getLong(int segment) {\n\t\t\treturn bitArray[segment];\n\t\t}\n\n\t\t@Override\n\t\tpublic void or(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] |= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void and(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] &= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\t}\n\n}Gicen the following input:\n3 4 9 0\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "5.00000000000000000000\n"
    }
}