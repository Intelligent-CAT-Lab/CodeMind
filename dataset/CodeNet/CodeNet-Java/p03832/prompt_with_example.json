{
    "0": {
        "prompt": "Instructions: You will be presented a piece of Java code and its input. You need to print the output of the code.\nFor example:\nConsider the following code:\nimport java.util.Scanner;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner scan=new Scanner(System.in);\n        int X =scan.nextInt();\n        switch(X%7){\n            case 4:\n                System.out.println(\"mon\");\n                break;\n            case 5:\n                System.out.println(\"tue\");\n                break;\n            case 6:\n                System.out.println(\"wed\");\n                break;\n            case 0:\n                System.out.println(\"thu\");\n                break;\n            case 1:\n                System.out.println(\"fri\");\n                break;\n            case 2:\n                System.out.println(\"sat\");\n                break;\n            case 3:\n                System.out.println(\"sun\");\n                break;    \n        }\n        \n    }\n\n}\n\nGien the following input:\n4\nPrint only the output of the code, ends with END-OF-OUTPUT:\nmon\nEND-OF-OUTPUT",
        "status": "NAN"
    },
    "1": {
        "prompt": "Consider the following code:\n\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.Math.min;\n\nimport java.math.BigDecimal;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\nimport java.util.stream.*;\n\n/**\n * @author baito\n */\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n    static boolean DEBUG = true;\n    static StringBuilder sb = new StringBuilder();\n    static int INF = 1234567890;\n    static int MINF = -1234567890;\n    static long LINF = 123456789123456789L;\n    static long MLINF = -123456789123456789L;\n    static int MOD = (int) 1e9 + 7;\n    static double EPS = 1e-10;\n    static int[] y4 = {-1, 1, 0, 0};\n    static int[] x4 = {0, 0, -1, 1};\n    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};\n    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};\n    static int[] Fa;\n    static boolean[] isPrime;\n    static ArrayList<Integer> primes;\n    static char[][] S;\n    static long maxRes = Long.MIN_VALUE;\n    static long minRes = Long.MAX_VALUE;\n    static int[] fac, finv, inv;\n\n    //    static int N;\n//    static int[] A;\n    static int N, A, B, C, D;\n    static int[][] dp;\n\n    public static void solve() throws Exception {\n//        long\u3092\u5fd8\u308c\u308b\u306a\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u3059\u308b\u305e\n//        N = ni();\n//        A = nia(N);\n//        $END$\n        int N = ni();\n        int A = ni();\n        int B = ni();\n        int C = ni();\n        int D = ni();\n        setMod();\n        long[][] dp = new long[N + 1][N + 1];\n        for (int i = 0; i < N + 1; i++) {\n            dp[i][0] = 1;\n        }\n        long[][] mPowFinv = new long[N + 1][N + 1];\n        for (int k = 0; k < N + 1; k++) {\n            mPowFinv[k][1] = finv[k];\n        }\n        for (int k = 0; k < N + 1; k++) {\n            for (int i = 2; i < D + 1; i++) {\n                mPowFinv[k][i] = mPowFinv[k][i - 1] * finv[k] % MOD;\n            }\n        }\n        for (int k = 1; k <= N; k++) {\n            for (int n = 1; n <= N; n++) {\n                //k\u4eba\u304c0\u306e\u3068\u304d\n                dp[k][n] = dp[k - 1][n];\n                if (!(A <= k && k <= B)) continue;\n                for (int x = C; x <= D && n - k * x >= 0; x++) {\n                    //n\u4eba\u304b\u3089k\u4eba\u3092x\u30b0\u30eb\u30fc\u30d7\u4f5c\u308a\u305d\u306e\u4ed6\u306fk-1\u4eba\u4ee5\u4e0b\n                    long cal = mMuls(fac[n], finv[n - k * x], mPowFinv[k][x], finv[x]);\n                    cal = mMul(cal, dp[k - 1][n - k * x]);\n                    dp[k][n] = mSum(dp[k][n], cal);\n                }\n            }\n        }\n        System.out.println(dp[N][N]);\n    }\n\n\n    public static boolean calc(long va) {\n        //\u8caa\u6b32\u306b\u30ae\u30ea\u30ae\u30ea\u30bb\u30fc\u30d5\u3092\u9078\u3093\u3067\u3044\u304f\u3002\n        int v = (int) va;\n        return true;\n    }\n\n    //\u6761\u4ef6\u3092\u6e80\u305f\u3059\u6700\u5927\u5024\u3001\u3042\u308b\u3044\u306f\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n    static int mgr(long ok, long ng) {\n        //int ok = 0; //\u89e3\u304c\u5b58\u5728\u3059\u308b\n        //int ng = N; //\u89e3\u304c\u5b58\u5728\u3057\u306a\u3044\n        while (Math.abs(ok - ng) > 1) {\n            long mid;\n            if (ok < 0 && ng > 0 || ok > 0 && ng < 0) mid = (ok + ng) / 2;\n            else mid = ok + (ng - ok) / 2;\n\n            if (calc(mid)) {\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n        if (calc(ok)) return (int) ok;\n        else return -1;\n    }\n\n    static <T> void initStreamArray(ArrayList<T>[] a, int n) {\n        a = Stream.generate(ArrayList::new).limit(n).toArray(ArrayList[]::new);\n    }\n\n    //\u6d88\u3059\u5019\u88dc\n    static ArrayList<Integer> divisors(int n) {\n        ArrayList<Integer> res = new ArrayList<>();\n        for (int i = 1; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                res.add(i);\n                if (i != n / i) res.add(n / i);\n            }\n        }\n        return res;\n    }\n\n    static ArrayList<Long> divisors(long n) {\n        ArrayList<Long> res = new ArrayList<>();\n        for (long i = 1; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                res.add(i);\n                if (i != n / i) res.add(n / i);\n            }\n        }\n        return res;\n    }\n\n    static ArrayList<Integer> factorization(int n) {\n        if (primes == null) setPrimes();\n        ArrayList<Integer> fact = new ArrayList<>();\n        for (int p : primes) {\n            if (n % p == 0) fact.add(p);\n            while (n % p == 0) n /= p;\n            if (n == 1) break;\n        }\n        if (n != 1) fact.add(n);\n        return fact;\n    }\n\n    boolean equal(double a, double b) {\n        return a == 0 ? abs(b) < EPS : abs((a - b) / a) < EPS;\n    }\n\n    public static void chMax(long v) {\n        maxRes = Math.max(maxRes, v);\n    }\n\n    public static void chMin(long v) {\n        minRes = Math.min(minRes, v);\n    }\n\n    //\u4fbf\u5229\u7cfb\n    //\u5de6\u7aef\u3001\u53f3\u7aef\u306e\u60c5\u5831\u3092\u3082\u305f\u305b\u308b\u3002\u534a\u958b\u533a\u9593\n    public static void setLR(int[] a, ArrayList<Integer> l, ArrayList<Integer> r) {\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] > 0) {\n                int j = i;\n                while (a[j] > 0) j++;\n                l.add(i);\n                r.add(j);\n                i = j - 1;\n            }\n        }\n    }\n\n    public static long[] rui(int[] a) {\n        long[] res = new long[a.length + 1];\n        for (int i = 0; i < a.length; i++) {\n            res[i + 1] = a[i];\n        }\n        for (int i = 0; i < a.length; i++) {\n            res[i + 1] += res[i];\n        }\n        return res;\n    }\n\n    //p[i].nowx := i\u756a\u76ee\u306b\u5c0f\u3055\u3044\uff56\u306e\u5024 p[i].nowy := \u305d\u306e\u500b\u6570\n    //0\u500b\u306e\u7269\u306f\u9664\u304f\n    public static P[] mato(int[] a) {\n        CouMap map = new CouMap(a);\n        P[] res = new P[map.size()];\n        int i = 0;\n        for (Map.Entry<Long, Long> m : map.map.entrySet()) {\n            res[i++] = new P((int) (long) m.getKey(), (int) (long) m.getValue());\n        }\n        sort(res);\n        return res;\n    }\n\n    public static int[] imosu(int[] f, int[] t, int n) {\n        int[] imosu = new int[n + 1];\n        for (int i = 0; i < f.length; i++) {\n            imosu[f[i]]++;\n            imosu[t[i] + 1]--;\n        }\n        for (int i = 0; i < n; i++) {\n            imosu[i + 1] += imosu[i];\n        }\n        return imosu;\n    }\n\n    static int[] inverse(int[] a) {\n        int[] res = new int[a.length];\n        for (int i = 0; i < a.length; i++)\n            res[a[i]] = i;\n        return res;\n    }\n\n    public static String notE(double v) {\n        return BigDecimal.valueOf(v).toPlainString();\n    }\n\n    public static void print(char[][] a) {\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[0].length; j++) {\n                System.out.print(a[i][j]);\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    public static void print(int[][] a) {\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[0].length; j++) {\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    public static <T> void print(ArrayList<T> a) {\n        for (T t : a) {\n            System.out.println(t);\n        }\n    }\n\n    public static void print(int[] a) {\n        for (int i = 0; i < a.length; i++)\n            System.out.println(a[i]);\n    }\n\n    public static void print(long[] a) {\n        for (int i = 0; i < a.length; i++)\n            System.out.println(a[i]);\n    }\n\n    //bit\u95a2\u9023\n    public static boolean bget(BitSet bit, int keta) {\n        return bit.nextSetBit(keta) == keta;\n    }\n\n    public static boolean bget(long bit, int keta) {\n        return ((bit >> keta) & 1) == 1;\n    }\n\n    public static int bget3(long bit, int keta) {\n        bit /= (long) pow(3, keta);\n        return (int) (bit % 3);\n    }\n\n    public static int getHashA(long key) {\n        return (int) (key >> 32);\n    }\n\n    public static int getHashB(long key) {\n        return (int) (key & -1);\n    }\n\n    //\u6b63\u306e\u6570\u306e\u307f\n    public static long getHashKey(int a, int b) {\n        return (long) a << 32 | b;\n    }\n    //\u6570\u5b66\u95a2\u4fc2--------------------------------\n\n    //a/b\u3092\u8fd4\u3059\n    public static long ceil(long a, long b) {\n        return (a % b == 0) ? a / b : a / b + 1;\n    }\n\n    public static double sqrt(double v) {\n        return Math.sqrt(v);\n    }\n\n    public static long sqrt(long v) {\n        long res = (long) Math.sqrt(v);\n        while (res * res > v) res--;\n        return res;\n    }\n\n    static double[][] PER_DP;\n\n    static double ncrPer(int n, int r) {\n        if (n < r) return 0;\n        if (PER_DP == null) {\n            PER_DP = new double[5001][5001];\n            PER_DP[0][0] = 1;\n            for (int ni = 0; ni < PER_DP.length - 1; ni++) {\n                for (int ri = 0; ri < ni + 1; ri++) {\n                    PER_DP[ni + 1][ri] += PER_DP[ni][ri] / 2;\n                    PER_DP[ni + 1][ri + 1] += PER_DP[ni][ri] / 2;\n                }\n            }\n        }\n        return PER_DP[n][r];\n    }\n\n    //mod\u95a2\u9023\n    public static int mod(long a, int m) {\n        return (int) ((a % m + m) % m);\n    }\n\n    static void setMod() {\n        fac = new int[(int) 1e6 + 1000];\n        finv = new int[(int) 1e6 + 1000];\n        inv = new int[(int) 1e6 + 1000];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n        for (int i = 2; i < 1e6 + 1000; i++) {\n            fac[i] = mMul(fac[i - 1], i);\n            inv[i] = MOD - mMul(inv[MOD % i], (MOD / i));\n            finv[i] = mMul(finv[i - 1], inv[i]);\n        }\n    }\n\n    static int mNcr(int n, int r) {\n        if (n < 0 || r < 0 || n < r) return 0;\n        int result = mMul(Fa[n], finv[n - r]);\n        result = mMul(result, finv[r]);\n        return result;\n    }\n\n    public static int mSum(long a, long b) {\n        return (int) (((a % MOD + b % MOD) % MOD + MOD) % MOD);\n    }\n\n    public static int mDiff(long a, long b) {\n        return mSum(a, -b);\n    }\n\n    public static int mMul(long a, long b) {\n        return (int) (((a % MOD * b % MOD) % MOD + MOD) % MOD);\n    }\n\n    public static int mDiv(long a, long b) {\n        return mMul(a, mInv(b));\n    }\n\n    public static long mSums(long... lar) {\n        long res = 0;\n        for (long l : lar)\n            res = (res + l % MOD) % MOD;\n        return (res + MOD) % MOD;\n    }\n\n    public static long mDiffs(long... lar) {\n        long res = lar[0] % MOD;\n        for (int i = 1; i < lar.length; i++) {\n            res = (res - lar[i] % MOD) % MOD;\n        }\n        return (res + MOD) % MOD;\n    }\n\n    public static long mMuls(long... lar) {\n        long res = 1;\n        for (long l : lar)\n            res = (res * (l % MOD)) % MOD;\n        return (res + MOD) % MOD;\n    }\n\n    public static long mDivs(long... lar) {\n        long res = lar[0] % MOD;\n        for (int i = 1; i < lar.length; i++) {\n            res = mMul(res, mInv(lar[i]));\n        }\n        return (res + MOD) % MOD;\n    }\n\n    static long mInv(long n) {\n        return mPow(n, MOD - 2);\n    }\n\n    static int mPow(long x, long n) {\n        long res = 1L;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return (int) ((res + MOD) % MOD);\n    }\n\n    static void factorial() {\n        Fa = new int[(int) 1e6 + 1];\n        Fa[0] = Fa[1] = 1;\n        for (int i = 2; i < Fa.length; i++) {\n            Fa[i] = (int) ((Fa[i - 1] * 1L * i) % MOD);\n        }\n    }\n\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n    static long lcm(long n, long r) {\n        return n / gcd(n, r) * r;\n    }\n\n    static int gcd(int n, int r) {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static long gcd(long n, long r) {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    public static int u0(int a) {\n        if (a < 0) return 0;\n        return a;\n    }\n\n    public static long u0(long a) {\n        if (a < 0) return 0;\n        return a;\n    }\n\n    public static double u0(double a) {\n        if (a < 0) return 0;\n        return a;\n    }\n\n    public static boolean[][] tbt(char[][] s, char c) {\n        boolean[][] res = new boolean[s.length][s[0].length];\n        for (int hi = 0; hi < s.length; hi++)\n            for (int wi = 0; wi < s[0].length; wi++)\n                if (s[hi][wi] == c) res[hi][wi] = true;\n        return res;\n    }\n\n    public static int[] tia(int a) {\n        int[] res = new int[keta(a)];\n        for (int i = res.length - 1; i >= 0; i--) {\n            res[i] = a % 10;\n            a /= 10;\n        }\n        return res;\n    }\n\n    public static int[][] tit(char[][] a) {\n        int[][] res = new int[a.length][a[0].length];\n        for (int hi = 0; hi < a.length; hi++) {\n            for (int wi = 0; wi < a[0].length; wi++) {\n                res[hi][wi] = a[hi][wi] - '0';\n            }\n        }\n        return res;\n    }\n\n    public static Integer[] toIntegerArray(int[] ar) {\n        Integer[] res = new Integer[ar.length];\n        for (int i = 0; i < ar.length; i++) {\n            res[i] = ar[i];\n        }\n        return res;\n    }\n\n    //k\u500b\u306e\u6b21\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u30d3\u30c3\u30c8\u3067\u8fd4\u3059 \u5927\u304d\u3055\u306b\u4e0a\u9650\u306f\u306a\u3044 110110 -> 111001\n    public static long bitNextComb(long comb) {\n        long x = comb & -comb; //\u6700\u4e0b\u4f4d\u306e1\n        long y = comb + x; //\u9023\u7d9a\u3057\u305f\u4e0b\u306e1\u3092\u7e70\u308a\u4e0a\u304c\u3089\u305b\u308b\n        return ((comb & ~y) / x >> 1) | y;\n    }\n\n    public static int keta(long num) {\n        int res = 0;\n        while (num > 0) {\n            num /= 10;\n            res++;\n        }\n        return res;\n    }\n\n    public static int ketaSum(long num) {\n        int res = 0;\n        while (num > 0) {\n            res += num % 10;\n            num /= 10;\n        }\n        return res;\n    }\n\n    public static boolean isOutofIndex(int x, int y, int w, int h) {\n        if (x < 0 || y < 0) return true;\n        if (w <= x || h <= y) return true;\n        return false;\n    }\n\n    public static boolean isOutofIndex(int x, int y, char[][] ban) {\n        if (x < 0 || y < 0) return true;\n        if (ban[0].length <= x || ban.length <= y) return true;\n        return false;\n    }\n\n\n    public static void setPrimes() {\n        int n = 100001;\n        isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        for (int i = 2; i * i <= n; i++) {\n            if (!isPrime[i]) continue;\n            for (int j = i * 2; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n        primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) primes.add(i);\n        }\n    }\n\n    public static void revSort(int[] a) {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static void revSort(long[] a) {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static P[] clone(P[] ar) {\n        P[] res = new P[ar.length];\n        for (int i = 0; i < ar.length; i++) {\n            res[i] = new P(ar[i].x, ar[i].y);\n        }\n        return res;\n    }\n\n    public static int[][] clone(int[][] ar) {\n        int[][] nr = new int[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = ar[i].clone();\n        return nr;\n    }\n\n    public static long[][] clone(long[][] ar) {\n        long[][] nr = new long[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = ar[i].clone();\n        return nr;\n    }\n\n    public static double[][] clone(double[][] ar) {\n        double[][] nr = new double[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = ar[i].clone();\n        return nr;\n    }\n\n    public static boolean[][] clone(boolean[][] ar) {\n        boolean[][] nr = new boolean[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = ar[i].clone();\n        return nr;\n    }\n\n    public static char[][] clone(char[][] ar) {\n        char[][] nr = new char[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = ar[i].clone();\n        return nr;\n    }\n\n    public static int[][][] clone(int[][][] ar) {\n        int[][][] nr = new int[ar.length][ar[0].length][ar[0][0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = clone(ar[i]);\n        return nr;\n    }\n\n    public static long[][][] clone(long[][][] ar) {\n        long[][][] nr = new long[ar.length][ar[0].length][ar[0][0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = clone(ar[i]);\n        return nr;\n    }\n\n    public static double[][][] clone(double[][][] ar) {\n        double[][][] nr = new double[ar.length][ar[0].length][ar[0][0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = clone(ar[i]);\n        return nr;\n    }\n\n    public static boolean[][][] clone(boolean[][][] ar) {\n        boolean[][][] nr = new boolean[ar.length][ar[0].length][ar[0][0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = clone(ar[i]);\n        return nr;\n    }\n\n    public static char[][][] clone(char[][][] ar) {\n        char[][][] nr = new char[ar.length][ar[0].length][ar[0][0].length];\n        for (int i = 0; i < ar.length; i++)\n            nr[i] = clone(ar[i]);\n        return nr;\n    }\n\n    /**\n     * <h1>\u6307\u5b9a\u3057\u305f\u5024\u4ee5\u4e0a\u306e\u5148\u982d\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u3092\u8fd4\u3059</h1>\n     * <p>\u914d\u5217\u8981\u7d20\u304c\uff10\u306e\u3068\u304d\u306f\u3001\uff10\u304c\u8fd4\u308b\u3002</p>\n     *\n     * @return<b>int</b> \uff1a \u63a2\u7d22\u3057\u305f\u5024\u4ee5\u4e0a\u3067\u3001\u5148\u982d\u306b\u306a\u308b\u30a4\u30f3\u30c7\u30af\u30b9\n     * \u5024\u304c\u7121\u3051\u308c\u3070\u3001\u633f\u5165\u3067\u304d\u308b\u6700\u5c0f\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n     */\n    public static <T extends Number> int lowerBound(final List<T> lis, final T value) {\n        int low = 0;\n        int high = lis.size();\n        int mid;\n\n        while (low < high) {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (lis.get(mid).doubleValue() < value.doubleValue()) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    //v\u672a\u6e80\u3067\u6700\u5927\u306ei\u3092\u8fd4\u3059\u3002\u305f\u3060\u3057v\u4ee5\u4e0a\u3092\u6e80\u305f\u3059i\u304c\u3042\u308b\u306a\u3089\u6700\u5c0f\u306ei\u3092\u8fd4\u3059\n    public static <T extends Number> int rlowerBound(final List<T> lis, final T value) {\n        int ind = lowerBound(lis, value);\n        if (ind == lis.size() || !lis.get(ind).equals(value)) ind--;\n        return ind;\n    }\n\n    /**\n     * <h1>\u6307\u5b9a\u3057\u305f\u5024\u3088\u308a\u5927\u304d\u3044\u5148\u982d\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u3092\u8fd4\u3059</h1>\n     * <p>\u914d\u5217\u8981\u7d20\u304c\uff10\u306e\u3068\u304d\u306f\u3001\uff10\u304c\u8fd4\u308b\u3002</p>\n     *\n     * @return<b>int</b> \uff1a \u63a2\u7d22\u3057\u305f\u5024\u3088\u308a\u4e0a\u3067\u3001\u5148\u982d\u306b\u306a\u308b\u30a4\u30f3\u30c7\u30af\u30b9\n     * \u5024\u304c\u7121\u3051\u308c\u3070\u3001\u633f\u5165\u3067\u304d\u308b\u6700\u5c0f\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n     */\n    public static <T extends Number> int upperBound(final List<T> lis, final T value) {\n        int low = 0;\n        int high = lis.size();\n        int mid;\n        while (low < high) {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (lis.get(mid).doubleValue() < value.doubleValue()) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int lowerBound(final int[] arr, final int value) {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n\n        while (low < high) {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] < value) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int rlowerBound(final int[] arr, final int value) {\n        int ind = lowerBound(arr, value);\n        if (ind == arr.length || arr[ind] != value) ind--;\n        return ind;\n    }\n\n\n    public static int upperBound(final int[] arr, final int value) {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high) {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] <= value) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int lowerBound(final long[] arr, final long value) {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high) {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] < value) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static int rlowerBound(final long[] arr, final long value) {\n        int ind = lowerBound(arr, value);\n        if (ind == arr.length || arr[ind] != value) ind--;\n        return ind;\n    }\n\n    public static int upperBound(final long[] arr, final long value) {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high) {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] <= value) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    //\u6b21\u306e\u9806\u5217\u306b\u66f8\u304d\u63db\u3048\u308b\u3001\u6700\u5927\u5024\u306a\u3089false\u3092\u8fd4\u3059\n    public static boolean nextPermutation(int A[]) {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--) {\n            if (A[pos] < A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n        //pos\u3088\u308a\u5927\u304d\u3044\u6700\u5c0f\u306e\u6570\u3092\u4e8c\u5206\u63a2\u7d22\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1) {\n            int mid = (ok + ng) / 2;\n            if (A[mid] > A[pos]) ok = mid;\n            else ng = mid;\n        }\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n        return true;\n    }\n\n    //\u6b21\u306e\u9806\u5217\u306b\u66f8\u304d\u63db\u3048\u308b\u3001\u6700\u5c0f\u5024\u306a\u3089false\u3092\u8fd4\u3059\n    public static boolean prevPermutation(int A[]) {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--) {\n            if (A[pos] > A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n        //pos\u3088\u308a\u5c0f\u3055\u3044\u6700\u5927\u306e\u6570\u3092\u4e8c\u5206\u63a2\u7d22\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1) {\n            int mid = (ok + ng) / 2;\n            if (A[mid] < A[pos]) ok = mid;\n            else ng = mid;\n        }\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n        return true;\n    }\n\n    static <T> void swap(T[] x, int i, int j) {\n        T t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    static void swap(char[] x, int i, int j) {\n        char t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    static void swap(int[] x, int i, int j) {\n        int t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    public static String reverse(String a) {\n        sb.append(a);\n        String res = sb.reverse().toString();\n        sb.setLength(0);\n        return new String(res);\n    }\n\n    public static void reverse(int[] x) {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r) {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(long[] x) {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r) {\n            long temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(char[] x) {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r) {\n            char temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(int[] x, int s, int e) {\n        int l = s;\n        int r = e;\n        while (l < r) {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    static int cou(boolean[] a) {\n        int res = 0;\n        for (boolean b : a) {\n            if (b) res++;\n        }\n        return res;\n    }\n\n    static int cou(boolean[][] a) {\n        int res = 0;\n        for (boolean[] b : a) {\n            res += cou(b);\n        }\n        return res;\n    }\n\n    static int cou(String s, char c) {\n        int res = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) res++;\n        }\n        return res;\n    }\n\n    static int cou(char[][] a, char c) {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == c) co++;\n        return co;\n    }\n\n    static int cou(int[] a, int key) {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            if (a[i] == key) co++;\n        return co;\n    }\n\n    static int cou(long[] a, long key) {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            if (a[i] == key) co++;\n        return co;\n    }\n\n    static int cou(int[][] a, int key) {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            co += (cou(a[i], key));\n        return co;\n    }\n\n    static int[] couArray(int[] a) {\n        int[] res = new int[maxs(a) + 1];\n        for (int i : a) {\n            res[i]++;\n        }\n        return res;\n    }\n\n    static void fill(int[] a, int v) {\n        Arrays.fill(a, v);\n    }\n\n    static void fill(long[] a, int v) {\n        Arrays.fill(a, v);\n    }\n\n    static void fill(boolean[] a, boolean v) {\n        Arrays.fill(a, v);\n    }\n\n    static void fill(int[][] a, int v) {\n        for (int i = 0; i < a.length; i++)\n            Arrays.fill(a[i], v);\n    }\n\n    static void fill(char[][] a, char c) {\n        for (int i = 0; i < a.length; i++)\n            Arrays.fill(a[i], c);\n    }\n\n    static void fill(long[][] a, long v) {\n        for (int i = 0; i < a.length; i++)\n            Arrays.fill(a[i], v);\n    }\n\n    static void fill(double[][] a, double v) {\n        for (int i = 0; i < a.length; i++)\n            Arrays.fill(a[i], v);\n    }\n\n    static void fill(boolean[][] a, boolean v) {\n        for (int i = 0; i < a.length; i++)\n            Arrays.fill(a[i], v);\n    }\n\n    static void fill(int[][][] a, int v) {\n        for (int i = 0; i < a.length; i++)\n            fill(a[i], v);\n    }\n\n    static void fill(long[][][] a, long v) {\n        for (int i = 0; i < a.length; i++)\n            fill(a[i], v);\n    }\n\n    static int maxs(int... a) {\n        int res = Integer.MIN_VALUE;\n        for (int i : a) {\n            res = Math.max(res, i);\n        }\n        return res;\n    }\n\n    static long maxs(long... a) {\n        long res = Long.MIN_VALUE;\n        for (long i : a) {\n            res = Math.max(res, i);\n        }\n        return res;\n    }\n\n    static double maxs(double... a) {\n        double res = Double.MIN_VALUE;\n        for (double i : a) {\n            res = Math.max(res, i);\n        }\n        return res;\n    }\n\n    static long mins(long... a) {\n        long res = Long.MAX_VALUE;\n        for (long i : a) {\n            res = Math.min(res, i);\n        }\n        return res;\n    }\n\n    static int maxs(int[][] ar) {\n        int res = Integer.MIN_VALUE;\n        for (int i[] : ar)\n            res = Math.max(res, maxs(i));\n        return res;\n    }\n\n    static long maxs(long[][] ar) {\n        long res = Integer.MIN_VALUE;\n        for (long i[] : ar)\n            res = Math.max(res, maxs(i));\n        return res;\n    }\n\n    static int mins(int... a) {\n        int res = Integer.MAX_VALUE;\n        for (int i : a) {\n            res = Math.min(res, i);\n        }\n        return res;\n    }\n\n\n    static int mins(int[][] ar) {\n        int res = Integer.MAX_VALUE;\n        for (int i[] : ar)\n            res = Math.min(res, mins(i));\n        return res;\n    }\n\n    public static <T extends Number> long sum(ArrayList<T> lis) {\n        long res = 0;\n        for (T li : lis) {\n            res += li.longValue();\n        }\n        return res;\n    }\n\n    static long sum(int[] a) {\n        long cou = 0;\n        for (int i : a)\n            cou += i;\n        return cou;\n    }\n\n    static long sum(long[] a) {\n        long cou = 0;\n        for (long i : a)\n            cou += i;\n        return cou;\n    }\n\n\n//FastScanner\n\n    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer tokenizer = null;\n\n    public static String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public static String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public static long nl() {\n        return Long.parseLong(next());\n    }\n\n    public static String n() {\n        return next();\n    }\n\n    public static int ni() {\n        return Integer.parseInt(next());\n    }\n\n    public static double nd() {\n        return Double.parseDouble(next());\n    }\n\n    public static int[] nia(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ni();\n        }\n        return a;\n    }\n\n    //1-index\n    public static int[] niao(int n) {\n        int[] a = new int[n + 1];\n        for (int i = 1; i < n + 1; i++) {\n            a[i] = ni();\n        }\n        return a;\n    }\n\n    //\u756a\u5175\u6cd5\n    public static int[] nias(int n, int end) {\n        int[] a = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            a[i] = ni();\n        }\n        a[n] = end;\n        return a;\n    }\n\n    public static int[] niad(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ni() - 1;\n        }\n        return a;\n    }\n\n    public static P[] npa(int n) {\n        P[] p = new P[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = new P(ni(), ni());\n        }\n        return p;\n    }\n\n    public static P[] npad(int n) {\n        P[] p = new P[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = new P(ni() - 1, ni() - 1);\n        }\n        return p;\n    }\n\n    public static int[][] nit(int h, int w) {\n        int[][] a = new int[h][w];\n        for (int hi = 0; hi < h; hi++) {\n            for (int wi = 0; wi < w; wi++) {\n                a[hi][wi] = ni();\n            }\n        }\n        return a;\n    }\n\n    public static int[][] nitd(int h, int w) {\n        int[][] a = new int[h][w];\n        for (int hi = 0; hi < h; hi++) {\n            for (int wi = 0; wi < w; wi++) {\n                a[hi][wi] = ni() - 1;\n            }\n        }\n        return a;\n    }\n\n    static int[][] S_ARRAY;\n    static long[][] S_LARRAY;\n    static int S_INDEX;\n    static int S_LINDEX;\n\n    //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n    public static int[] niah(int n, int k) throws Exception {\n        if (S_ARRAY == null) {\n            S_ARRAY = new int[k][n];\n            for (int j = 0; j < n; j++) {\n                for (int i = 0; i < k; i++) {\n                    S_ARRAY[i][j] = ni();\n                }\n            }\n        }\n        return S_ARRAY[S_INDEX++];\n    }\n\n    public static long[] nlah(int n, int k) throws Exception {\n        if (S_LARRAY == null) {\n            S_LARRAY = new long[k][n];\n            for (int j = 0; j < n; j++) {\n                for (int i = 0; i < k; i++) {\n                    S_LARRAY[i][j] = nl();\n                }\n            }\n        }\n        return S_LARRAY[S_LINDEX++];\n    }\n\n    //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n    public static int[] niahd(int n, int k) throws Exception {\n        if (S_ARRAY == null) {\n            S_ARRAY = new int[k][n];\n            for (int j = 0; j < n; j++) {\n                for (int i = 0; i < k; i++) {\n                    S_ARRAY[i][j] = ni() - 1;\n                }\n            }\n        }\n        return S_ARRAY[S_INDEX++];\n    }\n\n    public static long[] nlahd(int n, int k) throws Exception {\n        if (S_LARRAY == null) {\n            S_LARRAY = new long[k][n];\n            for (int j = 0; j < n; j++) {\n                for (int i = 0; i < k; i++) {\n                    S_LARRAY[i][j] = nl() - 1;\n                }\n            }\n        }\n        return S_LARRAY[S_LINDEX++];\n    }\n\n    public static char[] nca() {\n        char[] a = next().toCharArray();\n        return a;\n    }\n\n\n    public static String[] nsa(int n) {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = n();\n        }\n        return res;\n    }\n\n    //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n    public static char[][] ncts(int h, int w) {\n        char[][] a = new char[h][w];\n        for (int hi = 0; hi < h; hi++) {\n            String s = nextLine().replace(\" \", \"\");\n            for (int wi = 0; wi < s.length(); wi++) {\n                a[hi][wi] = s.charAt(wi);\n            }\n        }\n        return a;\n    }\n\n    public static char[][] nct(int h, int w) {\n        char[][] a = new char[h][w];\n        for (int hi = 0; hi < h; hi++) {\n            String s = nextLine();\n            for (int wi = 0; wi < s.length(); wi++) {\n                a[hi][wi] = s.charAt(wi);\n            }\n        }\n        return a;\n    }\n\n    public static char[][] nctp(int h, int w, char c) {\n        char[][] a = new char[h + 2][w + 2];\n        for (int hi = 1; hi < h + 1; hi++) {\n            String s = nextLine();\n            for (int wi = 1; wi < s.length() + 1; wi++) {\n                a[hi][wi] = s.charAt(wi - 1);\n            }\n        }\n        for (int wi = 0; wi < w + 2; wi++)\n            a[0][wi] = a[h + 1][wi] = c;\n        for (int hi = 0; hi < h + 2; hi++)\n            a[hi][0] = a[hi][w + 1] = c;\n        return a;\n    }\n\n    //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n    public static char[][] nctsp(int h, int w, char c) {\n        char[][] a = new char[h + 2][w + 2];\n        //char c = '*';\n        int i;\n        for (i = 0; i < w + 2; i++)\n            a[0][i] = c;\n        for (i = 1; i < h + 1; i++) {\n            a[i] = (c + nextLine().replace(\" \", \"\") + c).toCharArray();\n        }\n        for (i = 0; i < w + 2; i++)\n            a[h + 1][i] = c;\n        return a;\n    }\n\n    public static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nl();\n        }\n        return a;\n    }\n\n    public static long[] nlas(int n, long e) {\n        long[] a = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            a[i] = nl();\n        }\n        a[n] = e;\n        return a;\n    }\n\n    public static long[] nlao(int n) {\n        long[] a = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            a[i + 1] = nl();\n        }\n        return a;\n    }\n\n    public static long[] nlad(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nl() - 1;\n        }\n        return a;\n    }\n\n    public static long[][] nlt(int h, int w) {\n        long[][] a = new long[h][w];\n        for (int hi = 0; hi < h; hi++) {\n            for (int wi = 0; wi < w; wi++) {\n                a[hi][wi] = nl();\n            }\n        }\n        return a;\n    }\n\n    //\u4fbf\u5229\u30af\u30e9\u30b9\n    static class CouMap {\n        public HashMap<Long, Long> map;\n        public HashMap<String, Long> smap;\n\n        CouMap() {\n            map = new HashMap();\n            smap = new HashMap();\n        }\n\n        CouMap(int[] a) {\n            map = new HashMap();\n            smap = new HashMap();\n            for (int i : a) {\n                put(i);\n            }\n        }\n\n        public int size() {\n            return map.size();\n        }\n\n        public void put(long key, long value) {\n            Long nowValue = map.get(key);\n            map.put(key, nowValue == null ? value : nowValue + value);\n        }\n\n        public void put(String key, long value) {\n            Long nowValue = smap.get(key);\n            smap.put(key, nowValue == null ? value : nowValue + value);\n        }\n\n        public void mput(long key, long value) {\n            Long nowValue = map.get(key);\n            map.put(key, nowValue == null ? value % MOD : mSum(nowValue, value));\n        }\n\n        public void put(long key) {\n            put(key, 1);\n        }\n\n        public void put(String key) {\n            put(key, 1);\n        }\n\n        public void put(int... arg) {\n            for (int i : arg) {\n                put(i, 1);\n            }\n        }\n\n        public void put(long... arg) {\n            for (long i : arg) {\n                put(i, 1);\n            }\n        }\n\n        public void mput(int... arg) {\n            for (int i : arg) {\n                mput(i, 1);\n            }\n        }\n\n        public void mput(long... arg) {\n            for (long i : arg) {\n                mput(i, 1);\n            }\n        }\n\n        public long get(long key) {\n            Long v = map.get(key);\n            return v == null ? 0 : v;\n        }\n\n        public long get(String key) {\n            Long v = map.get(key);\n            return v == null ? 0 : v;\n        }\n    }\n\n    static class P implements Comparable<P> {\n        int x, y;\n\n        @Override\n        public int compareTo(P p) {\n            //xy\u3067\u6607\u9806\n            return x == p.x ? y - p.y : x - p.x;\n            //xy\u3067\u964d\u9806\n            //return (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;\n            //yx\u3067\u6607\u9806\n            //return nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;\n            //yx\u3067\u6607\u9806\n            //return (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;\n\n            //x\u6607 y\u964d\n            //return nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;\n            //x\u964d y\u6607\n            //return (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;\n            //y\u6607 x\u964d\n            //return nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;\n            //y\u964d x\u6607\n            //return (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;\n        }\n\n        P(int a, int b) {\n            x = a;\n            y = b;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof P)) return false;\n            P p = (P) o;\n            return x == p.x && y == p.y;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n\n    }\n\n    static class PL implements Comparable<PL> {\n        long x, y;\n\n        public int compareTo(PL p) {\n            //xy\u3067\u6607\u9806\n            long res = x == p.x ? y - p.y : x - p.x;\n            //xy\u3067\u964d\u9806\n            //long res = (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;\n            //yx\u3067\u6607\u9806\n            //long res = nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;\n            //yx\u3067\u6607\u9806\n            //long res = (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;\n\n            //x\u6607 y\u964d\n            //long res = nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;\n            //x\u964d y\u6607\n            //long res = (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;\n            //y\u6607 x\u964d\n            //long res = nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;\n            //y\u964d x\u6607\n            //long res = (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;\n\n            return (res == 0) ? 0 : res > 0 ? 1 : -1;\n        }\n\n        PL(long a, long b) {\n            x = a;\n            y = b;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof PL)) return false;\n            PL p = (PL) o;\n            return x == p.x && y == p.y;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n\n    }\n\n    //\u5024\u3092\u6e21\u3059\u969b\u306f\u534a\u958b\u533a\u9593\n    static class RectangleSum {\n        //\u534a\u958b\u533a\u9593 0\u306f0\n        long[][] rui;\n        int H, W;\n\n        RectangleSum(long[][] ori) {\n            H = ori.length;\n            W = ori[0].length;\n            rui = new long[H + 1][W + 1];\n            for (int hi = 0; hi < H; hi++) {\n                for (int wi = 0; wi < W; wi++) {\n                    rui[hi + 1][wi + 1] = ori[hi][wi];\n                }\n            }\n            for (int hi = 1; hi < H + 1; hi++) {\n                for (int wi = 1; wi < W + 1; wi++) {\n                    rui[hi][wi] += rui[hi - 1][wi];\n                    rui[hi][wi] += rui[hi][wi - 1];\n                    rui[hi][wi] -= rui[hi - 1][wi - 1];\n                }\n            }\n        }\n\n        RectangleSum(int[][] ori) {\n            H = ori.length;\n            W = ori[0].length;\n            rui = new long[H + 1][W + 1];\n            for (int hi = 0; hi < H; hi++) {\n                for (int wi = 0; wi < W; wi++) {\n                    rui[hi + 1][wi + 1] = ori[hi][wi];\n                }\n            }\n            for (int hi = 1; hi < H + 1; hi++) {\n                for (int wi = 1; wi < W + 1; wi++) {\n                    rui[hi][wi] += rui[hi - 1][wi];\n                    rui[hi][wi] += rui[hi][wi - 1];\n                    rui[hi][wi] -= rui[hi - 1][wi - 1];\n                }\n            }\n        }\n\n        //\u534a\u958b\u533a\u9593\n        public long getSum(int left, int right, int top, int bottom) {\n            if (right > W || bottom > H) return 0;\n            if (left < 0 || top < 0) return 0;\n            if (top >= bottom || left >= right) return 0;\n            long res = rui[bottom][right];\n            res -= rui[top][right];\n            res -= rui[bottom][left];\n            res += rui[top][left];\n            return res;\n        }\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        long startTime = System.currentTimeMillis();\n        solve();\n        System.out.flush();\n        long endTime = System.currentTimeMillis();\n        if (DEBUG) System.err.println(endTime - startTime);\n    }\n\n}\nGicen the following input:\n3 1 3 1 2\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "4\n"
    }
}