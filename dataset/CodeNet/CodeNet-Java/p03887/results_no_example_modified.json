{
    "0": {
        "prompt": "Consider the following code:\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static long solve(int n, int a, int b, int c) {\n    if (b % 2 == 1) {\n      return 0;\n    }\n    \n    ModCalculator mc = new ModCalculator(1_000_000_007L);\n    ModCombinationCache mcc = new ModCombinationCache(mc);\n    long answer = 0;\n    for (int x = a; x >= 0; x--) {\n      int group1 = x;\n      \n      int restA = a - x;\n      int group2 = restA;\n      \n      int restC1 = c - restA;\n      if (restC1 < 0) {\n        break;\n      }\n      if (b > 0) {\n        for (int y = 0; y <= restC1 / 3; y++) {\n          int group3 = y;\n          int restC2 = restC1 - 3 * y;\n          int group4 = b / 2;\n          \n          long count = mcc.getC(b / 2 + restC2 - 1, b / 2 - 1);\n          count = mc.mul(count, mcc.getC(group1 + group2 + group3 + group4, group4));\n          count = mc.mul(count, mcc.getC(group1 + group2 + group3, group3));\n          count = mc.mul(count, mcc.getC(group1 + group2, group2));\n          answer = mc.add(answer, count);\n        }\n      } else if (restC1 % 3 == 0) {\n        int group3 = restC1 / 3;\n        long count = mcc.getC(group1 + group2 + group3, group3);\n        count = mc.mul(count, mcc.getC(group1 + group2, group2));\n        answer = mc.add(answer, count);\n      }\n    }\n    return answer;\n  }\n  \n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int a = reader.nextInt();\n    int b = reader.nextInt();\n    int c = reader.nextInt();\n    out.println(solve(n, a, b, c));\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private BufferedReader reader;\n  private StringTokenizer tokenizer;\n  \n  ContestReader(InputStream in) {\n    reader = new BufferedReader(new InputStreamReader(in));\n  }\n  \n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n  \n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n  \n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] nextArray(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public int[] nextIntArray(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLongArray(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDoubleArray(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public int[][] nextIntMatrix(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLongMatrix(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDoubleMatrix(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n  }\n  \n  public long add(long a, long b) {\n    return (a + b) % mod;\n  }\n  \n  public long sub(long a, long b) {\n    return (a - b + mod) % mod;\n  }\n  \n  public long mul(long a, long b) {\n    return (a * b) % mod;\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n}\n \nclass ModCombinationCache {\n  private final ModCalculator modCalculator;\n  private final List<Long> factorialCache;\n  private final List<Long> factorialInverseCache;\n  \n  public ModCombinationCache(ModCalculator modCalculator) {\n    this.modCalculator = modCalculator;\n    factorialCache = new ArrayList<>();\n    factorialCache.add(1L);\n    factorialInverseCache = new ArrayList<>();\n    factorialInverseCache.add(1L);\n  }\n  \n  private void resize(int n) {\n    for (int i = factorialCache.size() - 1; i < n; i++) {\n      long v = modCalculator.mul(factorialCache.get(i), i + 1);\n      factorialCache.add(v);\n      factorialInverseCache.add(modCalculator.inverse(v));\n    }\n  }\n  \n  public long getP(int n) {\n    resize(n);\n    return factorialCache.get(n);\n  }\n  \n  public long getC(int n, int k) {\n    resize(n);\n    return modCalculator.mul(factorialCache.get(n), modCalculator.mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n  }\n}\n\nclass Algorithm {\n  private static void swap(Object[] list, int a, int b) {\n    Object tmp = list[a];\n    list[a] = list[b];\n    list[b] = tmp;\n  }\n  \n  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {\n    int rightMostAscendingOrderIndex = ts.length - 2;\n    while (rightMostAscendingOrderIndex >= 0 &&\n        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {\n      rightMostAscendingOrderIndex--;\n    }\n    if (rightMostAscendingOrderIndex < 0) {\n      return false;\n    }\n    \n    int rightMostGreatorIndex = ts.length - 1;\n    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {\n      rightMostGreatorIndex--;\n    }\n    \n    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);\n    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {\n      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);\n    }\n    return true;\n  }\n  \n  public static void shuffle(int[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      int temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void shuffle(long[] array) {\n    Random random = new Random();\n    int n = array.length;\n    for (int i = 0; i < n; i++) {\n      int randomIndex = i + random.nextInt(n - i);\n      \n      long temp = array[i];\n      array[i] = array[randomIndex];\n      array[randomIndex] = temp;\n    }\n  }\n  \n  public static void sort(int[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n  \n  public static void sort(long[] array) {\n    shuffle(array);\n    Arrays.sort(array);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n}\n\nWhat would be the output of the code execution given the following input:\n3 1 2 0\n \nPrint the answer and end your response with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "2\n",
        "predict": "1\nEND-OF-OUTPUT"
    }
}