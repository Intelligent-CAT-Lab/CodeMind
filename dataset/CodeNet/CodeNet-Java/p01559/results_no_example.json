{
    "0": {
        "prompt": "Consider the following code:\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// MinimumCostPath\n// 2012/09/19\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tint LIM=70;\n\n\tint[] dx={0, 0, -1, 1};\n\tint[] dy={-1, 1, 0, 0};\n\n\tint n, m;\n\tint[] xs, ys;\n\tlong[] factMod, factInvMod;\n\n\tint mod=(int)1e9+9;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\txs=new int[m];\n\t\tys=new int[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\txs[i]=sc.nextInt()-1;\n\t\t\tys[i]=sc.nextInt()-1;\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solveNaive(){\n\t\tLIM=1000;\n\t\tTreeMap<P, Long> paths=new TreeMap<P, Long>();\n\t\tTreeMap<P, Integer> ds=new TreeMap<P, Integer>();\n\t\tbfsLim(paths, ds, new P(0, 0));\n\t\tif(paths.containsKey(new P(n-1, n-1))){\n\t\t\tprintln(paths.get(new P(n-1, n-1))+\"\");\n\t\t}else{\n\t\t\tprintln(\"0\");\n\t\t}\n\t}\n\n\tvoid bfsLim(TreeMap<P, Long> path, TreeMap<P, Integer> d, P p0){\n\t\tHashSet<P> wall=new HashSet<P>();\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\twall.add(new P(xs[i], ys[i]));\n\t\t}\n\n\t\tpath.put(p0, 1L);\n\t\td.put(p0, 0);\n\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(p0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(d.get(p)==LIM){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.x+dx[i], p.y+dy[i]);\n\t\t\t\tif(q.x>=0&&q.x<n&&q.y>=0&&q.y<n&&!wall.contains(q)){\n\t\t\t\t\tif(!d.containsKey(q)){\n\t\t\t\t\t\td.put(q, d.get(p)+1);\n\t\t\t\t\t\tque.offer(q);\n\t\t\t\t\t}\n\t\t\t\t\tif(d.get(p)+1==d.get(q)){\n\t\t\t\t\t\tif(!path.containsKey(q)){\n\t\t\t\t\t\t\tpath.put(q, 0L);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpath.put(q, (path.get(q)+path.get(p))%mod);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tif(n<=200){\n\t\t\tsolveNaive();\n\t\t\treturn;\n\t\t}\n\n\t\t// fact mod\n\t\tint max=2000000;\n\t\tfactMod=new long[max];\n\t\tfactInvMod=new long[max];\n\t\tfactMod[0]=factInvMod[0]=1;\n\t\tfor(int i=1; i<max; i++){\n\t\t\tfactMod[i]=factMod[i-1]*i%mod;\n\t\t\tfactInvMod[i]=factInvMod[i-1]*powMod(i, mod-2, mod)%mod;\n\t\t}\n\n\t\t// BFS\n\t\tTreeMap<P, Long> pathsS=new TreeMap<P, Long>();\n\t\tTreeMap<P, Integer> dsS=new TreeMap<P, Integer>();\n\t\tTreeMap<P, Long> pathsG=new TreeMap<P, Long>();\n\t\tTreeMap<P, Integer> dsG=new TreeMap<P, Integer>();\n\n\t\tbfsLim(pathsS, dsS, new P(0, 0));\n\t\tbfsLim(pathsG, dsG, new P(n-1, n-1));\n\n\t\tint dMin=INF;\n\t\tfor(Entry<P, Integer> entryS : dsS.entrySet()){\n\t\t\tfor(Entry<P, Integer> entryG : dsG.entrySet()){\n\t\t\t\tint ds=entryS.getValue();\n\t\t\t\tint dg=entryG.getValue();\n\t\t\t\tP p=entryS.getKey();\n\t\t\t\tP q=entryG.getKey();\n\t\t\t\tif(ds==LIM&&dg==LIM){\n\t\t\t\t\tdMin=min(dMin, ds+abs(p.x-q.x)+abs(p.y-q.y)+dg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dMin==INF){\n\t\t\tprintln(\"0\");\n\t\t\treturn;\n\t\t}\n\n\t\tHashSet<P> setS=new HashSet<P>();\n\t\tHashSet<P> setG=new HashSet<P>();\n\n\t\tfor(Entry<P, Integer> entryS : dsS.entrySet()){\n\t\t\tfor(Entry<P, Integer> entryG : dsG.entrySet()){\n\t\t\t\tint ds=entryS.getValue();\n\t\t\t\tint dg=entryG.getValue();\n\t\t\t\tP p=entryS.getKey();\n\t\t\t\tP q=entryG.getKey();\n\t\t\t\tif(ds==LIM&&dg==LIM&&ds+abs(p.x-q.x)+abs(p.y-q.y)+dg==dMin){\n\t\t\t\t\tsetS.add(p);\n\t\t\t\t\tsetG.add(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tP[] ps=new P[m];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tps[i]=new P(xs[i], ys[i]);\n\t\t}\n\t\tsort(ps);\n\n\t\tlong[] dp=new long[m];\n\t\tfor(P p : setS){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tdp[i]=(dp[i]+pathsS.get(p)*nPath(p, ps[i])%mod)%mod;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<m; j++){\n\t\t\tfor(int i=j+1; i<m; i++){\n\t\t\t\tdp[i]=(dp[i]-dp[j]*nPath(ps[j], ps[i])%mod+mod)%mod;\n\t\t\t}\n\t\t}\n\t\tlong ans=0;\n\t\tfor(P p : setG){\n\t\t\tlong sum=0;\n\t\t\tfor(P q : setS){\n\t\t\t\tsum=(sum+pathsS.get(q)*nPath(q, p)%mod*pathsG.get(p)%mod)%mod;\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tsum=(sum-dp[i]*nPath(ps[i], p)%mod*pathsG.get(p)%mod+mod)%mod;\n\t\t\t}\n\t\t\tans=(ans+sum)%mod;\n\t\t}\n\n\t\tprintln(ans+\"\");\n\t}\n\n\tlong nPath(P p, P q){\n\t\tint dx=q.x-p.x;\n\t\tint dy=q.y-p.y;\n\t\treturn modComb(dx+dy, dx);\n\t}\n\n\tlong modComb(int n, int k){\n\t\tif(n<0||k<0||n<k){\n\t\t\treturn 0;\n\t\t}\n\t\treturn factMod[n]*factInvMod[k]%mod*factInvMod[n-k]%mod;\n\t}\n\n\tlong powMod(long x, int k, int mod){\n\t\tif(k==0)\n\t\t\treturn 1;\n\t\telse if((k&1)==0)\n\t\t\treturn powMod(x*x%mod, k>>>1, mod);\n\t\telse\n\t\t\treturn x*powMod(x, k-1, mod)%mod;\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\tif(y!=p.y){\n\t\t\t\treturn y-p.y;\n\t\t\t}else{\n\t\t\t\treturn x-p.x;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode(){\n\t\t\treturn x|(y<<16);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o){\n\t\t\tP p=(P)o;\n\t\t\treturn x==p.x&&y==p.y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}Gicen the following input:\n3 0\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "6\n",
        "predict": "0\nEND-OF-OUTPUT"
    }
}