{
    "0": {
        "prompt": "Consider the following code:\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner(System.in);\n\t\t// PrintWriter pwriter = new PrintWriter(System.out);\n\t\tdo {\n\t\t\tint p = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tCasino casino = new Casino(debug);\n\t\t\tcasino.printProb(p, m, n);\n\t\t} while (debug);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Casino {\n\tboolean debug;\n\n\tpublic Casino(boolean debug) {\n\t\tthis.debug = debug;\n\t}\n\n\tpublic void printProb(int p, int m, int n) {\n\t\t// if p is 0% or 100%, the probability are same for any bets.\n\t\t// and if p is 50%, bet amount must not be greater than m when succeed.\n\t\tif (p == 0) {\n\t\t\tSystem.out.println(0d);\n\t\t\tprintBet(m);\n\t\t} else if (p == 50) {\n\t\t\t// we can get same answer\n\t\t\tif (debug)\n\t\t\t\tSystem.out.println(\"debug\\n\" + getProbLarge(p / 100d, m, n));\n\t\t\tSystem.out.println((double) m / n);\n\t\t\tprintBet(Math.min(m, n - m));\n\t\t} else if (p == 100) {\n\t\t\tSystem.out.println(1d);\n\t\t\tprintBet(m);\n\t\t} else if (p > 50) {\n\t\t\tSystem.out.println(getProbLarge(p / 100d, m, n));\n\t\t\tSystem.out.println(\"1\");\n\t\t\tSystem.out.println(\"1\");\n\t\t} else {\n\t\t\tprintProbSmall(p / 100d, m, n);\n\t\t}\n\t}\n\n\tprivate void printBet(int m) {\n\t\tSystem.out.println(m);\n\t\tSystem.out.print(\"1\");\n\t\tif (m <= 200)\n\t\t\tfor (int i = 2; i <= m; i++)\n\t\t\t\tSystem.out.print(\" \" + i);\n\t\telse {\n\t\t\tfor (int i = 2; i <= 100; i++)\n\t\t\t\tSystem.out.print(\" \" + i);\n\t\t\tfor (int i = m - 100 + 1; i <= m; i++)\n\t\t\t\tSystem.out.print(\" \" + i);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tprivate void printProbSmall(double p, int m, int n) {\n\t\tProb pb = new Prob(p, n);\n\t\tdouble hi = pb.getProbSmall(m, 1d);\n\t\tSystem.out.println(hi);\n\t\tif (debug) {\n\t\t\t// if we check all bet pattern, it can not end for larger m value\n\t\t\t// within CPU time limits.\n\t\t\t// This statement is only for check the result.\n\t\t\tint[] bet = new int[100];\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 1; i <= m; i++)\n\t\t\t\tif (Math.abs(p * pb.getProbSmall(m + i, 1d) + (1d - p) * pb.getProbSmall(m - i, 1d) - hi) < Math\n\t\t\t\t\t\t.pow(0.1, 10)) {\n\t\t\t\t\tbet[cnt++] = i;\n\t\t\t\t}\n\t\t\tSystem.out.println(\"debug\\n\" + cnt);\n\t\t\tSystem.out.print(bet[0]);\n\t\t\tfor (int i = 1; i < cnt; i++)\n\t\t\t\tSystem.out.print(\" \" + bet[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tint[] bet = new int[100];\n\t\tsetFirstBet(bet, 0, m, 0, n);\n\n\t\tArrays.sort(bet);\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i < bet.length; i++)\n\t\t\tif (bet[i] > 0 && bet[i] != bet[i - 1])\n\t\t\t\tbet[cnt++] = bet[i];\n\t\tSystem.out.println(cnt);\n\t\tSystem.out.print(bet[0]);\n\t\tfor (int i = 1; i < cnt; i++)\n\t\t\tSystem.out.print(\" \" + bet[i]);\n\t\tSystem.out.println();\n\t}\n\n\tprivate void setFirstBet(int[] bet, int cnt, int m, int min, int max) {\n\t\t// one of the best bet value is all m when m is less than half of n\n\t\t// otherwise n-m. It's just get the n.\n\t\t//\n\t\t// In case of m is less than half of n, other bet is same probability.\n\t\t//\n\t\t// for example m is 3, n is 8\n\t\t// success bet 3 , and success or fail at second bet 2, continue..\n\t\t// f(3) = p*f(6) = p*{p + (1-p)*f(4)} = pp + p(1-p)f(4)\n\t\t// success or fail first bet 1, and second bet is all\n\t\t// f(3) = p*f(4) + (1-p)*f(2) = p*f(4) + (1-p)*p*f(4) = same\n\t\t//\n\t\t// In case of m is greater than half of n\n\t\t// fail at first bet, then remain just half of n, is same probability.\n\t\t//\n\t\t// I can not prove this rule more exactly,\n\t\t// but it can recursively true\n\t\t//\n\t\tbet[cnt++] = Math.min(m - min, max - m);\n\t\tif (max > min && (max + min) % 2 == 0) {\n\t\t\tif ((max + min) / 2 > m)\n\t\t\t\tmax = (max + min) / 2;\n\t\t\telse\n\t\t\t\tmin = (max + min) / 2;\n\t\t\tsetFirstBet(bet, cnt, m, min, max);\n\t\t}\n\n\t}\n\n\tclass Prob {\n\t\tint n;\n\t\tdouble p;\n\n\t\tpublic Prob(double p, int n) {\n\t\t\tthis.p = p;\n\t\t\tthis.n = n;\n\t\t}\n\n\t\tpublic double getProbSmall(int m, double ps) {\n\t\t\t// If p is less than 50 percents, best selection is to minimize the\n\t\t\t// try count.\n\t\t\t// When we have m, and m is less than n/2, bet all m\n\t\t\t// Otherwise bet (n - m) and just get n when success.\n\t\t\t//\n\t\t\t// This function repeatedly call with same value, for example\n\t\t\t// when we have m = 2 and goal n = 3\n\t\t\t// f(2) = p + (1-p)*f(1) = p + (1-p)*p*f(2) = p + (1-p)*p*{ p +\n\t\t\t// (1-p)*f(1) } = ...\n\t\t\t//\n\t\t\t// it means if fail at first bet f(2) call f(1), and succeed in\n\t\t\t// second bet f(1) call f(2) ...\n\t\t\t// Then keep dependency of sub call as 'ps', and if it saturate to\n\t\t\t// zero percent, terminate the sub call\n\t\t\t//\n\t\t\tif (m >= n)\n\t\t\t\treturn 1d;\n\t\t\tif (m <= 0)\n\t\t\t\treturn 0d;\n\n\t\t\tif (ps < Math.pow(0.1, 15))\n\t\t\t\treturn 0d;\n\n\t\t\tdouble x = 1d;\n\t\t\tif (2 * m <= n)\n\t\t\t\tx = p * getProbSmall(2 * m, ps * p);\n\t\t\telse\n\t\t\t\tx = p + (1d - p) * getProbSmall(2 * m - n, ps * (1d - p));\n\n\t\t\treturn x;\n\t\t}\n\t}\n\n\tprivate double getProbLarge(double p, int m, int n) {\n\t\t// if p is greater than 50 percent, bet 1 by 1 is best selection\n\t\t//\n\t\t// probability to increase m to n is represented as f(m,n), then\n\t\t// --- f(m,n) = f(m,m+1) * f(m+1,n)\n\t\t// --- = f(m,m+1) * f(m+1,m+2) * (f(m+2,m+3) * ..... * f(n-1,n)\n\t\t//\n\t\t// and\n\t\t// --- f(m,m+1) = p + (1-p) * f(m-1,m) * f(m,m+1)\n\t\t// bet 1 and success, that probability is p, and probability of fail is\n\t\t// (1-p). if fail, retry increase m-1 to m, and m to m+1\n\t\t//\n\t\t// --- f(m,m+1) = p / ( 1 - (1-p) * f(m-1,m) )\n\t\t// --- f(0,1) = 0, f(1,2) = p;\n\t\t//\n\t\t// additionally f(m,m+1) saturate to 100 percent at large m value\n\t\t// when p is 51 percent, f(1000,1001), f(1001,1002),... are saturated to\n\t\t// 100 percent\n\t\t// no need to calculate\n\t\tif (m > 1000)\n\t\t\treturn 1d;\n\t\tif (n > 1000)\n\t\t\tn = 1000;\n\t\tdouble[] f = new double[n];\n\t\t// f[m] means f(m,m+1)\n\t\tf[0] = 0;\n\t\tdouble pf = 1 - p;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = p / (1 - pf * f[i - 1]);\n\n\t\tif (debug)\n\t\t\tfor (int i = 1; i < n && f[i - 1] != f[i]; i++)\n\t\t\t\tSystem.out.println(\"f(\" + i + \") = \" + f[i]);\n\n\t\tdouble result = 1d;\n\t\tfor (int i = m; i < n; i++)\n\t\t\tresult *= f[i];\n\n\t\treturn result;\n\t}\n}\n\nclass UserScanner {\n\tprivate InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic UserScanner(InputStream inStream) {\n\t\tin = inStream;\n\t}\n\n\tprivate void read() {\n\t\tptr = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(9);\n\t\t}\n\t}\n\n\tprivate byte getByte() {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (buflen < 0 || isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() {\n\t\tfor (; ptr < buflen; ptr++)\n\t\t\tif (!isCtlSpace(buffer[ptr]))\n\t\t\t\treturn;\n\t\tread();\n\t\tskipCtlSpace();\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(9);\n\t\t}\n\t}\n\n\tpublic String next() {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tskipCtlSpace();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10d;\n\t\t\t\tn += (long) (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n\n\tpublic int nextInt() {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}Gicen the following input:\n60 2 3\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "0.789473\n1\n1\n"
    }
}