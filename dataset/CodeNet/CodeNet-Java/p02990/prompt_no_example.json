{
    "0": {
        "prompt": "Consider the following code:\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\tprivate static void solve() {\n\t\tlong n = ni();\n\t\tlong k = ni();\n\t\tfinal long M = 1000000007l;\n\t\tMod m = new Mod(M);\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tlong bl = modFact(m, k - 1, k - i);\n\t\t\tlong re = modFact(m, n - k + 1, n - k - i + 1);\n\t\t\tout(bl * re % M);\n\t\t}\n\t}\n\n\tstatic long modFact(Mod m, long n, long k) {\n\t\tif (k < 0)\n\t\t\treturn 0;\n\t\tif (k > n)\n\t\t\treturn 0;\n\t\tif (n == k)\n\t\t\treturn 1;\n\t\tm.vm.set(\"n\", n);\n\t\tm.vm.set(\"k\", k);\n\t\treturn m.vm.run(\"n!/(n-k)!/k!\");\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic <A extends Comparable<? super A>> A min(A a, A b) {\n\t\treturn a.compareTo(b) < 0 ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic <A extends Comparable<? super A>> A max(A a, A b) {\n\t\treturn a.compareTo(b) > 0 ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic int abs(int a) {\n\t\treturn a < 0 ? -a : a;\n\t}\n\n\tstatic long abs(long a) {\n\t\treturn a < 0 ? -a : a;\n\t}\n\n\tstatic <A extends Comparable<? super A>> A clamp(A a, A min, A max) {\n\t\treturn a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String ns() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int ni() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nl() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double nd() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nc() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (OutOfMemoryError e) {\n\t\t\te.printStackTrace(); // this will be detected as RE\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n// TODO: paste library here\n\nclass UP<A, B> { // Unordered Pair\n\tA a;\n\tB b;\n\n\tUP(A a, B b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic <A, B> UP<A, B> make(A a, B b) {\n\t\treturn new UP<A, B>(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UP))\n\t\t\treturn false;\n\t\tUP<?, ?> p = (UP<?, ?>) o;\n\t\tboolean aok = a == null ? p.a == null : a.equals(p.a);\n\t\tboolean bok = b == null ? p.b == null : b.equals(p.b);\n\t\treturn aok && bok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \")\";\n\t}\n}\n\nclass P<A extends Comparable<? super A>, B extends Comparable<? super B>> extends UP<A, B> implements\n\t\tComparable<P<A, B>> { // Pair\n\tP(A a, B b) {\n\t\tsuper(a, b);\n\t}\n\n\tstatic <A extends Comparable<? super A>, B extends Comparable<? super B>> P<A, B> make(A a, B b) {\n\t\treturn new P<A, B>(a, b);\n\t}\n\n\tpublic int compareTo(P<A, B> o) {\n\t\tint sa = a.compareTo(o.a);\n\t\tint sb = b.compareTo(o.b);\n\t\treturn sa != 0 ? sa : sb;\n\t}\n}\n\nclass PI implements Comparable<PI> { // Pair int\n\tint a;\n\tint b;\n\n\tPI(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic PI make(int a, int b) {\n\t\treturn new PI(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof PI))\n\t\t\treturn false;\n\t\tPI p = (PI) o;\n\t\treturn a == p.a && b == p.b;\n\t}\n\n\tpublic int compareTo(PI o) {\n\t\tint sa = a - o.a;\n\t\tint sb = b - o.b;\n\t\treturn sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : 0;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a + \", \" + b + \")\";\n\t}\n}\n\nclass PL implements Comparable<PL> { // Pair long\n\tlong a;\n\tlong b;\n\n\tPL(long a, long b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic PL make(long a, long b) {\n\t\treturn new PL(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof PL))\n\t\t\treturn false;\n\t\tPL p = (PL) o;\n\t\treturn a == p.a && b == p.b;\n\t}\n\n\tpublic int compareTo(PL o) {\n\t\tlong sa = a - o.a;\n\t\tlong sb = b - o.b;\n\t\treturn sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : 0;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a + \", \" + b + \")\";\n\t}\n}\n\nclass UT<A, B, C> { // Unordered Tuple\n\tA a;\n\tB b;\n\tC c;\n\n\tUT(A a, B b, C c) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n\n\tstatic <A, B, C> UT<A, B, C> make(A a, B b, C c) {\n\t\treturn new UT<A, B, C>(a, b, c);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UT))\n\t\t\treturn false;\n\t\tUT<?, ?, ?> t = (UT<?, ?, ?>) o;\n\t\tboolean aok = a == null ? t.a == null : a.equals(t.a);\n\t\tboolean bok = b == null ? t.b == null : b.equals(t.b);\n\t\tboolean cok = c == null ? t.c == null : c.equals(t.c);\n\t\treturn aok && bok && cok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \")\";\n\t}\n}\n\nclass T<A extends Comparable<? super A>, B extends Comparable<? super B>, C extends Comparable<? super C>> extends\n\t\tUT<A, B, C> implements Comparable<T<A, B, C>> { // Tuple\n\tT(A a, B b, C c) {\n\t\tsuper(a, b, c);\n\t}\n\n\tstatic <A extends Comparable<? super A>, B extends Comparable<? super B>, C extends Comparable<? super C>> T<A, B, C> make(\n\t\t\tA a, B b, C c) {\n\t\treturn new T<A, B, C>(a, b, c);\n\t}\n\n\tpublic int compareTo(T<A, B, C> o) {\n\t\tint sa = a.compareTo(o.a);\n\t\tint sb = b.compareTo(o.b);\n\t\tint sc = c.compareTo(o.c);\n\t\treturn sa != 0 ? sa : sb != 0 ? sb : sc;\n\t}\n}\n\nclass TI implements Comparable<TI> { // Tuple int\n\tint a;\n\tint b;\n\tint c;\n\n\tTI(int a, int b, int c) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n\n\tstatic TI make(int a, int b, int c) {\n\t\treturn new TI(a, b, c);\n\t}\n\n\tTL toLong() {\n\t\treturn TL.make(a, b, c);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof TI))\n\t\t\treturn false;\n\t\tTI t = (TI) o;\n\t\treturn a == t.a && b == t.b && c == t.c;\n\t}\n\n\tpublic int compareTo(TI o) {\n\t\tint sa = a - o.a;\n\t\tint sb = b - o.b;\n\t\tint sc = c - o.c;\n\t\treturn sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : sc > 0 ? 1 : sc < 0 ? -1 : 0;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a + \", \" + b + \", \" + c + \")\";\n\t}\n}\n\nclass TL implements Comparable<TL> { // Tuple long\n\tlong a;\n\tlong b;\n\tlong c;\n\n\tTL(long a, long b, long c) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n\n\tstatic TL make(long a, long b, long c) {\n\t\treturn new TL(a, b, c);\n\t}\n\n\tTI toInt() {\n\t\treturn TI.make((int) a, (int) b, (int) c);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof TL))\n\t\t\treturn false;\n\t\tTL t = (TL) o;\n\t\treturn a == t.a && b == t.b && c == t.c;\n\t}\n\n\tpublic int compareTo(TL o) {\n\t\tlong sa = a - o.a;\n\t\tlong sb = b - o.b;\n\t\tlong sc = c - o.c;\n\t\treturn sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : sc > 0 ? 1 : sc < 0 ? -1 : 0;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a + \", \" + b + \", \" + c + \")\";\n\t}\n}\n\nfinal class U { // Utilities\n\tprivate U() {\n\t}\n\n\tstatic <A> ArrayList<A> make(int n, F.IX<A> maker) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres.add(maker.f(i));\n\t\treturn res;\n\t}\n\n\tstatic boolean[] makeB(int n, F.IB maker) {\n\t\tboolean[] res = new boolean[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres[i] = maker.f(i);\n\t\treturn res;\n\t}\n\n\tstatic int[] makeI(int n, F.II maker) {\n\t\tint[] res = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres[i] = maker.f(i);\n\t\treturn res;\n\t}\n\n\tstatic long[] makeL(int n, F.IL maker) {\n\t\tlong[] res = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres[i] = maker.f(i);\n\t\treturn res;\n\t}\n\n\tstatic <A> A[] makeX(int n, F.IX<A> maker, A[] as) {\n\t\tA[] res = Arrays.copyOf(as, n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres[i] = maker.f(i);\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> filter(ArrayList<A> as, F.XB<A> pred) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (A a : as)\n\t\t\tif (pred.f(a))\n\t\t\t\tres.add(a);\n\t\treturn res;\n\t}\n\n\tstatic <A> int count(ArrayList<A> as, F.XB<A> pred) {\n\t\tint res = 0;\n\t\tfor (A a : as)\n\t\t\tif (pred.f(a))\n\t\t\t\tres++;\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> concat(ArrayList<A> as, ArrayList<A> bs) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tres.addAll(as);\n\t\tres.addAll(bs);\n\t\treturn res;\n\t}\n\n\tstatic <A> boolean any(ArrayList<A> as, F.XB<A> pred) {\n\t\tfor (A a : as)\n\t\t\tif (pred.f(a))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tstatic <A> boolean all(ArrayList<A> as, F.XB<A> pred) {\n\t\tfor (A a : as)\n\t\t\tif (!pred.f(a))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tstatic <A> ArrayList<A> flatten(ArrayList<ArrayList<A>> ass) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (ArrayList<A> as : ass)\n\t\t\tres.addAll(as);\n\t\treturn res;\n\t}\n\n\tstatic <A, B> B foldl(ArrayList<A> as, F.XXX<B, A, B> f, B e) {\n\t\tB res = e;\n\t\tfor (A a : as)\n\t\t\tres = f.f(res, a);\n\t\treturn res;\n\t}\n\n\tstatic <A, B> B foldr(ArrayList<A> as, F.XXX<A, B, B> f, B e) {\n\t\tB res = e;\n\t\tfor (int i = as.size() - 1; i >= 0; i--)\n\t\t\tres = f.f(as.get(i), res);\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> reverse(ArrayList<A> as) {\n\t\tint size = as.size();\n\t\treturn make(size, i -> as.get(size - 1 - i));\n\t}\n\n\tstatic boolean[] reverse(boolean[] as) {\n\t\tint size = as.length;\n\t\treturn makeB(size, i -> as[size - 1 - i]);\n\t}\n\n\tstatic int[] reverse(int[] as) {\n\t\tint size = as.length;\n\t\treturn makeI(size, i -> as[size - 1 - i]);\n\t}\n\n\tstatic long[] reverse(long[] as) {\n\t\tint size = as.length;\n\t\treturn makeL(size, i -> as[size - 1 - i]);\n\t}\n\n\tstatic <A> A[] reverse(A[] as) {\n\t\tint size = as.length;\n\t\treturn makeX(size, i -> as[size - 1 - i], as);\n\t}\n\n\tstatic <A extends Comparable<? super A>> UP<TreeMap<A, Integer>, ArrayList<A>> compress(ArrayList<A> as) {\n\t\tTreeSet<A> set = new TreeSet<A>(as);\n\t\tTreeMap<A, Integer> map = new TreeMap<A, Integer>();\n\t\tArrayList<A> imap = new ArrayList<A>();\n\t\tint i = 0;\n\t\tfor (A a : set) {\n\t\t\tmap.put(a, i++);\n\t\t\timap.add(a);\n\t\t}\n\t\treturn UP.make(map, imap);\n\t}\n\n\tstatic <A, B> ArrayList<B> map(ArrayList<A> as, F.XX<A, B> f) {\n\t\treturn make(as.size(), (i) -> f.f(as.get(i)));\n\t}\n\n\tstatic <A, B> ArrayList<B> mapi(ArrayList<A> as, F.XIX<A, B> f) {\n\t\treturn make(as.size(), (i) -> f.f(as.get(i), i));\n\t}\n\n\tstatic <A, B> ArrayList<UP<A, B>> zip(ArrayList<A> as, ArrayList<B> bs) {\n\t\treturn make(min(as.size(), bs.size()), (i) -> UP.make(as.get(i), bs.get(i)));\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic <A extends Comparable<? super A>> A min(A a, A b) {\n\t\treturn a.compareTo(b) < 0 ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic <A extends Comparable<? super A>> A max(A a, A b) {\n\t\treturn a.compareTo(b) > 0 ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic <A extends Comparable<? super A>> A clamp(A a, A min, A max) {\n\t\treturn a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;\n\t}\n\n\tstatic int abs(int a) {\n\t\treturn a < 0 ? -a : a;\n\t}\n\n\tstatic long abs(long a) {\n\t\treturn a < 0 ? -a : a;\n\t}\n\n\tstatic void forEachBitPerm(int n, int k, F.IV f) {\n\t\tfor (int i = (1 << k) - 1; i < 1 << n;) {\n\t\t\tf.f(i);\n\t\t\tint t = (i | i - 1) + 1;\n\t\t\ti = t | ((t & -t) / (i & -i) >> 1) - 1;\n\t\t}\n\t}\n\n\tstatic int nextBitPerm(int a) {\n\t\tint t = (a | a - 1) + 1;\n\t\treturn t | ((t & -t) / (a & -a) >> 1) - 1;\n\t}\n\n\tstatic void mebius(int n, F.IIV f) { // s, i\n\t\tint bit = 1;\n\t\tint exp = 0;\n\t\tfor (int i = 1; i < 1 << n; i++) {\n\t\t\tf.f(i ^ bit, exp);\n\t\t\tif ((i & i + 1) == 0) {\n\t\t\t\tbit <<= 1;\n\t\t\t\texp++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void zeta(int n, F.IIV f) { // s, i\n\t\tint m = (1 << n) - 1;\n\t\tint bit = 1;\n\t\tint exp = 0;\n\t\tfor (int i = (1 << n) - 2; i >= 0; i--) {\n\t\t\tf.f(i ^ bit, exp);\n\t\t\tif ((~i & ~i + 1 & m) == 0) {\n\t\t\t\tbit <<= 1;\n\t\t\t\texp++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic <A> ArrayList<A> toAL(A[] as) {\n\t\treturn make(as.length, i -> as[i]);\n\t}\n\n\tstatic <A> A[] doubleSize(A[] as) {\n\t\treturn Arrays.copyOf(as, as.length << 1);\n\t}\n\n\tstatic long searchL(long ng, long ok, F.LB isOk) {\n\t\twhile (ng - ok > 1 || ok - ng > 1) {\n\t\t\tlong mid = ng + ok >> 1;\n\t\t\tif (isOk.f(mid))\n\t\t\t\tok = mid;\n\t\t\telse\n\t\t\t\tng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n\n\tstatic int searchI(int ng, int ok, F.IB isOk) {\n\t\treturn (int) searchL((long) ng, (long) ok, (mid) -> isOk.f((int) mid));\n\t}\n}\n\nfinal class F { // Functions\n\tprivate F() {\n\t}\n\n\tinterface VV {\n\t\tvoid f();\n\t}\n\n\tinterface BV {\n\t\tvoid f(boolean a);\n\t}\n\n\tinterface BXV<A> {\n\t\tvoid f(boolean a, A b);\n\t}\n\n\tinterface BXXV<A, B> {\n\t\tvoid f(boolean a, A b, B c);\n\t}\n\n\tinterface BXXXV<A, B, C> {\n\t\tvoid f(boolean a, A b, B c, C d);\n\t}\n\n\tinterface XBV<A> {\n\t\tvoid f(A a, boolean b);\n\t}\n\n\tinterface XXBV<A, B> {\n\t\tvoid f(A a, B b, boolean c);\n\t}\n\n\tinterface XXXBV<A, B, C> {\n\t\tvoid f(A a, B b, C c, boolean d);\n\t}\n\n\tinterface IV {\n\t\tvoid f(int a);\n\t}\n\n\tinterface IXV<A> {\n\t\tvoid f(int a, A b);\n\t}\n\n\tinterface IXXV<A, B> {\n\t\tvoid f(int a, A b, B c);\n\t}\n\n\tinterface IXXXV<A, B, C> {\n\t\tvoid f(int a, A b, B c, C d);\n\t}\n\n\tinterface XIV<A> {\n\t\tvoid f(A a, int b);\n\t}\n\n\tinterface XXIV<A, B> {\n\t\tvoid f(A a, B b, int c);\n\t}\n\n\tinterface XXXIV<A, B, C> {\n\t\tvoid f(A a, B b, C c, int d);\n\t}\n\n\tinterface LV {\n\t\tvoid f(long a);\n\t}\n\n\tinterface LXV<A> {\n\t\tvoid f(long a, A b);\n\t}\n\n\tinterface LXXV<A, B> {\n\t\tvoid f(long a, A b, B c);\n\t}\n\n\tinterface LXXXV<A, B, C> {\n\t\tvoid f(long a, A b, B c, C d);\n\t}\n\n\tinterface XLV<A> {\n\t\tvoid f(A a, long b);\n\t}\n\n\tinterface XXLV<A, B> {\n\t\tvoid f(A a, B b, long c);\n\t}\n\n\tinterface XXXLV<A, B, C> {\n\t\tvoid f(A a, B b, C c, long d);\n\t}\n\n\tinterface DV {\n\t\tvoid f(double a);\n\t}\n\n\tinterface DXV<A> {\n\t\tvoid f(double a, A b);\n\t}\n\n\tinterface DXXV<A, B> {\n\t\tvoid f(double a, A b, B c);\n\t}\n\n\tinterface DXXXV<A, B, C> {\n\t\tvoid f(double a, A b, B c, C d);\n\t}\n\n\tinterface XDV<A> {\n\t\tvoid f(A a, double b);\n\t}\n\n\tinterface XXDV<A, B> {\n\t\tvoid f(A a, B b, double c);\n\t}\n\n\tinterface XXXDV<A, B, C> {\n\t\tvoid f(A a, B b, C c, double d);\n\t}\n\n\tinterface XV<A> {\n\t\tvoid f(A a);\n\t}\n\n\tinterface XXV<A, B> {\n\t\tvoid f(A a, B b);\n\t}\n\n\tinterface XXXV<A, B, C> {\n\t\tvoid f(A a, B b, C c);\n\t}\n\n\tinterface XXXXV<A, B, C, D> {\n\t\tvoid f(A a, B b, C c, D d);\n\t}\n\n\tinterface BBV {\n\t\tvoid f(boolean a, boolean b);\n\t}\n\n\tinterface BIV {\n\t\tvoid f(boolean a, int b);\n\t}\n\n\tinterface BLV {\n\t\tvoid f(boolean a, long b);\n\t}\n\n\tinterface BDV {\n\t\tvoid f(boolean a, double b);\n\t}\n\n\tinterface IBV {\n\t\tvoid f(int a, boolean b);\n\t}\n\n\tinterface IIV {\n\t\tvoid f(int a, int b);\n\t}\n\n\tinterface ILV {\n\t\tvoid f(int a, long b);\n\t}\n\n\tinterface IDV {\n\t\tvoid f(int a, double b);\n\t}\n\n\tinterface LBV {\n\t\tvoid f(long a, boolean b);\n\t}\n\n\tinterface LIV {\n\t\tvoid f(long a, int b);\n\t}\n\n\tinterface LLV {\n\t\tvoid f(long a, long b);\n\t}\n\n\tinterface LDV {\n\t\tvoid f(long a, double b);\n\t}\n\n\tinterface DBV {\n\t\tvoid f(double a, boolean b);\n\t}\n\n\tinterface DIV {\n\t\tvoid f(double a, int b);\n\t}\n\n\tinterface DLV {\n\t\tvoid f(double a, long b);\n\t}\n\n\tinterface DDV {\n\t\tvoid f(double a, double b);\n\t}\n\n\tinterface VB {\n\t\tboolean f();\n\t}\n\n\tinterface BB {\n\t\tboolean f(boolean a);\n\t}\n\n\tinterface BXB<A> {\n\t\tboolean f(boolean a, A b);\n\t}\n\n\tinterface BXXB<A, B> {\n\t\tboolean f(boolean a, A b, B c);\n\t}\n\n\tinterface BXXXB<A, B, C> {\n\t\tboolean f(boolean a, A b, B c, C d);\n\t}\n\n\tinterface XBB<A> {\n\t\tboolean f(A a, boolean b);\n\t}\n\n\tinterface XXBB<A, B> {\n\t\tboolean f(A a, B b, boolean c);\n\t}\n\n\tinterface XXXBB<A, B, C> {\n\t\tboolean f(A a, B b, C c, boolean d);\n\t}\n\n\tinterface IB {\n\t\tboolean f(int a);\n\t}\n\n\tinterface IXB<A> {\n\t\tboolean f(int a, A b);\n\t}\n\n\tinterface IXXB<A, B> {\n\t\tboolean f(int a, A b, B c);\n\t}\n\n\tinterface IXXXB<A, B, C> {\n\t\tboolean f(int a, A b, B c, C d);\n\t}\n\n\tinterface XIB<A> {\n\t\tboolean f(A a, int b);\n\t}\n\n\tinterface XXIB<A, B> {\n\t\tboolean f(A a, B b, int c);\n\t}\n\n\tinterface XXXIB<A, B, C> {\n\t\tboolean f(A a, B b, C c, int d);\n\t}\n\n\tinterface LB {\n\t\tboolean f(long a);\n\t}\n\n\tinterface LXB<A> {\n\t\tboolean f(long a, A b);\n\t}\n\n\tinterface LXXB<A, B> {\n\t\tboolean f(long a, A b, B c);\n\t}\n\n\tinterface LXXXB<A, B, C> {\n\t\tboolean f(long a, A b, B c, C d);\n\t}\n\n\tinterface XLB<A> {\n\t\tboolean f(A a, long b);\n\t}\n\n\tinterface XXLB<A, B> {\n\t\tboolean f(A a, B b, long c);\n\t}\n\n\tinterface XXXLB<A, B, C> {\n\t\tboolean f(A a, B b, C c, long d);\n\t}\n\n\tinterface DB {\n\t\tboolean f(double a);\n\t}\n\n\tinterface DXB<A> {\n\t\tboolean f(double a, A b);\n\t}\n\n\tinterface DXXB<A, B> {\n\t\tboolean f(double a, A b, B c);\n\t}\n\n\tinterface DXXXB<A, B, C> {\n\t\tboolean f(double a, A b, B c, C d);\n\t}\n\n\tinterface XDB<A> {\n\t\tboolean f(A a, double b);\n\t}\n\n\tinterface XXDB<A, B> {\n\t\tboolean f(A a, B b, double c);\n\t}\n\n\tinterface XXXDB<A, B, C> {\n\t\tboolean f(A a, B b, C c, double d);\n\t}\n\n\tinterface XB<A> {\n\t\tboolean f(A a);\n\t}\n\n\tinterface XXB<A, B> {\n\t\tboolean f(A a, B b);\n\t}\n\n\tinterface XXXB<A, B, C> {\n\t\tboolean f(A a, B b, C c);\n\t}\n\n\tinterface XXXXB<A, B, C, D> {\n\t\tboolean f(A a, B b, C c, D d);\n\t}\n\n\tinterface BBB {\n\t\tboolean f(boolean a, boolean b);\n\t}\n\n\tinterface BIB {\n\t\tboolean f(boolean a, int b);\n\t}\n\n\tinterface BLB {\n\t\tboolean f(boolean a, long b);\n\t}\n\n\tinterface BDB {\n\t\tboolean f(boolean a, double b);\n\t}\n\n\tinterface IBB {\n\t\tboolean f(int a, boolean b);\n\t}\n\n\tinterface IIB {\n\t\tboolean f(int a, int b);\n\t}\n\n\tinterface ILB {\n\t\tboolean f(int a, long b);\n\t}\n\n\tinterface IDB {\n\t\tboolean f(int a, double b);\n\t}\n\n\tinterface LBB {\n\t\tboolean f(long a, boolean b);\n\t}\n\n\tinterface LIB {\n\t\tboolean f(long a, int b);\n\t}\n\n\tinterface LLB {\n\t\tboolean f(long a, long b);\n\t}\n\n\tinterface LDB {\n\t\tboolean f(long a, double b);\n\t}\n\n\tinterface DBB {\n\t\tboolean f(double a, boolean b);\n\t}\n\n\tinterface DIB {\n\t\tboolean f(double a, int b);\n\t}\n\n\tinterface DLB {\n\t\tboolean f(double a, long b);\n\t}\n\n\tinterface DDB {\n\t\tboolean f(double a, double b);\n\t}\n\n\tinterface VI {\n\t\tint f();\n\t}\n\n\tinterface BI {\n\t\tint f(boolean a);\n\t}\n\n\tinterface BXI<A> {\n\t\tint f(boolean a, A b);\n\t}\n\n\tinterface BXXI<A, B> {\n\t\tint f(boolean a, A b, B c);\n\t}\n\n\tinterface BXXXI<A, B, C> {\n\t\tint f(boolean a, A b, B c, C d);\n\t}\n\n\tinterface XBI<A> {\n\t\tint f(A a, boolean b);\n\t}\n\n\tinterface XXBI<A, B> {\n\t\tint f(A a, B b, boolean c);\n\t}\n\n\tinterface XXXBI<A, B, C> {\n\t\tint f(A a, B b, C c, boolean d);\n\t}\n\n\tinterface II {\n\t\tint f(int a);\n\t}\n\n\tinterface IXI<A> {\n\t\tint f(int a, A b);\n\t}\n\n\tinterface IXXI<A, B> {\n\t\tint f(int a, A b, B c);\n\t}\n\n\tinterface IXXXI<A, B, C> {\n\t\tint f(int a, A b, B c, C d);\n\t}\n\n\tinterface XII<A> {\n\t\tint f(A a, int b);\n\t}\n\n\tinterface XXII<A, B> {\n\t\tint f(A a, B b, int c);\n\t}\n\n\tinterface XXXII<A, B, C> {\n\t\tint f(A a, B b, C c, int d);\n\t}\n\n\tinterface LI {\n\t\tint f(long a);\n\t}\n\n\tinterface LXI<A> {\n\t\tint f(long a, A b);\n\t}\n\n\tinterface LXXI<A, B> {\n\t\tint f(long a, A b, B c);\n\t}\n\n\tinterface LXXXI<A, B, C> {\n\t\tint f(long a, A b, B c, C d);\n\t}\n\n\tinterface XLI<A> {\n\t\tint f(A a, long b);\n\t}\n\n\tinterface XXLI<A, B> {\n\t\tint f(A a, B b, long c);\n\t}\n\n\tinterface XXXLI<A, B, C> {\n\t\tint f(A a, B b, C c, long d);\n\t}\n\n\tinterface DI {\n\t\tint f(double a);\n\t}\n\n\tinterface DXI<A> {\n\t\tint f(double a, A b);\n\t}\n\n\tinterface DXXI<A, B> {\n\t\tint f(double a, A b, B c);\n\t}\n\n\tinterface DXXXI<A, B, C> {\n\t\tint f(double a, A b, B c, C d);\n\t}\n\n\tinterface XDI<A> {\n\t\tint f(A a, double b);\n\t}\n\n\tinterface XXDI<A, B> {\n\t\tint f(A a, B b, double c);\n\t}\n\n\tinterface XXXDI<A, B, C> {\n\t\tint f(A a, B b, C c, double d);\n\t}\n\n\tinterface XI<A> {\n\t\tint f(A a);\n\t}\n\n\tinterface XXI<A, B> {\n\t\tint f(A a, B b);\n\t}\n\n\tinterface XXXI<A, B, C> {\n\t\tint f(A a, B b, C c);\n\t}\n\n\tinterface XXXXI<A, B, C, D> {\n\t\tint f(A a, B b, C c, D d);\n\t}\n\n\tinterface BBI {\n\t\tint f(boolean a, boolean b);\n\t}\n\n\tinterface BII {\n\t\tint f(boolean a, int b);\n\t}\n\n\tinterface BLI {\n\t\tint f(boolean a, long b);\n\t}\n\n\tinterface BDI {\n\t\tint f(boolean a, double b);\n\t}\n\n\tinterface IBI {\n\t\tint f(int a, boolean b);\n\t}\n\n\tinterface III {\n\t\tint f(int a, int b);\n\t}\n\n\tinterface ILI {\n\t\tint f(int a, long b);\n\t}\n\n\tinterface IDI {\n\t\tint f(int a, double b);\n\t}\n\n\tinterface LBI {\n\t\tint f(long a, boolean b);\n\t}\n\n\tinterface LII {\n\t\tint f(long a, int b);\n\t}\n\n\tinterface LLI {\n\t\tint f(long a, long b);\n\t}\n\n\tinterface LDI {\n\t\tint f(long a, double b);\n\t}\n\n\tinterface DBI {\n\t\tint f(double a, boolean b);\n\t}\n\n\tinterface DII {\n\t\tint f(double a, int b);\n\t}\n\n\tinterface DLI {\n\t\tint f(double a, long b);\n\t}\n\n\tinterface DDI {\n\t\tint f(double a, double b);\n\t}\n\n\tinterface VL {\n\t\tlong f();\n\t}\n\n\tinterface BL {\n\t\tlong f(boolean a);\n\t}\n\n\tinterface BXL<A> {\n\t\tlong f(boolean a, A b);\n\t}\n\n\tinterface BXXL<A, B> {\n\t\tlong f(boolean a, A b, B c);\n\t}\n\n\tinterface BXXXL<A, B, C> {\n\t\tlong f(boolean a, A b, B c, C d);\n\t}\n\n\tinterface XBL<A> {\n\t\tlong f(A a, boolean b);\n\t}\n\n\tinterface XXBL<A, B> {\n\t\tlong f(A a, B b, boolean c);\n\t}\n\n\tinterface XXXBL<A, B, C> {\n\t\tlong f(A a, B b, C c, boolean d);\n\t}\n\n\tinterface IL {\n\t\tlong f(int a);\n\t}\n\n\tinterface IXL<A> {\n\t\tlong f(int a, A b);\n\t}\n\n\tinterface IXXL<A, B> {\n\t\tlong f(int a, A b, B c);\n\t}\n\n\tinterface IXXXL<A, B, C> {\n\t\tlong f(int a, A b, B c, C d);\n\t}\n\n\tinterface XIL<A> {\n\t\tlong f(A a, int b);\n\t}\n\n\tinterface XXIL<A, B> {\n\t\tlong f(A a, B b, int c);\n\t}\n\n\tinterface XXXIL<A, B, C> {\n\t\tlong f(A a, B b, C c, int d);\n\t}\n\n\tinterface LL {\n\t\tlong f(long a);\n\t}\n\n\tinterface LXL<A> {\n\t\tlong f(long a, A b);\n\t}\n\n\tinterface LXXL<A, B> {\n\t\tlong f(long a, A b, B c);\n\t}\n\n\tinterface LXXXL<A, B, C> {\n\t\tlong f(long a, A b, B c, C d);\n\t}\n\n\tinterface XLL<A> {\n\t\tlong f(A a, long b);\n\t}\n\n\tinterface XXLL<A, B> {\n\t\tlong f(A a, B b, long c);\n\t}\n\n\tinterface XXXLL<A, B, C> {\n\t\tlong f(A a, B b, C c, long d);\n\t}\n\n\tinterface DL {\n\t\tlong f(double a);\n\t}\n\n\tinterface DXL<A> {\n\t\tlong f(double a, A b);\n\t}\n\n\tinterface DXXL<A, B> {\n\t\tlong f(double a, A b, B c);\n\t}\n\n\tinterface DXXXL<A, B, C> {\n\t\tlong f(double a, A b, B c, C d);\n\t}\n\n\tinterface XDL<A> {\n\t\tlong f(A a, double b);\n\t}\n\n\tinterface XXDL<A, B> {\n\t\tlong f(A a, B b, double c);\n\t}\n\n\tinterface XXXDL<A, B, C> {\n\t\tlong f(A a, B b, C c, double d);\n\t}\n\n\tinterface XL<A> {\n\t\tlong f(A a);\n\t}\n\n\tinterface XXL<A, B> {\n\t\tlong f(A a, B b);\n\t}\n\n\tinterface XXXL<A, B, C> {\n\t\tlong f(A a, B b, C c);\n\t}\n\n\tinterface XXXXL<A, B, C, D> {\n\t\tlong f(A a, B b, C c, D d);\n\t}\n\n\tinterface BBL {\n\t\tlong f(boolean a, boolean b);\n\t}\n\n\tinterface BIL {\n\t\tlong f(boolean a, int b);\n\t}\n\n\tinterface BLL {\n\t\tlong f(boolean a, long b);\n\t}\n\n\tinterface BDL {\n\t\tlong f(boolean a, double b);\n\t}\n\n\tinterface IBL {\n\t\tlong f(int a, boolean b);\n\t}\n\n\tinterface IIL {\n\t\tlong f(int a, int b);\n\t}\n\n\tinterface ILL {\n\t\tlong f(int a, long b);\n\t}\n\n\tinterface IDL {\n\t\tlong f(int a, double b);\n\t}\n\n\tinterface LBL {\n\t\tlong f(long a, boolean b);\n\t}\n\n\tinterface LIL {\n\t\tlong f(long a, int b);\n\t}\n\n\tinterface LLL {\n\t\tlong f(long a, long b);\n\t}\n\n\tinterface LDL {\n\t\tlong f(long a, double b);\n\t}\n\n\tinterface DBL {\n\t\tlong f(double a, boolean b);\n\t}\n\n\tinterface DIL {\n\t\tlong f(double a, int b);\n\t}\n\n\tinterface DLL {\n\t\tlong f(double a, long b);\n\t}\n\n\tinterface DDL {\n\t\tlong f(double a, double b);\n\t}\n\n\tinterface VD {\n\t\tdouble f();\n\t}\n\n\tinterface BD {\n\t\tdouble f(boolean a);\n\t}\n\n\tinterface BXD<A> {\n\t\tdouble f(boolean a, A b);\n\t}\n\n\tinterface BXXD<A, B> {\n\t\tdouble f(boolean a, A b, B c);\n\t}\n\n\tinterface BXXXD<A, B, C> {\n\t\tdouble f(boolean a, A b, B c, C d);\n\t}\n\n\tinterface XBD<A> {\n\t\tdouble f(A a, boolean b);\n\t}\n\n\tinterface XXBD<A, B> {\n\t\tdouble f(A a, B b, boolean c);\n\t}\n\n\tinterface XXXBD<A, B, C> {\n\t\tdouble f(A a, B b, C c, boolean d);\n\t}\n\n\tinterface ID {\n\t\tdouble f(int a);\n\t}\n\n\tinterface IXD<A> {\n\t\tdouble f(int a, A b);\n\t}\n\n\tinterface IXXD<A, B> {\n\t\tdouble f(int a, A b, B c);\n\t}\n\n\tinterface IXXXD<A, B, C> {\n\t\tdouble f(int a, A b, B c, C d);\n\t}\n\n\tinterface XID<A> {\n\t\tdouble f(A a, int b);\n\t}\n\n\tinterface XXID<A, B> {\n\t\tdouble f(A a, B b, int c);\n\t}\n\n\tinterface XXXID<A, B, C> {\n\t\tdouble f(A a, B b, C c, int d);\n\t}\n\n\tinterface LD {\n\t\tdouble f(long a);\n\t}\n\n\tinterface LXD<A> {\n\t\tdouble f(long a, A b);\n\t}\n\n\tinterface LXXD<A, B> {\n\t\tdouble f(long a, A b, B c);\n\t}\n\n\tinterface LXXXD<A, B, C> {\n\t\tdouble f(long a, A b, B c, C d);\n\t}\n\n\tinterface XLD<A> {\n\t\tdouble f(A a, long b);\n\t}\n\n\tinterface XXLD<A, B> {\n\t\tdouble f(A a, B b, long c);\n\t}\n\n\tinterface XXXLD<A, B, C> {\n\t\tdouble f(A a, B b, C c, long d);\n\t}\n\n\tinterface DD {\n\t\tdouble f(double a);\n\t}\n\n\tinterface DXD<A> {\n\t\tdouble f(double a, A b);\n\t}\n\n\tinterface DXXD<A, B> {\n\t\tdouble f(double a, A b, B c);\n\t}\n\n\tinterface DXXXD<A, B, C> {\n\t\tdouble f(double a, A b, B c, C d);\n\t}\n\n\tinterface XDD<A> {\n\t\tdouble f(A a, double b);\n\t}\n\n\tinterface XXDD<A, B> {\n\t\tdouble f(A a, B b, double c);\n\t}\n\n\tinterface XXXDD<A, B, C> {\n\t\tdouble f(A a, B b, C c, double d);\n\t}\n\n\tinterface XD<A> {\n\t\tdouble f(A a);\n\t}\n\n\tinterface XXD<A, B> {\n\t\tdouble f(A a, B b);\n\t}\n\n\tinterface XXXD<A, B, C> {\n\t\tdouble f(A a, B b, C c);\n\t}\n\n\tinterface XXXXD<A, B, C, D> {\n\t\tdouble f(A a, B b, C c, D d);\n\t}\n\n\tinterface BBD {\n\t\tdouble f(boolean a, boolean b);\n\t}\n\n\tinterface BID {\n\t\tdouble f(boolean a, int b);\n\t}\n\n\tinterface BLD {\n\t\tdouble f(boolean a, long b);\n\t}\n\n\tinterface BDD {\n\t\tdouble f(boolean a, double b);\n\t}\n\n\tinterface IBD {\n\t\tdouble f(int a, boolean b);\n\t}\n\n\tinterface IID {\n\t\tdouble f(int a, int b);\n\t}\n\n\tinterface ILD {\n\t\tdouble f(int a, long b);\n\t}\n\n\tinterface IDD {\n\t\tdouble f(int a, double b);\n\t}\n\n\tinterface LBD {\n\t\tdouble f(long a, boolean b);\n\t}\n\n\tinterface LID {\n\t\tdouble f(long a, int b);\n\t}\n\n\tinterface LLD {\n\t\tdouble f(long a, long b);\n\t}\n\n\tinterface LDD {\n\t\tdouble f(long a, double b);\n\t}\n\n\tinterface DBD {\n\t\tdouble f(double a, boolean b);\n\t}\n\n\tinterface DID {\n\t\tdouble f(double a, int b);\n\t}\n\n\tinterface DLD {\n\t\tdouble f(double a, long b);\n\t}\n\n\tinterface DDD {\n\t\tdouble f(double a, double b);\n\t}\n\n\tinterface VX<A> {\n\t\tA f();\n\t}\n\n\tinterface BX<A> {\n\t\tA f(boolean a);\n\t}\n\n\tinterface BXX<A, B> {\n\t\tB f(boolean a, A b);\n\t}\n\n\tinterface BXXX<A, B, C> {\n\t\tC f(boolean a, A b, B c);\n\t}\n\n\tinterface BXXXX<A, B, C, D> {\n\t\tD f(boolean a, A b, B c, C d);\n\t}\n\n\tinterface XBX<A, B> {\n\t\tB f(A a, boolean b);\n\t}\n\n\tinterface XXBX<A, B, C> {\n\t\tC f(A a, B b, boolean c);\n\t}\n\n\tinterface XXXBX<A, B, C, D> {\n\t\tD f(A a, B b, C c, boolean d);\n\t}\n\n\tinterface IX<A> {\n\t\tA f(int a);\n\t}\n\n\tinterface IXX<A, B> {\n\t\tB f(int a, A b);\n\t}\n\n\tinterface IXXX<A, B, C> {\n\t\tC f(int a, A b, B c);\n\t}\n\n\tinterface IXXXX<A, B, C, D> {\n\t\tD f(int a, A b, B c, C d);\n\t}\n\n\tinterface XIX<A, B> {\n\t\tB f(A a, int b);\n\t}\n\n\tinterface XXIX<A, B, C> {\n\t\tC f(A a, B b, int c);\n\t}\n\n\tinterface XXXIX<A, B, C, D> {\n\t\tD f(A a, B b, C c, int d);\n\t}\n\n\tinterface LX<A> {\n\t\tA f(long a);\n\t}\n\n\tinterface LXX<A, B> {\n\t\tB f(long a, A b);\n\t}\n\n\tinterface LXXX<A, B, C> {\n\t\tC f(long a, A b, B c);\n\t}\n\n\tinterface LXXXX<A, B, C, D> {\n\t\tD f(long a, A b, B c, C d);\n\t}\n\n\tinterface XLX<A, B> {\n\t\tB f(A a, long b);\n\t}\n\n\tinterface XXLX<A, B, C> {\n\t\tC f(A a, B b, long c);\n\t}\n\n\tinterface XXXLX<A, B, C, D> {\n\t\tD f(A a, B b, C c, long d);\n\t}\n\n\tinterface DX<A> {\n\t\tA f(double a);\n\t}\n\n\tinterface DXX<A, B> {\n\t\tB f(double a, A b);\n\t}\n\n\tinterface DXXX<A, B, C> {\n\t\tC f(double a, A b, B c);\n\t}\n\n\tinterface DXXXX<A, B, C, D> {\n\t\tD f(double a, A b, B c, C d);\n\t}\n\n\tinterface XDX<A, B> {\n\t\tB f(A a, double b);\n\t}\n\n\tinterface XXDX<A, B, C> {\n\t\tC f(A a, B b, double c);\n\t}\n\n\tinterface XXXDX<A, B, C, D> {\n\t\tD f(A a, B b, C c, double d);\n\t}\n\n\tinterface XX<A, B> {\n\t\tB f(A a);\n\t}\n\n\tinterface XXX<A, B, C> {\n\t\tC f(A a, B b);\n\t}\n\n\tinterface XXXX<A, B, C, D> {\n\t\tD f(A a, B b, C c);\n\t}\n\n\tinterface XXXXX<A, B, C, D, E> {\n\t\tE f(A a, B b, C c, D d);\n\t}\n\n\tinterface BBX<A> {\n\t\tA f(boolean a, boolean b);\n\t}\n\n\tinterface BIX<A> {\n\t\tA f(boolean a, int b);\n\t}\n\n\tinterface BLX<A> {\n\t\tA f(boolean a, long b);\n\t}\n\n\tinterface BDX<A> {\n\t\tA f(boolean a, double b);\n\t}\n\n\tinterface IBX<A> {\n\t\tA f(int a, boolean b);\n\t}\n\n\tinterface IIX<A> {\n\t\tA f(int a, int b);\n\t}\n\n\tinterface ILX<A> {\n\t\tA f(int a, long b);\n\t}\n\n\tinterface IDX<A> {\n\t\tA f(int a, double b);\n\t}\n\n\tinterface LBX<A> {\n\t\tA f(long a, boolean b);\n\t}\n\n\tinterface LIX<A> {\n\t\tA f(long a, int b);\n\t}\n\n\tinterface LLX<A> {\n\t\tA f(long a, long b);\n\t}\n\n\tinterface LDX<A> {\n\t\tA f(long a, double b);\n\t}\n\n\tinterface DBX<A> {\n\t\tA f(double a, boolean b);\n\t}\n\n\tinterface DIX<A> {\n\t\tA f(double a, int b);\n\t}\n\n\tinterface DLX<A> {\n\t\tA f(double a, long b);\n\t}\n\n\tinterface DDX<A> {\n\t\tA f(double a, double b);\n\t}\n}\n\nclass SA { // suffix array\n\tstatic int[] makeSA(String s) {\n\t\tint n = s.length() + 1;\n\t\tint[] cs = new int[n];\n\t\tcs[n - 1] = 0;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\tcs[i] = s.charAt(i) + 1;\n\t\tArrayList<Integer> acs = U.make(n, i -> cs[i]);\n\t\tTreeMap<Integer, Integer> tm = U.compress(acs).a;\n\t\tint k = tm.size();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcs[i] = tm.get(cs[i]);\n\t\treturn makeSA(cs, n, k);\n\t}\n\n\tstatic int[] makeLCP(String s, int[] sa) { // lcp(i, i+1)\n\t\tint n = sa.length;\n\t\tint[] r = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tr[sa[i]] = i;\n\t\tint[] lcp = new int[n];\n\t\tint l = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint idx = r[i];\n\t\t\tif (idx == n - 1) {\n\t\t\t\tlcp[idx] = -1;\n\t\t\t\tl = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint p = sa[idx];\n\t\t\tint q = sa[idx + 1];\n\t\t\tif (l > 0)\n\t\t\t\tl--;\n\t\t\twhile (p + l < n - 1 && q + l < n - 1 && s.charAt(p + l) == s.charAt(q + l))\n\t\t\t\tl++;\n\t\t\tlcp[idx] = l;\n\t\t}\n\t\treturn lcp;\n\t}\n\n\tstatic F.III lcpQuery(String s) {\n\t\tint n = s.length() + 1;\n\t\tint[] sa = makeSA(s);\n\t\tint[] lcp = makeLCP(s, sa);\n\t\tint[] inv = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tinv[sa[i]] = i;\n\t\t}\n\t\tST<Integer> st = new ST<Integer>(n, (a, b) -> a < b ? a : b, Integer.MAX_VALUE);\n\t\tst.init(i -> i < n ? lcp[i] : Integer.MAX_VALUE);\n\t\treturn (i, j) -> {\n\t\t\tif (i == j)\n\t\t\t\treturn n - 1 - i;\n\t\t\ti = inv[i];\n\t\t\tj = inv[j];\n\t\t\tif (i > j) {\n\t\t\t\ti ^= j;\n\t\t\t\tj ^= i;\n\t\t\t\ti ^= j;\n\t\t\t}\n\t\t\treturn st.query(i, j);\n\t\t};\n\t}\n\n\tprivate static int[] makeSA(int[] cs, int n, int k) {\n\t\tboolean[] isS = new boolean[n];\n\t\tboolean[] isLms = new boolean[n];\n\t\tint[] lmss = new int[n];\n\t\tint numLmss = 0;\n\t\tisS[n - 1] = true;\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tisS[i] = cs[i] < cs[i + 1] || cs[i] == cs[i + 1] && isS[i + 1];\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tif (!isS[i - 1] && isS[i]) {\n\t\t\t\tlmss[numLmss++] = i;\n\t\t\t\tisLms[i] = true;\n\t\t\t}\n\t\tint[] sa = inducedSort(cs, n, numLmss, k, lmss, isS);\n\t\tint[] lmss2 = new int[numLmss];\n\t\tnumLmss = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (isLms[sa[i]])\n\t\t\t\tlmss2[numLmss++] = sa[i];\n\t\tint num = 0;\n\t\tsa[lmss2[0]] = 0;\n\t\tfor (int i = 0; i < numLmss - 1; i++) {\n\t\t\tint p = lmss2[i];\n\t\t\tint q = lmss2[i + 1];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (cs[p] != cs[q] || isLms[p] != isLms[q]) {\n\t\t\t\t\tsa[lmss2[i + 1]] = ++num;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (j > 0 && (isLms[p] || isLms[q])) {\n\t\t\t\t\tsa[lmss2[i + 1]] = num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t\tif (num + 1 < numLmss) {\n\t\t\tnumLmss = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (isLms[i])\n\t\t\t\t\tlmss2[numLmss++] = sa[i];\n\t\t\tlmss2 = makeSA(lmss2, numLmss, num + 1);\n\t\t\tfor (int i = 0; i < numLmss; i++)\n\t\t\t\tlmss2[i] = lmss[lmss2[i]];\n\t\t}\n\t\treturn inducedSort(cs, n, numLmss, k, lmss2, isS);\n\t}\n\n\tprivate static int[] inducedSort(int[] cs, int n, int numLmss, int k, int[] lmss, boolean[] isS) {\n\t\tint[] sa = new int[n];\n\t\tint[] bin = new int[k + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tbin[cs[i] + 1]++;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tbin[i + 1] += bin[i];\n\t\tint[] counts = new int[k];\n\t\tfor (int i = numLmss - 1; i >= 0; i--) { // put LMS backward\n\t\t\tint c = cs[lmss[i]];\n\t\t\tsa[bin[c + 1] - 1 - counts[c]++] = lmss[i];\n\t\t}\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tcounts[i] = 0;\n\t\tfor (int i = 0; i < n; i++) { // put L forward\n\t\t\tint s = sa[i] - 1;\n\t\t\tif (s < 0 || isS[s])\n\t\t\t\tcontinue;\n\t\t\tint c = cs[s];\n\t\t\tsa[bin[c] + counts[c]++] = s;\n\t\t}\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tcounts[i] = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) { // put S backward\n\t\t\tint s = sa[i] - 1;\n\t\t\tif (s < 0 || !isS[s])\n\t\t\t\tcontinue;\n\t\t\tint c = cs[s];\n\t\t\tsa[bin[c + 1] - 1 - counts[c]++] = s;\n\t\t}\n\t\treturn sa;\n\t}\n}\n\nclass ST<A> { // Segment Tree\n\tprivate ArrayList<A> as;\n\tprivate int h;\n\tprivate int n;\n\tprivate F.XXX<A, A, A> merger;\n\tprivate A e;\n\n\tST(int num, F.XXX<A, A, A> merger, A e) {\n\t\tthis.merger = merger;\n\t\tthis.e = e;\n\t\th = 0;\n\t\twhile ((1 << h) < num)\n\t\t\th++;\n\t\tn = 1 << h;\n\t\tas = U.make(2 * n, i -> e);\n\t}\n\n\tvoid init(A a) {\n\t\tinit(i -> a);\n\t}\n\n\tvoid init(A[] as) {\n\t\tinit(i -> i < as.length ? as[i] : e);\n\t}\n\n\tvoid init(F.IX<A> maker) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tas.set(n + i, maker.f(i));\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tas.set(i, merge(as.get(i << 1), as.get(i << 1 | 1)));\n\t}\n\n\tA get(int i) {\n\t\treturn query(i, i + 1);\n\t}\n\n\tvoid set(int i, A a) {\n\t\tas.set(i += n, a);\n\t\twhile ((i >>= 1) > 0)\n\t\t\tas.set(i, merge(as.get(i << 1), as.get(i << 1 | 1)));\n\t}\n\n\tA query(int l, int r) {\n\t\tl += n;\n\t\tr += n;\n\t\tA al = e;\n\t\tA ar = e;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) != 0)\n\t\t\t\tal = merge(al, as.get(l++));\n\t\t\tif ((r & 1) != 0)\n\t\t\t\tar = merge(as.get(--r), ar);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\t\treturn merge(al, ar);\n\t}\n\n\tprivate A merge(A a, A b) {\n\t\treturn a == e ? b : b == e ? a : merger.f(a, b);\n\t}\n}\n\ninterface Magma<A> {\n\tA g(A a, A b);\n}\n\ninterface Associative {\n}\n\ninterface Unital<A> {\n\tA e();\n}\n\ninterface Invertible<A> {\n\tA inv(A a);\n}\n\ninterface Commutative {\n}\n\ninterface SemiGroup<A> extends Magma<A>, Associative {\n}\n\ninterface Monoid<A> extends SemiGroup<A>, Unital<A> {\n\tstatic <A> Monoid<A> make(F.XXX<A, A, A> g, A e) {\n\t\treturn new Monoid<A>() {\n\t\t\tpublic A g(A a, A b) {\n\t\t\t\treturn a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);\n\t\t\t}\n\n\t\t\tpublic A e() {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface CommutativeMonoid<A> extends Monoid<A>, Commutative {\n\tstatic <A> CommutativeMonoid<A> make(F.XXX<A, A, A> g, A e) {\n\t\treturn new CommutativeMonoid<A>() {\n\t\t\tpublic A g(A a, A b) {\n\t\t\t\treturn a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);\n\t\t\t}\n\n\t\t\tpublic A e() {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface Group<A> extends Monoid<A>, Invertible<A> {\n\tstatic <A> Group<A> make(F.XXX<A, A, A> g, F.XX<A, A> inv, A e) {\n\t\treturn new Group<A>() {\n\t\t\tpublic A g(A a, A b) {\n\t\t\t\treturn a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);\n\t\t\t}\n\n\t\t\tpublic A e() {\n\t\t\t\treturn e;\n\t\t\t}\n\n\t\t\tpublic A inv(A a) {\n\t\t\t\treturn a.equals(e) ? e : inv.f(a);\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface AbelianGroup<A> extends Group<A>, CommutativeMonoid<A> {\n\tstatic <A> AbelianGroup<A> make(F.XXX<A, A, A> g, F.XX<A, A> inv, A e) {\n\t\treturn new AbelianGroup<A>() {\n\t\t\tpublic A g(A a, A b) {\n\t\t\t\treturn a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);\n\t\t\t}\n\n\t\t\tpublic A e() {\n\t\t\t\treturn e;\n\t\t\t}\n\n\t\t\tpublic A inv(A a) {\n\t\t\t\treturn a.equals(e) ? e : inv.f(a);\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface Ring<A> {\n\tAbelianGroup<A> add();\n\n\tMonoid<A> mul();\n\n\tdefault A zero() {\n\t\treturn add().e();\n\t}\n\n\tdefault A one() {\n\t\treturn mul().e();\n\t}\n\n\tstatic <A> Ring<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, A zero, A one) {\n\t\treturn make(AbelianGroup.make(add, neg, zero), Monoid.make(mul, one));\n\t}\n\n\tstatic <A> Ring<A> make(AbelianGroup<A> add, Monoid<A> mul) {\n\t\treturn new Ring<A>() {\n\t\t\tpublic AbelianGroup<A> add() {\n\t\t\t\treturn add;\n\t\t\t}\n\n\t\t\tpublic Monoid<A> mul() {\n\t\t\t\treturn mul;\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface CommutativeRing<A> extends Ring<A> {\n\tCommutativeMonoid<A> mul();\n\n\tstatic <A> CommutativeRing<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, A zero, A one) {\n\t\treturn make(AbelianGroup.make(add, neg, zero), CommutativeMonoid.make(mul, one));\n\t}\n\n\tstatic <A> CommutativeRing<A> make(AbelianGroup<A> add, CommutativeMonoid<A> mul) {\n\t\treturn new CommutativeRing<A>() {\n\t\t\tpublic AbelianGroup<A> add() {\n\t\t\t\treturn add;\n\t\t\t}\n\n\t\t\tpublic CommutativeMonoid<A> mul() {\n\t\t\t\treturn mul;\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface EuclideanRing<A> extends CommutativeRing<A> {\n\tA div(A a, A b);\n\n\tA mod(A a, A b);\n\n\tstatic <A> EuclideanRing<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, F.XXX<A, A, A> div,\n\t\t\tF.XXX<A, A, A> mod, A zero, A one) {\n\t\treturn make(AbelianGroup.make(add, neg, zero), CommutativeMonoid.make(mul, one), div, mod);\n\t}\n\n\tstatic <A> EuclideanRing<A> make(AbelianGroup<A> add, CommutativeMonoid<A> mul, F.XXX<A, A, A> div,\n\t\t\tF.XXX<A, A, A> mod) {\n\t\tfinal A zero = add.e();\n\t\tfinal A one = mul.e();\n\t\treturn new EuclideanRing<A>() {\n\t\t\tpublic AbelianGroup<A> add() {\n\t\t\t\treturn add;\n\t\t\t}\n\n\t\t\tpublic CommutativeMonoid<A> mul() {\n\t\t\t\treturn mul;\n\t\t\t}\n\n\t\t\tpublic A div(A a, A b) {\n\t\t\t\tif (b.equals(zero))\n\t\t\t\t\tthrow new ArithmeticException(\"division by zero\");\n\t\t\t\treturn b.equals(one) ? a : div.f(a, b);\n\t\t\t}\n\n\t\t\tpublic A mod(A a, A b) {\n\t\t\t\tif (b.equals(zero))\n\t\t\t\t\tthrow new ArithmeticException(\"division by zero\");\n\t\t\t\treturn b.equals(one) ? zero : mod.f(a, b);\n\t\t\t}\n\t\t};\n\t}\n}\n\ninterface Field<A> extends EuclideanRing<A> {\n\tAbelianGroup<A> mul();\n\n\tstatic <A> Field<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, F.XX<A, A> inv, A zero, A one) {\n\t\treturn make(AbelianGroup.make(add, neg, zero), AbelianGroup.make(mul, inv, one));\n\t}\n\n\tstatic <A> Field<A> make(AbelianGroup<A> add, AbelianGroup<A> mul) {\n\t\tfinal A zero = add.e();\n\t\tfinal A one = mul.e();\n\t\treturn new Field<A>() {\n\t\t\tpublic AbelianGroup<A> add() {\n\t\t\t\treturn add;\n\t\t\t}\n\n\t\t\tpublic AbelianGroup<A> mul() {\n\t\t\t\treturn mul;\n\t\t\t}\n\n\t\t\tpublic A div(A a, A b) {\n\t\t\t\tif (b.equals(zero))\n\t\t\t\t\tthrow new ArithmeticException(\"division by zero\");\n\t\t\t\treturn b.equals(one) ? a : mul.g(a, mul.inv(b));\n\t\t\t}\n\n\t\t\tpublic A mod(A a, A b) {\n\t\t\t\tif (b.equals(zero))\n\t\t\t\t\tthrow new ArithmeticException(\"division by zero\");\n\t\t\t\treturn zero;\n\t\t\t}\n\t\t};\n\t}\n}\n\nfinal class Alg {\n\tprivate Alg() {\n\t}\n\n\tstatic <A extends Comparable<? super A>> A gcd(A a, A b, EuclideanRing<A> ring) {\n\t\tAbelianGroup<A> add = ring.add();\n\t\tA zero = add.e();\n\t\tint sa = a.compareTo(zero);\n\t\tint sb = b.compareTo(zero);\n\t\tif (sa == 0)\n\t\t\treturn b;\n\t\tif (sb == 0)\n\t\t\treturn a;\n\t\tif (sa < 0)\n\t\t\ta = add.inv(a);\n\t\tif (sb < 0)\n\t\t\tb = add.inv(b);\n\t\tif (a.compareTo(b) < 0) {\n\t\t\tA tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile (true) {\n\t\t\tA c = ring.mod(a, b);\n\t\t\tif (c.compareTo(zero) == 0)\n\t\t\t\treturn b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\tif (a < 0)\n\t\t\ta = -a;\n\t\tif (b < 0)\n\t\t\tb = -b;\n\t\tif (a < b) {\n\t\t\ta ^= b;\n\t\t\tb ^= a;\n\t\t\ta ^= b;\n\t\t}\n\t\twhile (true) {\n\t\t\tlong c = a % b;\n\t\t\tif (c == 0)\n\t\t\t\treturn b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\treturn (int) gcd((long) a, (long) b);\n\t}\n\n\tstatic <A extends Comparable<A>> int[] lis(F.IX<A> access, int size) {\n\t\tObject[] dp = new Object[size];\n\t\tint[][] dpIndices = new int[size][2];\n\t\tdp[0] = access.f(0);\n\t\tint len = 1;\n\t\tint lidx = 0;\n\t\tfor (int i = 1; i < size; i++) {\n\t\t\tA ai = access.f(i);\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tint idx = U.searchI(-1, len, j -> ai.compareTo((A) dp[j]) <= 0); // replace <= with < to return NLDS\n\t\t\tdp[idx] = ai;\n\t\t\tdpIndices[idx][0] = i;\n\t\t\tif (idx == len) {\n\t\t\t\tlidx = i;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (idx > 0)\n\t\t\t\tdpIndices[i][1] = dpIndices[idx - 1][0];\n\t\t}\n\t\tint[] res = new int[len];\n\t\tres[len - 1] = lidx;\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tres[i] = lidx;\n\t\t\tlidx = dpIndices[lidx][1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> A pow(A a, long b, Monoid<A> monoid) {\n\t\tA res = monoid.e();\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) != 0)\n\t\t\t\tres = monoid.g(res, a);\n\t\t\ta = monoid.g(a, a);\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long pow(long a, long b) {\n\t\tlong res = 1;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) != 0)\n\t\t\t\tres *= a;\n\t\t\ta *= a;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A extends Comparable<? super A>> T<A, A, A> extgcd(A a, A b, EuclideanRing<A> ring) { // returns (x, y, d) s.t. ax + by = d\n\t\tAbelianGroup<A> add = ring.add();\n\t\tCommutativeMonoid<A> mul = ring.mul();\n\t\tA zero = add.e();\n\t\tA one = mul.e();\n\t\tA sa = a.compareTo(zero) < 0 ? add.inv(one) : one;\n\t\tA sb = b.compareTo(zero) < 0 ? add.inv(one) : one;\n\t\ta = mul.g(a, sa);\n\t\tb = mul.g(b, sb);\n\t\tA x = one;\n\t\tA y = zero;\n\t\tA z = zero;\n\t\tA w = one;\n\t\twhile (b.compareTo(zero) > 0) {\n\t\t\tA q = ring.div(a, b);\n\t\t\tA t = z;\n\t\t\tz = add.g(x, add.inv(mul.g(q, z)));\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = add.g(y, add.inv(mul.g(q, w)));\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = add.g(a, add.inv(mul.g(q, b)));\n\t\t\ta = t;\n\t\t}\n\t\treturn T.make(mul.g(x, sa), mul.g(y, sb), a);\n\t}\n\n\tstatic TL extgcd(long a, long b) {\n\t\tint sa = a < 0 ? -1 : 1;\n\t\tint sb = b < 0 ? -1 : 1;\n\t\ta *= sa;\n\t\tb *= sb;\n\t\tlong x = 1;\n\t\tlong y = 0;\n\t\tlong z = 0;\n\t\tlong w = 1;\n\t\twhile (b > 0) {\n\t\t\tlong q = a / b;\n\t\t\tlong t = z;\n\t\t\tz = x - q * z;\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = y - q * w;\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = a - q * b;\n\t\t\ta = t;\n\t\t}\n\t\treturn TL.make(x * sa, y * sb, a);\n\t}\n\n\tstatic TI extgcd(int a, int b) {\n\t\treturn extgcd((long) a, (long) b).toInt();\n\t}\n\n\tstatic ArrayList<PI> factorize(int n) { // factor, exponent\n\t\tArrayList<PI> res = new ArrayList<PI>();\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tint count = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > 0)\n\t\t\t\tres.add(PI.make(i, count));\n\t\t}\n\t\tif (n > 1)\n\t\t\tres.add(PI.make(n, 1));\n\t\treturn res;\n\t}\n\n\tstatic <A> A arithSum(A a, A d, long num, Ring<A> ring) {\n\t\treturn arithGeomSum(a, d, ring.one(), ring.one(), num, ring);\n\t}\n\n\tstatic <A> A geomSum(A b, A r, long num, Ring<A> ring) {\n\t\treturn arithGeomSum(ring.one(), ring.zero(), b, r, num, ring);\n\t}\n\n\tstatic <A> A arithGeomSum(A a, A d, A b, A r, long num, Ring<A> ring) { // \u03a3(a+(i-1)d)br^(i-1)\n\t\tAbelianGroup<A> add = ring.add();\n\t\tMonoid<A> mul = ring.mul();\n\t\tMonoid<MN<A>> matMul = Mat.mulRing(3, ring);\n\t\tA zero = ring.zero();\n\t\tA one = ring.one();\n\t\tMN<A> mat = pow(Mat.make(new Object[][] { { r, d, a }, { zero, r, r }, { zero, zero, one } }), num - 1, matMul);\n\t\treturn mul.g(add.g(add.g(mul.g(mat.at(0, 0), a), mul.g(mat.at(0, 1), r)), mat.at(0, 2)), b);\n\t}\n}\n\nclass MN<A> {\n\tfinal int m;\n\tfinal int n;\n\tprivate final Object[][] as;\n\n\tstatic class Scalar<A> extends MN<A> {\n\t\tfinal long l;\n\t\tA a;\n\n\t\tScalar(int m, int n, long l, A zero, A oneTimesL) {\n\t\t\tsuper(m, n, (i, j) -> i == j ? oneTimesL : zero);\n\t\t\tthis.a = oneTimesL;\n\t\t\tthis.l = l;\n\t\t}\n\t}\n\n\tMN(int m, int n, Mat.Accessor<A> accessor) {\n\t\tthis.m = m;\n\t\tthis.n = n;\n\t\tas = new Object[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tas[i][j] = accessor.at(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\ts += i == 0 ? \"[[ \" : \" [ \";\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\ts += (j == 0 ? \"\" : \", \") + as[i][j];\n\t\t\t}\n\t\t\ts += i == m - 1 ? \" ]]\" : \" ]\\n\";\n\t\t}\n\t\treturn s;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tA at(int i, int j) {\n\t\treturn (A) as[i][j];\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tA[][] toArray() {\n\t\tA[][] res = (A[][]) Array.newInstance(as[0][0].getClass(), m, n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tres[i][j] = (A) as[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint[][] toIntArray() {\n\t\tint[][] res = new int[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tres[i][j] = (int) as[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tlong[][] toLongArray() {\n\t\tlong[][] res = new long[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tres[i][j] = (long) as[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tdouble[][] toDoubleArray() {\n\t\tdouble[][] res = new double[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tres[i][j] = (double) as[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Mat<A> {\n\tinterface Accessor<A> {\n\t\tA at(int i, int j);\n\t}\n\n\tprivate static <A> MN.Scalar<A> make(int m, int n, long l, A zero, A oneTimesL) {\n\t\treturn new MN.Scalar<A>(m, n, l, zero, oneTimesL);\n\t}\n\n\tstatic <A> MN<A> make(int m, int n, Accessor<A> accessor) {\n\t\treturn new MN<A>(m, n, accessor);\n\t}\n\n\tstatic <A> MN<A> make(int m, int n, A[][] as) {\n\t\treturn new MN<A>(m, n, (i, j) -> as[i][j]);\n\t}\n\n\tstatic MN<Long> make(int[][] as) {\n\t\treturn new MN<Long>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> (long) as[i][j]);\n\t}\n\n\tstatic MN<Long> make(long[][] as) {\n\t\treturn new MN<Long>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> as[i][j]);\n\t}\n\n\tstatic MN<Double> make(double[][] as) {\n\t\treturn new MN<Double>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> as[i][j]);\n\t}\n\n\tstatic <A> MN<A> make(int[][] as, F.IX<A> toA) {\n\t\treturn new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));\n\t}\n\n\tstatic <A> MN<A> make(long[][] as, F.LX<A> toA) {\n\t\treturn new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));\n\t}\n\n\tstatic <A> MN<A> make(double[][] as, F.DX<A> toA) {\n\t\treturn new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));\n\t}\n\n\tstatic <A, B> MN<A> make(B[][] as, F.XX<B, A> toA) {\n\t\treturn new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic <A> MN<A> make(Object[][] as) {\n\t\treturn new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> (A) as[i][j]);\n\t}\n\n\tstatic <A> MN<A> eye(int n, Ring<A> ring) {\n\t\treturn make(n, n, (i, j) -> i == j ? ring.mul().e() : ring.add().e());\n\t}\n\n\tstatic <A> AbelianGroup<MN<A>> add(int m, int n, Ring<A> ring) {\n\t\treturn AbelianGroup.make((a, b) -> add(a, b, ring), a -> neg(a, ring), make(m, n, 0, ring.zero(), ring.zero()));\n\t}\n\n\tstatic <A> Monoid<MN<A>> mulRing(int n, Ring<A> ring) {\n\t\treturn Monoid.make((a, b) -> mul(a, b, ring), make(n, n, 1, ring.zero(), ring.one()));\n\t}\n\n\tstatic <A> AbelianGroup<MN<A>> mulField(int n, Field<A> field) {\n\t\treturn AbelianGroup.make((a, b) -> mul(a, b, field), a -> inv(a, field),\n\t\t\t\tmake(n, n, 1, field.zero(), field.one()));\n\t}\n\n\tstatic <A> MN<A> add(MN<A> a, MN<A> b, Ring<A> ring) {\n\t\tint m = U.max(a.m, b.m);\n\t\tint n = U.max(a.n, b.n);\n\t\tAbelianGroup<A> add = ring.add();\n\t\tif (a instanceof MN.Scalar && b instanceof MN.Scalar) {\n\t\t\tMN.Scalar<A> as = ((MN.Scalar<A>) a);\n\t\t\tMN.Scalar<A> bs = ((MN.Scalar<A>) b);\n\t\t\treturn make(m, n, as.l + bs.l, ring.zero(), add.g(as.a, bs.a));\n\t\t}\n\t\treturn make(m, n, (i, j) -> add.g(a.at(i, j), b.at(i, j)));\n\t}\n\n\tstatic <A> MN<A> neg(MN<A> a, Ring<A> ring) {\n\t\tif (a instanceof MN.Scalar) {\n\t\t\tMN.Scalar<A> as = ((MN.Scalar<A>) a);\n\t\t\treturn make(a.m, a.n, -as.l, ring.zero(), ring.add().inv(as.a));\n\t\t}\n\t\treturn make(a.m, a.n, (i, j) -> ring.add().inv(a.at(i, j)));\n\t}\n\n\tstatic <A> MN<A> mul(MN<A> a, MN<A> b, Ring<A> ring) {\n\t\tint m = a.m;\n\t\tint u = U.max(a.n, b.m);\n\t\tint n = b.n;\n\t\tAbelianGroup<A> add = ring.add();\n\t\tMonoid<A> mul = ring.mul();\n\t\tif (a instanceof MN.Scalar && b instanceof MN.Scalar) {\n\t\t\tMN.Scalar<A> as = ((MN.Scalar<A>) a);\n\t\t\tMN.Scalar<A> bs = ((MN.Scalar<A>) b);\n\t\t\treturn make(m, n, as.l * bs.l, ring.zero(), mul.g(as.a, bs.a));\n\t\t}\n\t\treturn make(m, n, (i, j) -> {\n\t\t\tA res = ring.zero();\n\t\t\tfor (int k = 0; k < u; k++)\n\t\t\t\tres = add.g(res, mul.g(a.at(i, k), b.at(k, j)));\n\t\t\treturn res;\n\t\t});\n\t}\n\n\tstatic <A> A det(MN<A> a, Field<A> field) {\n\t\treturn detInv(a, field).a;\n\t}\n\n\tstatic <A> MN<A> inv(MN<A> a, Field<A> field) {\n\t\tUP<A, MN<A>> detInv = detInv(a, field);\n\t\tif (detInv.a.equals(field.zero()))\n\t\t\tthrow new ArithmeticException(\"inverse does not exist: det=0\");\n\t\treturn detInv.b;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <A> UP<A, MN<A>> detInv(MN<A> a, Field<A> field) {\n\t\tif (a.m != a.n)\n\t\t\tthrow new IllegalArgumentException(\"matrix not square\");\n\t\tif (field.zero() instanceof Long) {\n\t\t\tUP<Long, MN<Long>> detInv = detInvLong((MN<Long>) a, (Field<Long>) field);\n\t\t\treturn UP.make((A) detInv.a, (MN<A>) detInv.b);\n\t\t}\n\t\tint n = a.n;\n\t\tAbelianGroup<A> add = field.add();\n\t\tAbelianGroup<A> mul = field.mul();\n\t\tA zero = field.zero();\n\t\tA one = field.one();\n\t\tA[][] m1 = a.toArray();\n\t\tA[][] m2 = eye(n, field).toArray();\n\t\tA res = one;\n\t\tint sign = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint pivot = -1;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (!m1[j][i].equals(zero)) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pivot == -1) {\n\t\t\t\treturn UP.make(zero, null);\n\t\t\t}\n\t\t\tif (pivot != i) {\n\t\t\t\tsign = -sign;\n\t\t\t\tA tmp;\n\t\t\t\tfor (int j = i; j < n; j++) { // [0, i) are zero\n\t\t\t\t\ttmp = m1[i][j];\n\t\t\t\t\tm1[i][j] = m1[pivot][j];\n\t\t\t\t\tm1[pivot][j] = tmp;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\ttmp = m2[i][j];\n\t\t\t\t\tm2[i][j] = m2[pivot][j];\n\t\t\t\t\tm2[pivot][j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tA d = m1[i][i];\n\t\t\tres = mul.g(res, d);\n\t\t\td = mul.inv(d);\n\t\t\tm1[i][i] = one;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tm1[i][j] = mul.g(m1[i][j], d);\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tm2[i][j] = mul.g(m2[i][j], d);\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tA mult = m1[j][i];\n\t\t\t\tm1[j][i] = zero;\n\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\tm1[j][k] = add.g(m1[j][k], add.inv(mul.g(m1[i][k], mult)));\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tm2[j][k] = add.g(m2[j][k], add.inv(mul.g(m2[i][k], mult)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn UP.make(sign == 1 ? res : add.inv(res), make(m2));\n\t}\n\n\tprivate static UP<Long, MN<Long>> detInvLong(MN<Long> a, Field<Long> field) {\n\t\tif (a.m != a.n)\n\t\t\tthrow new IllegalArgumentException(\"matrix not square\");\n\t\tint n = a.n;\n\t\tAbelianGroup<Long> add = field.add();\n\t\tAbelianGroup<Long> mul = field.mul();\n\t\tlong zero = field.zero();\n\t\tlong one = field.one();\n\t\tlong[][] m1 = a.toLongArray();\n\t\tlong[][] m2 = eye(n, field).toLongArray();\n\t\tlong res = one;\n\t\tint sign = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint pivot = -1;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (m1[j][i] != zero) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pivot == -1) {\n\t\t\t\treturn UP.make(zero, null);\n\t\t\t}\n\t\t\tif (pivot != i) {\n\t\t\t\tsign = -sign;\n\t\t\t\tlong tmp;\n\t\t\t\tfor (int j = i; j < n; j++) { // [0, i) are zero\n\t\t\t\t\ttmp = m1[i][j];\n\t\t\t\t\tm1[i][j] = m1[pivot][j];\n\t\t\t\t\tm1[pivot][j] = tmp;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\ttmp = m2[i][j];\n\t\t\t\t\tm2[i][j] = m2[pivot][j];\n\t\t\t\t\tm2[pivot][j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong d = m1[i][i];\n\t\t\tres = mul.g(res, d);\n\t\t\td = mul.inv(d);\n\t\t\tm1[i][i] = one;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tm1[i][j] = mul.g(m1[i][j], d);\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tm2[i][j] = mul.g(m2[i][j], d);\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong mult = m1[j][i];\n\t\t\t\tm1[j][i] = zero;\n\t\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\t\tm1[j][k] = add.g(m1[j][k], add.inv(mul.g(m1[i][k], mult)));\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tm2[j][k] = add.g(m2[j][k], add.inv(mul.g(m2[i][k], mult)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn UP.make(sign == 1 ? res : add.inv(res), make(m2));\n\t}\n\n\tstatic <A> Ring<MN<A>> ring(int n, Ring<A> ring) {\n\t\treturn Ring.make(add(n, n, ring), mulRing(n, ring));\n\t}\n\n\tstatic <A> Field<MN<A>> field(int n, Field<A> field) {\n\t\treturn Field.make(add(n, n, field), mulField(n, field));\n\t}\n\n\tstatic <A> VM<MN<A>> vm(int n, Ring<A> ring) {\n\t\tif (ring instanceof Field)\n\t\t\treturn vmField(n, (Field<A>) ring);\n\t\treturn vmRing(n, ring);\n\t}\n\n\tprivate static <A> VM<MN<A>> vmRing(int n, Ring<A> ring) {\n\t\tRing<MN<A>> matRing = ring(n, ring);\n\t\tMonoid<MN<A>> matMul = matRing.mul();\n\t\tAbelianGroup<A> add = ring.add();\n\t\tMonoid<A> mul = ring.mul();\n\t\tA zero = add.e();\n\t\tA one = mul.e();\n\t\treturn new VM<MN<A>>(matRing, null, null, (a, b) -> {\n\t\t\tif (b instanceof MN.Scalar) {\n\t\t\t\tMN.Scalar<A> bs = ((MN.Scalar<A>) b);\n\t\t\t\tif (bs.l < 0)\n\t\t\t\t\tthrow new RuntimeException(\"pow(MN, <0) is not defined\");\n\t\t\t\treturn Alg.pow(a, bs.l, matMul);\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"pow(MN, MN) is not defined\");\n\t\t}, null, l -> make(n, n, l, zero, Alg.pow(one, l, add)), a -> a);\n\t}\n\n\tprivate static <A> VM<MN<A>> vmField(int n, Field<A> field) {\n\t\tField<MN<A>> matField = field(n, field);\n\t\tAbelianGroup<MN<A>> matMul = matField.mul();\n\t\tA zero = field.zero();\n\t\tA one = field.one();\n\t\treturn new VM<MN<A>>(matField, (a, b) -> {\n\t\t\tif (b instanceof MN.Scalar) {\n\t\t\t\tMN.Scalar<A> bs = ((MN.Scalar<A>) b);\n\t\t\t\tif (bs.l < 0)\n\t\t\t\t\treturn Alg.pow(inv(a, field), -bs.l, matMul);\n\t\t\t\treturn Alg.pow(a, bs.l, matMul);\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"pow(MN, MN) is not defined\");\n\t\t}, a -> inv(a, field), l -> make(n, n, l, zero, Alg.pow(one, l, field.add())), a -> a);\n\t}\n}\n\nclass VM<A> {\n\tprivate final HashMap<String, A> env;\n\tprivate final Evaluator<A> etor;\n\tprivate final F.XX<A, A> filter;\n\n\tVM(F.XXX<A, A, A> add, F.XXX<A, A, A> sub, F.XXX<A, A, A> mul, F.XXX<A, A, A> div, F.XXX<A, A, A> mod,\n\t\t\tF.XXX<A, A, A> pow, F.XX<A, A> neg, F.XX<A, A> fact, F.LX<A> fromInt, F.XX<A, A> filter) {\n\t\tenv = new HashMap<String, A>();\n\t\tetor = SimpleLang.makeEvaluator((s, a) -> {\n\t\t\tenv.put(s, a);\n\t\t\treturn a;\n\t\t}, add, sub, mul, div, mod, pow, neg, fact, fromInt, s -> {\n\t\t\tif (env.containsKey(s))\n\t\t\t\treturn env.get(s);\n\t\t\tthrow new RuntimeException(\"no such variable: \" + s);\n\t\t});\n\t\tthis.filter = filter;\n\t}\n\n\tVM(Ring<A> ring, F.XXX<A, A, A> div, F.XXX<A, A, A> mod, F.XXX<A, A, A> pow, F.XX<A, A> fact, F.LX<A> fromInt,\n\t\t\tF.XX<A, A> filter) {\n\t\tthis(ring.add()::g, (a, b) -> ring.add().g(a, ring.add().inv(b)), ring.mul()::g, div, mod, pow,\n\t\t\t\tring.add()::inv, fact, fromInt, filter);\n\t}\n\n\tVM(EuclideanRing<A> ring, F.XXX<A, A, A> pow, F.XX<A, A> fact, F.LX<A> fromInt, F.XX<A, A> filter) {\n\t\tthis(ring, ring::div, ring::mod, pow, fact, fromInt, filter);\n\t}\n\n\tvoid clear() {\n\t\tenv.clear();\n\t}\n\n\tA get(String id) {\n\t\treturn env.get(id);\n\t}\n\n\tvoid print(String id, F.XV<String> printer) {\n\t\tprinter.f(\"\" + get(id));\n\t}\n\n\t@SafeVarargs\n\tfinal void set(String idsSp, A... as) {\n\t\tString[] ids = idsSp.trim().split(\" +\");\n\t\tint n = ids.length;\n\t\tif (as.length != n)\n\t\t\tthrow new IllegalArgumentException(\"argument size mismatch: \" + n + \" != \" + as.length);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tset(ids[i], as[i]);\n\t}\n\n\tvoid set(String id, A a) {\n\t\tenv.put(id, filter.f(a));\n\t}\n\n\tA run(String expr) {\n\t\treturn AST.eval(SimpleLang.parse(expr), etor);\n\t}\n}\n\nclass AST { // Abstract Syntax Tree\n\tstatic class AssignOp extends AST {\n\t\tString id;\n\t\tAST r;\n\n\t\tAssignOp(String id, AST r) {\n\t\t\tthis.id = id;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"Assign(\" + id + \", \" + r + \")\";\n\t\t}\n\t}\n\n\tstatic class Multi extends AST {\n\t\tArrayList<AST> as;\n\n\t\tMulti(ArrayList<AST> as) {\n\t\t\tthis.as = as;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tString s = \"\";\n\t\t\tfor (AST a : as)\n\t\t\t\ts += s.isEmpty() ? a : \"; \" + a;\n\t\t\treturn \"Multi(\" + s + \")\";\n\t\t}\n\t}\n\n\tstatic class BinOp extends AST {\n\t\tAST l;\n\t\tAST r;\n\t\tString op;\n\n\t\tBinOp(AST l, String op, AST r) {\n\t\t\tthis.l = l;\n\t\t\tthis.op = op;\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"BinOp(\" + l + \", \" + op + \", \" + r + \")\";\n\t\t}\n\t}\n\n\tstatic class UnOp extends AST {\n\t\tAST a;\n\t\tString op;\n\n\t\tUnOp(String op, AST a) {\n\t\t\tthis.op = op;\n\t\t\tthis.a = a;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"UnOp(\" + op + \", \" + a + \")\";\n\t\t}\n\t}\n\n\tstatic class Int extends AST {\n\t\tlong v;\n\n\t\tInt(long v) {\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"Int(\" + v + \")\";\n\t\t}\n\t}\n\n\tstatic class Id extends AST {\n\t\tString s;\n\n\t\tId(String s) {\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"Id(\" + s + \")\";\n\t\t}\n\t}\n\n\tstatic <A> A eval(AST a, Evaluator<A> etor) {\n\t\tif (a instanceof AssignOp)\n\t\t\treturn etor.assign(((AssignOp) a).id, eval(((AssignOp) a).r, etor));\n\t\tif (a instanceof Multi) {\n\t\t\tA last = null;\n\t\t\tfor (AST a2 : ((Multi) a).as)\n\t\t\t\tlast = eval(a2, etor);\n\t\t\treturn last;\n\t\t}\n\t\tif (a instanceof BinOp)\n\t\t\treturn etor.binOp(((BinOp) a).op, eval(((BinOp) a).l, etor), eval(((BinOp) a).r, etor));\n\t\tif (a instanceof UnOp)\n\t\t\treturn etor.unOp(((UnOp) a).op, eval(((UnOp) a).a, etor));\n\t\tif (a instanceof Int)\n\t\t\treturn etor.fromInt(((Int) a).v);\n\t\tif (a instanceof Id)\n\t\t\treturn etor.id(((Id) a).s);\n\t\tthrow new RuntimeException(\"unexpected ast: \" + a);\n\t}\n}\n\ninterface Evaluator<A> {\n\tA assign(String s, A a);\n\n\tA binOp(String op, A a, A b);\n\n\tA unOp(String op, A a);\n\n\tA fromInt(long a);\n\n\tA id(String s);\n}\n\nclass Seq<A> {\n\tArrayList<A> as;\n\tint ptr;\n\n\tSeq(ArrayList<A> as) {\n\t\tthis.as = as;\n\t\tptr = 0;\n\t}\n\n\tboolean hasNext(int num) {\n\t\treturn ptr + num < as.size();\n\t}\n\n\tboolean hasNext() {\n\t\treturn hasNext(0);\n\t}\n\n\tA next(int num) {\n\t\treturn ptr + num < as.size() ? as.get(ptr + num) : null;\n\t}\n\n\tA next() {\n\t\treturn next(0);\n\t}\n\n\tA read() {\n\t\treturn hasNext() ? as.get(ptr++) : null;\n\t}\n\n\tA read(A a) {\n\t\tif (!hasNext())\n\t\t\tthrow new RuntimeException(\"unexpected EOF\");\n\t\tif (!isNext(a))\n\t\t\tthrow new RuntimeException(\"expected \" + a + \" but got\" + next());\n\t\treturn read();\n\t}\n\n\tA read(F.XX<A, Boolean> f) {\n\t\tif (!hasNext())\n\t\t\tthrow new RuntimeException(\"unexpected EOF\");\n\t\tif (!f.f(next()))\n\t\t\tthrow new RuntimeException(\"f(\" + next() + \") returned false\");\n\t\treturn read();\n\t}\n\n\tboolean isNext(A a) {\n\t\treturn a.equals(next());\n\t}\n\n\tboolean isNext(@SuppressWarnings(\"unchecked\") A... as) {\n\t\tfor (A a : as)\n\t\t\tif (isNext(a))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tboolean isNext(F.XX<A, Boolean> f) {\n\t\treturn hasNext() && f.f(next());\n\t}\n\n\tA readIf(F.XX<A, Boolean> f) {\n\t\tif (isNext(f))\n\t\t\treturn read();\n\t\treturn null;\n\t}\n\n\tA readIf(@SuppressWarnings(\"unchecked\") A... as) {\n\t\tfor (A a : as)\n\t\t\tif (isNext(a)) {\n\t\t\t\tptr++;\n\t\t\t\treturn a;\n\t\t\t}\n\t\treturn null;\n\t}\n\n\tpublic String toString() {\n\t\treturn as.toString();\n\t}\n}\n\nclass Token extends P<String, Integer> {\n\tprivate static final int ID = 1;\n\tprivate static final int SYM = 2;\n\tprivate static final int INT = 3;\n\n\tToken(String s, int type) {\n\t\tsuper(s, type);\n\t}\n\n\tboolean is(String s) {\n\t\treturn a.equals(s);\n\t}\n\n\tstatic Token ofId(String s) {\n\t\treturn new Token(s, ID);\n\t}\n\n\tstatic Token ofSym(String s) {\n\t\treturn new Token(s, SYM);\n\t}\n\n\tstatic Token ofInt(String s) {\n\t\treturn new Token(s, INT);\n\t}\n\n\tboolean isId() {\n\t\treturn b == ID;\n\t}\n\n\tboolean isSym() {\n\t\treturn b == SYM;\n\t}\n\n\tboolean isInt() {\n\t\treturn b == INT;\n\t}\n}\n\nclass SimpleLang {\n\tprivate static class Tokenizer {\n\t\tprivate static final String SYMS = \"+-*/%^!()=;\";\n\n\t\tSeq<Character> sc;\n\t\tArrayList<Token> ts;\n\n\t\tTokenizer(String s) {\n\t\t\tsc = new Seq<Character>(U.make(s.length(), i -> s.charAt(i)));\n\t\t}\n\n\t\tSeq<Token> parse() {\n\t\t\tts = new ArrayList<Token>();\n\t\t\tparseAll();\n\t\t\treturn new Seq<Token>(ts);\n\t\t}\n\n\t\tprivate static boolean isSpace(char c) {\n\t\t\treturn c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n\t\t}\n\n\t\tprivate static boolean isDigit(char c) {\n\t\t\treturn c >= '0' && c <= '9';\n\t\t}\n\n\t\tprivate static boolean isSymbol(char c) {\n\t\t\treturn SYMS.indexOf(c) != -1;\n\t\t}\n\n\t\tprivate static boolean isAlpha(char c) {\n\t\t\treturn c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_';\n\t\t}\n\n\t\tprivate void parseAll() {\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\twhile (sc.isNext(Tokenizer::isSpace))\n\t\t\t\t\tsc.read();\n\t\t\t\tif (!sc.hasNext())\n\t\t\t\t\tbreak;\n\t\t\t\tif (sc.isNext(Tokenizer::isAlpha)) {\n\t\t\t\t\tparseId();\n\t\t\t\t} else if (sc.isNext(Tokenizer::isDigit)) {\n\t\t\t\t\tparseInt();\n\t\t\t\t} else if (sc.isNext(Tokenizer::isSymbol)) {\n\t\t\t\t\tparseSym();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new RuntimeException(\"invalid character: \" + sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void parseId() {\n\t\t\tString s = sc.read().toString();\n\t\t\twhile (sc.isNext(Tokenizer::isAlpha) || sc.isNext(Tokenizer::isDigit))\n\t\t\t\ts += sc.read().toString();\n\t\t\tts.add(Token.ofId(s));\n\t\t}\n\n\t\tprivate void parseInt() {\n\t\t\tString s = sc.read().toString();\n\t\t\twhile (sc.isNext(Tokenizer::isDigit))\n\t\t\t\ts += sc.read().toString();\n\t\t\tts.add(Token.ofInt(s));\n\t\t}\n\n\t\tprivate void parseSym() {\n\t\t\tString s = sc.read().toString();\n\t\t\tts.add(Token.ofSym(s));\n\t\t}\n\t}\n\n\tprivate static class Parser {\n\t\tSeq<Token> ts;\n\n\t\tParser(Seq<Token> ts) {\n\t\t\tthis.ts = ts;\n\t\t}\n\n\t\tAST parse() {\n\t\t\treturn parseExpr();\n\t\t}\n\n\t\tprivate AST parseExpr() {\n\t\t\treturn parseMultiExpr();\n\t\t}\n\n\t\tprivate AST parseMultiExpr() {\n\t\t\treadSemicolons();\n\t\t\tAST a = parseAssignExpr();\n\t\t\tif (readSemicolons()) {\n\t\t\t\tArrayList<AST> as = new ArrayList<AST>();\n\t\t\t\tas.add(a);\n\t\t\t\tdo {\n\t\t\t\t\tif (!ts.hasNext())\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tas.add(parseAssignExpr());\n\t\t\t\t} while (readSemicolons());\n\t\t\t\tif (as.size() == 1)\n\t\t\t\t\treturn a;\n\t\t\t\treturn new AST.Multi(as);\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate boolean readSemicolons() {\n\t\t\tif (!ts.isNext(t -> t.is(\";\")))\n\t\t\t\treturn false;\n\t\t\tdo {\n\t\t\t\tts.read();\n\t\t\t} while (ts.isNext(t -> t.is(\";\")));\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate AST parseAssignExpr() {\n\t\t\tAST a = parseAddSubOp();\n\t\t\tif (ts.isNext(t -> t.is(\"=\"))) {\n\t\t\t\tts.read();\n\t\t\t\tif (!(a instanceof AST.Id))\n\t\t\t\t\tthrow new RuntimeException(\"cannot assign to \" + a);\n\t\t\t\treturn new AST.AssignOp(((AST.Id) a).s, parseAssignExpr());\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate AST parseAddSubOp() {\n\t\t\tAST a = parseMulDivModOp();\n\t\t\twhile (ts.isNext(t -> t.is(\"+\") || t.is(\"-\")))\n\t\t\t\ta = new AST.BinOp(a, ts.read().a, parseMulDivModOp());\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate AST parseMulDivModOp() {\n\t\t\tAST a = parsePowOp();\n\t\t\twhile (ts.isNext(t -> t.is(\"*\") || t.is(\"/\") || t.is(\"%\")))\n\t\t\t\ta = new AST.BinOp(a, ts.read().a, parsePowOp());\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate AST parsePowOp() {\n\t\t\tAST a = parseNegateOp();\n\t\t\tif (ts.isNext(t -> t.is(\"^\")))\n\t\t\t\treturn new AST.BinOp(a, ts.read().a, parsePowOp());\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate AST parseNegateOp() {\n\t\t\tif (ts.isNext(t -> t.is(\"-\")))\n\t\t\t\treturn new AST.UnOp(ts.read().a, parseNegateOp());\n\t\t\treturn parseFactOp();\n\t\t}\n\n\t\tprivate AST parseFactOp() {\n\t\t\tAST a = parsePrimary();\n\t\t\twhile (ts.isNext(t -> t.is(\"!\")))\n\t\t\t\ta = new AST.UnOp(ts.read().a, a);\n\t\t\treturn a;\n\t\t}\n\n\t\tprivate AST parsePrimary() {\n\t\t\tif (ts.isNext(t -> t.isId()))\n\t\t\t\treturn new AST.Id(ts.read().a);\n\t\t\tif (ts.isNext(t -> t.isInt()))\n\t\t\t\treturn new AST.Int(Long.parseLong(ts.read().a));\n\t\t\tif (ts.readIf(t -> t.is(\"(\")) != null) {\n\t\t\t\tAST e = parseExpr();\n\t\t\t\tts.read(t -> t.is(\")\"));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"unexpected token: \" + ts.next());\n\t\t}\n\t}\n\n\tstatic HashMap<String, AST> cache = new HashMap<String, AST>();\n\n\tstatic <A> Evaluator<A> makeEvaluator(F.XXX<String, A, A> assign, F.XXX<A, A, A> add, F.XXX<A, A, A> sub,\n\t\t\tF.XXX<A, A, A> mul, F.XXX<A, A, A> div, F.XXX<A, A, A> mod, F.XXX<A, A, A> pow, F.XX<A, A> neg,\n\t\t\tF.XX<A, A> fact, F.LX<A> fromInt, F.XX<String, A> id) {\n\t\treturn new Evaluator<A>() {\n\t\t\tpublic A assign(String s, A a) {\n\t\t\t\treturn assign.f(s, a);\n\t\t\t}\n\n\t\t\tpublic A binOp(String op, A a, A b) {\n\t\t\t\tswitch (op) {\n\t\t\t\tcase \"+\":\n\t\t\t\t\treturn add.f(a, b);\n\t\t\t\tcase \"-\":\n\t\t\t\t\treturn sub.f(a, b);\n\t\t\t\tcase \"*\":\n\t\t\t\t\treturn mul.f(a, b);\n\t\t\t\tcase \"/\":\n\t\t\t\t\treturn div.f(a, b);\n\t\t\t\tcase \"%\":\n\t\t\t\t\treturn mod.f(a, b);\n\t\t\t\tcase \"^\":\n\t\t\t\t\treturn pow.f(a, b);\n\t\t\t\t}\n\t\t\t\tthrow new RuntimeException(\"invalid binOp: \" + op);\n\t\t\t}\n\n\t\t\tpublic A unOp(String op, A a) {\n\t\t\t\tswitch (op) {\n\t\t\t\tcase \"-\":\n\t\t\t\t\treturn neg.f(a);\n\t\t\t\tcase \"!\":\n\t\t\t\t\treturn fact.f(a);\n\t\t\t\t}\n\t\t\t\tthrow new RuntimeException(\"invalid unOp: \" + op);\n\t\t\t}\n\n\t\t\tpublic A fromInt(long a) {\n\t\t\t\treturn fromInt.f(a);\n\t\t\t}\n\n\t\t\tpublic A id(String s) {\n\t\t\t\treturn id.f(s);\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic AST parse(String s) {\n\t\tif (cache.containsKey(cache)) {\n\t\t\treturn cache.get(s);\n\t\t}\n\t\tTokenizer l = new Tokenizer(s);\n\t\tSeq<Token> ts = l.parse();\n\t\tParser p = new Parser(ts);\n\t\tAST a = p.parse();\n\t\tcache.put(s, a);\n\t\treturn a;\n\t}\n}\n\nclass Mod {\n\tfinal long mod;\n\tfinal AbelianGroup<Long> add;\n\tfinal AbelianGroup<Long> mul;\n\tfinal Field<Long> field;\n\tfinal VM<Long> vm;\n\tprivate final boolean prime;\n\tprivate final HashMap<Long, Integer> logMap;\n\tprivate long[] facts;\n\tprivate long[] invs;\n\tprivate long[] invFacts;\n\tprivate long[] factors;\n\n\tMod(long mod) {\n\t\tthis.mod = mod;\n\t\tprepareFacts(0);\n\t\tprime = BigInteger.valueOf(mod).isProbablePrime(100);\n\t\tadd = AbelianGroup.make((a, b) -> (a + b) % mod, a -> mod - a, 0l);\n\t\tmul = AbelianGroup.make((a, b) -> (a * b) % mod, a -> {\n\t\t\tif (prime)\n\t\t\t\treturn pow(a, mod - 2);\n\t\t\tTL t = Alg.extgcd(a, mod);\n\t\t\tif (t.c != 1)\n\t\t\t\tthrow new ArithmeticException(\"inv(\" + a + \") does not exist\");\n\t\t\treturn (t.a % mod + mod) % mod;\n\t\t}, 1l);\n\t\tfield = Field.make(add, mul);\n\t\tlogMap = new HashMap<Long, Integer>();\n\t\tvm = new VM<Long>(field, this::pow, this::fact, a -> (a % mod + mod) % mod, a -> (a % mod + mod) % mod);\n\t}\n\n\tlong fact(long a) {\n\t\tif (a >= Integer.MAX_VALUE)\n\t\t\tthrow new RuntimeException(\"fact(\" + a + \") too big\");\n\t\tprepareFacts((int) a);\n\t\treturn facts[(int) (a % mod)];\n\t}\n\n\tlong invFact(int a) {\n\t\tprepareFacts(a);\n\t\treturn invFacts[(int) (a % mod)];\n\t}\n\n\tlong inv(long a) {\n\t\treturn mul.inv(a);\n\t}\n\n\tlong pow(long a, long b) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif (b == 1)\n\t\t\treturn a;\n\t\tif (b < 0) {\n\t\t\ta = inv(a);\n\t\t\tb = -b;\n\t\t}\n\t\ta %= mod;\n\t\tlong res = 1;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) != 0)\n\t\t\t\tres = res * a % mod;\n\t\t\ta = a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tlong order(long a) { // computes the order of `a` in O(sqrt(mod)) time\n\t\ta %= mod;\n\t\tif (a == 0)\n\t\t\treturn 0;\n\t\tif (a == 1)\n\t\t\treturn 1;\n\t\tif (factors == null) {\n\t\t\tArrayList<Long> fs = new ArrayList<Long>();\n\t\t\tfor (long i = 2; i * i < mod; i++) {\n\t\t\t\tif ((mod - 1) % i == 0)\n\t\t\t\t\tfs.add(i);\n\t\t\t}\n\t\t\tfactors = new long[fs.size()];\n\t\t\tfor (int i = 0; i < fs.size(); i++) {\n\t\t\t\tfactors[i] = fs.get(i);\n\t\t\t}\n\t\t}\n\t\tfor (long f : factors) {\n\t\t\tif (pow(a, f) == 1)\n\t\t\t\treturn f;\n\t\t}\n\t\treturn mod - 1;\n\t}\n\n\tPL log(long a, long b) { // log_b(a) in O(sqrt(mod)) time\n\t\ta %= mod;\n\t\tb %= mod;\n\t\tif (b == 1 || b == 0)\n\t\t\treturn a == b ? PL.make(1, 1) : PL.make(-1, 0);\n\t\tif (a == 0)\n\t\t\treturn PL.make(-1, 0);\n\t\tlong order = order(b);\n\t\tif (a == 1)\n\t\t\treturn PL.make(0, order);\n\t\tlong orderSqrtL = sqrtCeil(order);\n\t\tif (orderSqrtL > Integer.MAX_VALUE)\n\t\t\tthrow new RuntimeException(\"order(\" + b + \") too big: \" + order);\n\t\tint orderSqrt = (int) sqrtCeil(order);\n\t\tlogMap.clear();\n\t\tlogMap.put(1l, 0);\n\t\tlong p = 1;\n\t\tfor (int i = 1; i < orderSqrt; i++) {\n\t\t\tp = p * b % mod;\n\t\t\tlogMap.put(p, i);\n\t\t}\n\t\tlong ib = pow(b, mod - orderSqrt - 1);\n\t\tp = a;\n\t\tfor (int i = 1; i < orderSqrt; i++) {\n\t\t\tp = p * ib % mod;\n\t\t\tif (logMap.containsKey(p))\n\t\t\t\treturn PL.make((i * orderSqrt + logMap.get(p)) % order, order);\n\t\t}\n\t\treturn PL.make(-1, 0);\n\t}\n\n\tprivate long sqrtCeil(long a) {\n\t\treturn U.searchL((long) Math.sqrt(a * 0.9), (long) Math.sqrt(a * 1.1) + 1, mid -> mid * mid >= a);\n\t}\n\n\tprivate void prepareFacts(int n) {\n\t\tif (facts == null) {\n\t\t\tfacts = new long[1024];\n\t\t\tinvs = new long[1024];\n\t\t\tinvFacts = new long[1024];\n\t\t\tprepareFactsIn(0, 1024);\n\t\t}\n\t\tif (n >= mod)\n\t\t\tn = (int) (mod - 1);\n\t\twhile (facts.length <= n) {\n\t\t\tint prevL = facts.length;\n\t\t\tint newL = prevL << 1;\n\t\t\tfacts = Arrays.copyOf(facts, newL);\n\t\t\tinvs = Arrays.copyOf(invs, newL);\n\t\t\tinvFacts = Arrays.copyOf(invFacts, newL);\n\t\t\tprepareFactsIn(prevL, newL);\n\t\t}\n\t}\n\n\tprivate void prepareFactsIn(int from, int until) {\n\t\tif (until > mod)\n\t\t\tuntil = (int) mod;\n\t\tfor (int i = from; i < until; i++) {\n\t\t\tif (i == 0) {\n\t\t\t\tfacts[0] = 1;\n\t\t\t\tinvs[0] = 0;\n\t\t\t\tinvFacts[0] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 1) {\n\t\t\t\tfacts[1] = 1;\n\t\t\t\tinvs[1] = 1;\n\t\t\t\tinvFacts[1] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfacts[i] = facts[i - 1] * i % mod;\n\t\t\tinvs[i] = (mod - mod / i) * invs[(int) (mod % i)] % mod;\n\t\t\tinvFacts[i] = invFacts[i - 1] * invs[i] % mod;\n\t\t}\n\t}\n}\nGicen the following input:\n5 3\nPrint only the output of the code, ends with \"END-OF-OUTPUT\":",
        "status": "NAN",
        "gorund_truth": "3\n6\n1\n"
    }
}