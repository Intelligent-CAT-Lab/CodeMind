1 import java.io.IOException;
2 import java.io.InputStream;
3 import java.io.PrintWriter;
4 import java.lang.reflect.Array;
5 import java.math.BigDecimal;
6 import java.math.BigInteger;
7 import java.util.ArrayList;
8 import java.util.Arrays;
9 import java.util.HashMap;
10 import java.util.NoSuchElementException;
11 import java.util.TreeMap;
12 import java.util.TreeSet;
13 
14 public class Main {
15 	private static void solve() {
16 		long n = ni();
17 		long k = ni();
18 		final long M = 1000000007l;
19 		Mod m = new Mod(M);
20 		for (int i = 1; i <= k; i++) {
21 			long bl = modFact(m, k - 1, k - i);
22 			long re = modFact(m, n - k + 1, n - k - i + 1);
23 			out(bl * re % M);
24 		}
25 	}
26 
27 	static long modFact(Mod m, long n, long k) {
28 		if (k < 0)
29 			return 0;
30 		if (k > n)
31 			return 0;
32 		if (n == k)
33 			return 1;
34 		m.vm.set("n", n);
35 		m.vm.set("k", k);
36 		return m.vm.run("n!/(n-k)!/k!");
37 	}
38 
39 	static int min(int a, int b) {
40 		return a < b ? a : b;
41 	}
42 
43 	static long min(long a, long b) {
44 		return a < b ? a : b;
45 	}
46 
47 	static <A extends Comparable<? super A>> A min(A a, A b) {
48 		return a.compareTo(b) < 0 ? a : b;
49 	}
50 
51 	static int max(int a, int b) {
52 		return a > b ? a : b;
53 	}
54 
55 	static long max(long a, long b) {
56 		return a > b ? a : b;
57 	}
58 
59 	static <A extends Comparable<? super A>> A max(A a, A b) {
60 		return a.compareTo(b) > 0 ? a : b;
61 	}
62 
63 	static int clamp(int a, int min, int max) {
64 		return a < min ? min : a > max ? max : a;
65 	}
66 
67 	static long clamp(long a, long min, long max) {
68 		return a < min ? min : a > max ? max : a;
69 	}
70 
71 	static int abs(int a) {
72 		return a < 0 ? -a : a;
73 	}
74 
75 	static long abs(long a) {
76 		return a < 0 ? -a : a;
77 	}
78 
79 	static <A extends Comparable<? super A>> A clamp(A a, A min, A max) {
80 		return a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;
81 	}
82 
83 	static void out(String val) {
84 		IO.out(val);
85 	}
86 
87 	static void out(Object val) {
88 		IO.out(String.valueOf(val));
89 	}
90 
91 	static void out(int val) {
92 		IO.out(String.valueOf(val));
93 	}
94 
95 	static void out(long val) {
96 		IO.out(String.valueOf(val));
97 	}
98 
99 	static void out(char val) {
100 		IO.out(String.valueOf(val));
101 	}
102 
103 	static void out(double val) {
104 		IO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));
105 	}
106 
107 	static void out(boolean val) {
108 		IO.out(val ? "true" : "false");
109 	}
110 
111 	static void kil(String val) {
112 		IO.out(val);
113 		IO.flush();
114 		System.exit(0);
115 	}
116 
117 	static void kil(Object val) {
118 		IO.out(String.valueOf(val));
119 		IO.flush();
120 		System.exit(0);
121 	}
122 
123 	static void kil(int val) {
124 		IO.out(String.valueOf(val));
125 		IO.flush();
126 		System.exit(0);
127 	}
128 
129 	static void kil(long val) {
130 		IO.out(String.valueOf(val));
131 		IO.flush();
132 		System.exit(0);
133 	}
134 
135 	static void kil(char val) {
136 		IO.out(String.valueOf(val));
137 		IO.flush();
138 		System.exit(0);
139 	}
140 
141 	static void kil(double val) {
142 		IO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));
143 		IO.flush();
144 		System.exit(0);
145 	}
146 
147 	static void kil(boolean val) {
148 		IO.out(val ? "true" : "false");
149 		IO.flush();
150 		System.exit(0);
151 	}
152 
153 	static String ns() {
154 		return IO.next();
155 	}
156 
157 	static int ni() {
158 		return IO.nextInt();
159 	}
160 
161 	static long nl() {
162 		return IO.nextLong();
163 	}
164 
165 	static double nd() {
166 		return IO.nextDouble();
167 	}
168 
169 	static char nc() {
170 		return IO.nextChar();
171 	}
172 
173 	static String[] nss(int n) {
174 		String[] as = new String[n];
175 		for (int i = 0; i < n; i++) {
176 			as[i] = IO.next();
177 		}
178 		return as;
179 	}
180 
181 	static int[] nis(int n) {
182 		int[] as = new int[n];
183 		for (int i = 0; i < n; i++) {
184 			as[i] = IO.nextInt();
185 		}
186 		return as;
187 	}
188 
189 	static long[] nls(int n) {
190 		long[] as = new long[n];
191 		for (int i = 0; i < n; i++) {
192 			as[i] = IO.nextLong();
193 		}
194 		return as;
195 	}
196 
197 	static double[] nds(int n) {
198 		double[] as = new double[n];
199 		for (int i = 0; i < n; i++) {
200 			as[i] = IO.nextDouble();
201 		}
202 		return as;
203 	}
204 
205 	static char[] ncs(int n) {
206 		char[] as = new char[n];
207 		for (int i = 0; i < n; i++) {
208 			as[i] = IO.nextChar();
209 		}
210 		return as;
211 	}
212 
213 	static String[][] nss2(int n, int m) {
214 		String[][] as = new String[n][m];
215 		for (int i = 0; i < n; i++) {
216 			for (int j = 0; j < m; j++) {
217 				as[i][j] = IO.next();
218 			}
219 		}
220 		return as;
221 	}
222 
223 	static int[][] nis2(int n, int m) {
224 		int[][] as = new int[n][m];
225 		for (int i = 0; i < n; i++) {
226 			for (int j = 0; j < m; j++) {
227 				as[i][j] = IO.nextInt();
228 			}
229 		}
230 		return as;
231 	}
232 
233 	static long[][] nls2(int n, int m) {
234 		long[][] as = new long[n][m];
235 		for (int i = 0; i < n; i++) {
236 			for (int j = 0; j < m; j++) {
237 				as[i][j] = IO.nextLong();
238 			}
239 		}
240 		return as;
241 	}
242 
243 	static double[][] nds2(int n, int m) {
244 		double[][] as = new double[n][m];
245 		for (int i = 0; i < n; i++) {
246 			for (int j = 0; j < m; j++) {
247 				as[i][j] = IO.nextDouble();
248 			}
249 		}
250 		return as;
251 	}
252 
253 	static char[][] ncs2(int n, int m) {
254 		char[][] as = new char[n][m];
255 		for (int i = 0; i < n; i++) {
256 			for (int j = 0; j < m; j++) {
257 				as[i][j] = IO.nextChar();
258 			}
259 		}
260 		return as;
261 	}
262 
263 	static int parseInt(String val) {
264 		return Integer.parseInt(val);
265 	}
266 
267 	static long parseLong(String val) {
268 		return Long.parseLong(val);
269 	}
270 
271 	public static void main(String[] args) {
272 		try {
273 			solve();
274 			IO.flush();
275 		} catch (NumberFormatException e) {
276 			e.printStackTrace();
277 		} catch (OutOfMemoryError e) {
278 			e.printStackTrace(); // this will be detected as RE
279 		}
280 	}
281 }
282 
283 final class IO {
284 	private static final InputStream in = System.in;
285 	private static final PrintWriter out = new PrintWriter(System.out, false);
286 	private static final byte[] buffer = new byte[1024];
287 	private static int ptr = 0;
288 	private static int len = 0;
289 
290 	private static boolean hasNextByte() {
291 		if (ptr < len)
292 			return true;
293 		ptr = 0;
294 		try {
295 			len = in.read(buffer);
296 		} catch (IOException e) {
297 			e.printStackTrace();
298 		}
299 		return len > 0;
300 	}
301 
302 	private static int readByte() {
303 		if (hasNextByte())
304 			return buffer[ptr++];
305 		else
306 			return -1;
307 	}
308 
309 	static boolean hasNext() {
310 		byte c;
311 		while (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))
312 			ptr++;
313 		return hasNextByte();
314 	}
315 
316 	static String next() {
317 		if (!hasNext())
318 			throw new NoSuchElementException();
319 		StringBuilder sb = new StringBuilder();
320 		int b = readByte();
321 		while (b >= '!' && b <= '~') {
322 			sb.append((char) b);
323 			b = readByte();
324 		}
325 		return sb.toString();
326 	}
327 
328 	static char nextChar() {
329 		if (!hasNext())
330 			throw new NoSuchElementException();
331 		return (char) readByte();
332 	}
333 
334 	static long nextLong() {
335 		if (!hasNext())
336 			throw new NoSuchElementException();
337 		long n = 0;
338 		int sign = 1;
339 		int b = readByte();
340 		if (b == '-') {
341 			sign = -1;
342 			b = readByte();
343 		}
344 		if (b < '0' || '9' < b)
345 			throw new NumberFormatException();
346 		while (true) {
347 			if ('0' <= b && b <= '9')
348 				n = n * 10 + b - '0';
349 			else if (b == -1 || b < '!' || b > '~')
350 				return n * sign;
351 			else
352 				throw new NumberFormatException();
353 			b = readByte();
354 		}
355 	}
356 
357 	static int nextInt() {
358 		if (!hasNext())
359 			throw new NoSuchElementException();
360 		int n = 0;
361 		int sign = 1;
362 		int b = readByte();
363 		if (b == '-') {
364 			sign = -1;
365 			b = readByte();
366 		}
367 		if (b < '0' || '9' < b)
368 			throw new NumberFormatException();
369 		while (true) {
370 			if ('0' <= b && b <= '9')
371 				n = n * 10 + b - '0';
372 			else if (b == -1 || b < '!' || b > '~')
373 				return n * sign;
374 			else
375 				throw new NumberFormatException();
376 			b = readByte();
377 		}
378 	}
379 
380 	static double nextDouble() {
381 		return Double.parseDouble(next());
382 	}
383 
384 	static void out(String val) {
385 		out.println(val);
386 	}
387 
388 	static void flush() {
389 		out.flush();
390 	}
391 }
392 
393 // TODO: paste library here
394 
395 class UP<A, B> { // Unordered Pair
396 	A a;
397 	B b;
398 
399 	UP(A a, B b) {
400 		this.a = a;
401 		this.b = b;
402 	}
403 
404 	static <A, B> UP<A, B> make(A a, B b) {
405 		return new UP<A, B>(a, b);
406 	}
407 
408 	public boolean equals(Object o) {
409 		if (o == this)
410 			return true;
411 		if (!(o instanceof UP))
412 			return false;
413 		UP<?, ?> p = (UP<?, ?>) o;
414 		boolean aok = a == null ? p.a == null : a.equals(p.a);
415 		boolean bok = b == null ? p.b == null : b.equals(p.b);
416 		return aok && bok;
417 	}
418 
419 	public String toString() {
420 		return "(" + a.toString() + ", " + b.toString() + ")";
421 	}
422 }
423 
424 class P<A extends Comparable<? super A>, B extends Comparable<? super B>> extends UP<A, B> implements
425 		Comparable<P<A, B>> { // Pair
426 	P(A a, B b) {
427 		super(a, b);
428 	}
429 
430 	static <A extends Comparable<? super A>, B extends Comparable<? super B>> P<A, B> make(A a, B b) {
431 		return new P<A, B>(a, b);
432 	}
433 
434 	public int compareTo(P<A, B> o) {
435 		int sa = a.compareTo(o.a);
436 		int sb = b.compareTo(o.b);
437 		return sa != 0 ? sa : sb;
438 	}
439 }
440 
441 class PI implements Comparable<PI> { // Pair int
442 	int a;
443 	int b;
444 
445 	PI(int a, int b) {
446 		this.a = a;
447 		this.b = b;
448 	}
449 
450 	static PI make(int a, int b) {
451 		return new PI(a, b);
452 	}
453 
454 	public boolean equals(Object o) {
455 		if (o == this)
456 			return true;
457 		if (!(o instanceof PI))
458 			return false;
459 		PI p = (PI) o;
460 		return a == p.a && b == p.b;
461 	}
462 
463 	public int compareTo(PI o) {
464 		int sa = a - o.a;
465 		int sb = b - o.b;
466 		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : 0;
467 	}
468 
469 	public String toString() {
470 		return "(" + a + ", " + b + ")";
471 	}
472 }
473 
474 class PL implements Comparable<PL> { // Pair long
475 	long a;
476 	long b;
477 
478 	PL(long a, long b) {
479 		this.a = a;
480 		this.b = b;
481 	}
482 
483 	static PL make(long a, long b) {
484 		return new PL(a, b);
485 	}
486 
487 	public boolean equals(Object o) {
488 		if (o == this)
489 			return true;
490 		if (!(o instanceof PL))
491 			return false;
492 		PL p = (PL) o;
493 		return a == p.a && b == p.b;
494 	}
495 
496 	public int compareTo(PL o) {
497 		long sa = a - o.a;
498 		long sb = b - o.b;
499 		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : 0;
500 	}
501 
502 	public String toString() {
503 		return "(" + a + ", " + b + ")";
504 	}
505 }
506 
507 class UT<A, B, C> { // Unordered Tuple
508 	A a;
509 	B b;
510 	C c;
511 
512 	UT(A a, B b, C c) {
513 		this.a = a;
514 		this.b = b;
515 		this.c = c;
516 	}
517 
518 	static <A, B, C> UT<A, B, C> make(A a, B b, C c) {
519 		return new UT<A, B, C>(a, b, c);
520 	}
521 
522 	public boolean equals(Object o) {
523 		if (o == this)
524 			return true;
525 		if (!(o instanceof UT))
526 			return false;
527 		UT<?, ?, ?> t = (UT<?, ?, ?>) o;
528 		boolean aok = a == null ? t.a == null : a.equals(t.a);
529 		boolean bok = b == null ? t.b == null : b.equals(t.b);
530 		boolean cok = c == null ? t.c == null : c.equals(t.c);
531 		return aok && bok && cok;
532 	}
533 
534 	public String toString() {
535 		return "(" + a.toString() + ", " + b.toString() + ", " + c.toString() + ")";
536 	}
537 }
538 
539 class T<A extends Comparable<? super A>, B extends Comparable<? super B>, C extends Comparable<? super C>> extends
540 		UT<A, B, C> implements Comparable<T<A, B, C>> { // Tuple
541 	T(A a, B b, C c) {
542 		super(a, b, c);
543 	}
544 
545 	static <A extends Comparable<? super A>, B extends Comparable<? super B>, C extends Comparable<? super C>> T<A, B, C> make(
546 			A a, B b, C c) {
547 		return new T<A, B, C>(a, b, c);
548 	}
549 
550 	public int compareTo(T<A, B, C> o) {
551 		int sa = a.compareTo(o.a);
552 		int sb = b.compareTo(o.b);
553 		int sc = c.compareTo(o.c);
554 		return sa != 0 ? sa : sb != 0 ? sb : sc;
555 	}
556 }
557 
558 class TI implements Comparable<TI> { // Tuple int
559 	int a;
560 	int b;
561 	int c;
562 
563 	TI(int a, int b, int c) {
564 		this.a = a;
565 		this.b = b;
566 		this.c = c;
567 	}
568 
569 	static TI make(int a, int b, int c) {
570 		return new TI(a, b, c);
571 	}
572 
573 	TL toLong() {
574 		return TL.make(a, b, c);
575 	}
576 
577 	public boolean equals(Object o) {
578 		if (o == this)
579 			return true;
580 		if (!(o instanceof TI))
581 			return false;
582 		TI t = (TI) o;
583 		return a == t.a && b == t.b && c == t.c;
584 	}
585 
586 	public int compareTo(TI o) {
587 		int sa = a - o.a;
588 		int sb = b - o.b;
589 		int sc = c - o.c;
590 		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : sc > 0 ? 1 : sc < 0 ? -1 : 0;
591 	}
592 
593 	public String toString() {
594 		return "(" + a + ", " + b + ", " + c + ")";
595 	}
596 }
597 
598 class TL implements Comparable<TL> { // Tuple long
599 	long a;
600 	long b;
601 	long c;
602 
603 	TL(long a, long b, long c) {
604 		this.a = a;
605 		this.b = b;
606 		this.c = c;
607 	}
608 
609 	static TL make(long a, long b, long c) {
610 		return new TL(a, b, c);
611 	}
612 
613 	TI toInt() {
614 		return TI.make((int) a, (int) b, (int) c);
615 	}
616 
617 	public boolean equals(Object o) {
618 		if (o == this)
619 			return true;
620 		if (!(o instanceof TL))
621 			return false;
622 		TL t = (TL) o;
623 		return a == t.a && b == t.b && c == t.c;
624 	}
625 
626 	public int compareTo(TL o) {
627 		long sa = a - o.a;
628 		long sb = b - o.b;
629 		long sc = c - o.c;
630 		return sa > 0 ? 1 : sa < 0 ? -1 : sb > 0 ? 1 : sb < 0 ? -1 : sc > 0 ? 1 : sc < 0 ? -1 : 0;
631 	}
632 
633 	public String toString() {
634 		return "(" + a + ", " + b + ", " + c + ")";
635 	}
636 }
637 
638 final class U { // Utilities
639 	private U() {
640 	}
641 
642 	static <A> ArrayList<A> make(int n, F.IX<A> maker) {
643 		ArrayList<A> res = new ArrayList<A>();
644 		for (int i = 0; i < n; i++)
645 			res.add(maker.f(i));
646 		return res;
647 	}
648 
649 	static boolean[] makeB(int n, F.IB maker) {
650 		boolean[] res = new boolean[n];
651 		for (int i = 0; i < n; i++)
652 			res[i] = maker.f(i);
653 		return res;
654 	}
655 
656 	static int[] makeI(int n, F.II maker) {
657 		int[] res = new int[n];
658 		for (int i = 0; i < n; i++)
659 			res[i] = maker.f(i);
660 		return res;
661 	}
662 
663 	static long[] makeL(int n, F.IL maker) {
664 		long[] res = new long[n];
665 		for (int i = 0; i < n; i++)
666 			res[i] = maker.f(i);
667 		return res;
668 	}
669 
670 	static <A> A[] makeX(int n, F.IX<A> maker, A[] as) {
671 		A[] res = Arrays.copyOf(as, n);
672 		for (int i = 0; i < n; i++)
673 			res[i] = maker.f(i);
674 		return res;
675 	}
676 
677 	static <A> ArrayList<A> filter(ArrayList<A> as, F.XB<A> pred) {
678 		ArrayList<A> res = new ArrayList<A>();
679 		for (A a : as)
680 			if (pred.f(a))
681 				res.add(a);
682 		return res;
683 	}
684 
685 	static <A> int count(ArrayList<A> as, F.XB<A> pred) {
686 		int res = 0;
687 		for (A a : as)
688 			if (pred.f(a))
689 				res++;
690 		return res;
691 	}
692 
693 	static <A> ArrayList<A> concat(ArrayList<A> as, ArrayList<A> bs) {
694 		ArrayList<A> res = new ArrayList<A>();
695 		res.addAll(as);
696 		res.addAll(bs);
697 		return res;
698 	}
699 
700 	static <A> boolean any(ArrayList<A> as, F.XB<A> pred) {
701 		for (A a : as)
702 			if (pred.f(a))
703 				return true;
704 		return false;
705 	}
706 
707 	static <A> boolean all(ArrayList<A> as, F.XB<A> pred) {
708 		for (A a : as)
709 			if (!pred.f(a))
710 				return false;
711 		return true;
712 	}
713 
714 	static <A> ArrayList<A> flatten(ArrayList<ArrayList<A>> ass) {
715 		ArrayList<A> res = new ArrayList<A>();
716 		for (ArrayList<A> as : ass)
717 			res.addAll(as);
718 		return res;
719 	}
720 
721 	static <A, B> B foldl(ArrayList<A> as, F.XXX<B, A, B> f, B e) {
722 		B res = e;
723 		for (A a : as)
724 			res = f.f(res, a);
725 		return res;
726 	}
727 
728 	static <A, B> B foldr(ArrayList<A> as, F.XXX<A, B, B> f, B e) {
729 		B res = e;
730 		for (int i = as.size() - 1; i >= 0; i--)
731 			res = f.f(as.get(i), res);
732 		return res;
733 	}
734 
735 	static <A> ArrayList<A> reverse(ArrayList<A> as) {
736 		int size = as.size();
737 		return make(size, i -> as.get(size - 1 - i));
738 	}
739 
740 	static boolean[] reverse(boolean[] as) {
741 		int size = as.length;
742 		return makeB(size, i -> as[size - 1 - i]);
743 	}
744 
745 	static int[] reverse(int[] as) {
746 		int size = as.length;
747 		return makeI(size, i -> as[size - 1 - i]);
748 	}
749 
750 	static long[] reverse(long[] as) {
751 		int size = as.length;
752 		return makeL(size, i -> as[size - 1 - i]);
753 	}
754 
755 	static <A> A[] reverse(A[] as) {
756 		int size = as.length;
757 		return makeX(size, i -> as[size - 1 - i], as);
758 	}
759 
760 	static <A extends Comparable<? super A>> UP<TreeMap<A, Integer>, ArrayList<A>> compress(ArrayList<A> as) {
761 		TreeSet<A> set = new TreeSet<A>(as);
762 		TreeMap<A, Integer> map = new TreeMap<A, Integer>();
763 		ArrayList<A> imap = new ArrayList<A>();
764 		int i = 0;
765 		for (A a : set) {
766 			map.put(a, i++);
767 			imap.add(a);
768 		}
769 		return UP.make(map, imap);
770 	}
771 
772 	static <A, B> ArrayList<B> map(ArrayList<A> as, F.XX<A, B> f) {
773 		return make(as.size(), (i) -> f.f(as.get(i)));
774 	}
775 
776 	static <A, B> ArrayList<B> mapi(ArrayList<A> as, F.XIX<A, B> f) {
777 		return make(as.size(), (i) -> f.f(as.get(i), i));
778 	}
779 
780 	static <A, B> ArrayList<UP<A, B>> zip(ArrayList<A> as, ArrayList<B> bs) {
781 		return make(min(as.size(), bs.size()), (i) -> UP.make(as.get(i), bs.get(i)));
782 	}
783 
784 	static int min(int a, int b) {
785 		return a < b ? a : b;
786 	}
787 
788 	static long min(long a, long b) {
789 		return a < b ? a : b;
790 	}
791 
792 	static <A extends Comparable<? super A>> A min(A a, A b) {
793 		return a.compareTo(b) < 0 ? a : b;
794 	}
795 
796 	static int max(int a, int b) {
797 		return a > b ? a : b;
798 	}
799 
800 	static long max(long a, long b) {
801 		return a > b ? a : b;
802 	}
803 
804 	static <A extends Comparable<? super A>> A max(A a, A b) {
805 		return a.compareTo(b) > 0 ? a : b;
806 	}
807 
808 	static int clamp(int a, int min, int max) {
809 		return a < min ? min : a > max ? max : a;
810 	}
811 
812 	static long clamp(long a, long min, long max) {
813 		return a < min ? min : a > max ? max : a;
814 	}
815 
816 	static <A extends Comparable<? super A>> A clamp(A a, A min, A max) {
817 		return a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;
818 	}
819 
820 	static int abs(int a) {
821 		return a < 0 ? -a : a;
822 	}
823 
824 	static long abs(long a) {
825 		return a < 0 ? -a : a;
826 	}
827 
828 	static void forEachBitPerm(int n, int k, F.IV f) {
829 		for (int i = (1 << k) - 1; i < 1 << n;) {
830 			f.f(i);
831 			int t = (i | i - 1) + 1;
832 			i = t | ((t & -t) / (i & -i) >> 1) - 1;
833 		}
834 	}
835 
836 	static int nextBitPerm(int a) {
837 		int t = (a | a - 1) + 1;
838 		return t | ((t & -t) / (a & -a) >> 1) - 1;
839 	}
840 
841 	static void mebius(int n, F.IIV f) { // s, i
842 		int bit = 1;
843 		int exp = 0;
844 		for (int i = 1; i < 1 << n; i++) {
845 			f.f(i ^ bit, exp);
846 			if ((i & i + 1) == 0) {
847 				bit <<= 1;
848 				exp++;
849 			}
850 		}
851 	}
852 
853 	static void zeta(int n, F.IIV f) { // s, i
854 		int m = (1 << n) - 1;
855 		int bit = 1;
856 		int exp = 0;
857 		for (int i = (1 << n) - 2; i >= 0; i--) {
858 			f.f(i ^ bit, exp);
859 			if ((~i & ~i + 1 & m) == 0) {
860 				bit <<= 1;
861 				exp++;
862 			}
863 		}
864 	}
865 
866 	static <A> ArrayList<A> toAL(A[] as) {
867 		return make(as.length, i -> as[i]);
868 	}
869 
870 	static <A> A[] doubleSize(A[] as) {
871 		return Arrays.copyOf(as, as.length << 1);
872 	}
873 
874 	static long searchL(long ng, long ok, F.LB isOk) {
875 		while (ng - ok > 1 || ok - ng > 1) {
876 			long mid = ng + ok >> 1;
877 			if (isOk.f(mid))
878 				ok = mid;
879 			else
880 				ng = mid;
881 		}
882 		return ok;
883 	}
884 
885 	static int searchI(int ng, int ok, F.IB isOk) {
886 		return (int) searchL((long) ng, (long) ok, (mid) -> isOk.f((int) mid));
887 	}
888 }
889 
890 final class F { // Functions
891 	private F() {
892 	}
893 
894 	interface VV {
895 		void f();
896 	}
897 
898 	interface BV {
899 		void f(boolean a);
900 	}
901 
902 	interface BXV<A> {
903 		void f(boolean a, A b);
904 	}
905 
906 	interface BXXV<A, B> {
907 		void f(boolean a, A b, B c);
908 	}
909 
910 	interface BXXXV<A, B, C> {
911 		void f(boolean a, A b, B c, C d);
912 	}
913 
914 	interface XBV<A> {
915 		void f(A a, boolean b);
916 	}
917 
918 	interface XXBV<A, B> {
919 		void f(A a, B b, boolean c);
920 	}
921 
922 	interface XXXBV<A, B, C> {
923 		void f(A a, B b, C c, boolean d);
924 	}
925 
926 	interface IV {
927 		void f(int a);
928 	}
929 
930 	interface IXV<A> {
931 		void f(int a, A b);
932 	}
933 
934 	interface IXXV<A, B> {
935 		void f(int a, A b, B c);
936 	}
937 
938 	interface IXXXV<A, B, C> {
939 		void f(int a, A b, B c, C d);
940 	}
941 
942 	interface XIV<A> {
943 		void f(A a, int b);
944 	}
945 
946 	interface XXIV<A, B> {
947 		void f(A a, B b, int c);
948 	}
949 
950 	interface XXXIV<A, B, C> {
951 		void f(A a, B b, C c, int d);
952 	}
953 
954 	interface LV {
955 		void f(long a);
956 	}
957 
958 	interface LXV<A> {
959 		void f(long a, A b);
960 	}
961 
962 	interface LXXV<A, B> {
963 		void f(long a, A b, B c);
964 	}
965 
966 	interface LXXXV<A, B, C> {
967 		void f(long a, A b, B c, C d);
968 	}
969 
970 	interface XLV<A> {
971 		void f(A a, long b);
972 	}
973 
974 	interface XXLV<A, B> {
975 		void f(A a, B b, long c);
976 	}
977 
978 	interface XXXLV<A, B, C> {
979 		void f(A a, B b, C c, long d);
980 	}
981 
982 	interface DV {
983 		void f(double a);
984 	}
985 
986 	interface DXV<A> {
987 		void f(double a, A b);
988 	}
989 
990 	interface DXXV<A, B> {
991 		void f(double a, A b, B c);
992 	}
993 
994 	interface DXXXV<A, B, C> {
995 		void f(double a, A b, B c, C d);
996 	}
997 
998 	interface XDV<A> {
999 		void f(A a, double b);
1000 	}
1001 
1002 	interface XXDV<A, B> {
1003 		void f(A a, B b, double c);
1004 	}
1005 
1006 	interface XXXDV<A, B, C> {
1007 		void f(A a, B b, C c, double d);
1008 	}
1009 
1010 	interface XV<A> {
1011 		void f(A a);
1012 	}
1013 
1014 	interface XXV<A, B> {
1015 		void f(A a, B b);
1016 	}
1017 
1018 	interface XXXV<A, B, C> {
1019 		void f(A a, B b, C c);
1020 	}
1021 
1022 	interface XXXXV<A, B, C, D> {
1023 		void f(A a, B b, C c, D d);
1024 	}
1025 
1026 	interface BBV {
1027 		void f(boolean a, boolean b);
1028 	}
1029 
1030 	interface BIV {
1031 		void f(boolean a, int b);
1032 	}
1033 
1034 	interface BLV {
1035 		void f(boolean a, long b);
1036 	}
1037 
1038 	interface BDV {
1039 		void f(boolean a, double b);
1040 	}
1041 
1042 	interface IBV {
1043 		void f(int a, boolean b);
1044 	}
1045 
1046 	interface IIV {
1047 		void f(int a, int b);
1048 	}
1049 
1050 	interface ILV {
1051 		void f(int a, long b);
1052 	}
1053 
1054 	interface IDV {
1055 		void f(int a, double b);
1056 	}
1057 
1058 	interface LBV {
1059 		void f(long a, boolean b);
1060 	}
1061 
1062 	interface LIV {
1063 		void f(long a, int b);
1064 	}
1065 
1066 	interface LLV {
1067 		void f(long a, long b);
1068 	}
1069 
1070 	interface LDV {
1071 		void f(long a, double b);
1072 	}
1073 
1074 	interface DBV {
1075 		void f(double a, boolean b);
1076 	}
1077 
1078 	interface DIV {
1079 		void f(double a, int b);
1080 	}
1081 
1082 	interface DLV {
1083 		void f(double a, long b);
1084 	}
1085 
1086 	interface DDV {
1087 		void f(double a, double b);
1088 	}
1089 
1090 	interface VB {
1091 		boolean f();
1092 	}
1093 
1094 	interface BB {
1095 		boolean f(boolean a);
1096 	}
1097 
1098 	interface BXB<A> {
1099 		boolean f(boolean a, A b);
1100 	}
1101 
1102 	interface BXXB<A, B> {
1103 		boolean f(boolean a, A b, B c);
1104 	}
1105 
1106 	interface BXXXB<A, B, C> {
1107 		boolean f(boolean a, A b, B c, C d);
1108 	}
1109 
1110 	interface XBB<A> {
1111 		boolean f(A a, boolean b);
1112 	}
1113 
1114 	interface XXBB<A, B> {
1115 		boolean f(A a, B b, boolean c);
1116 	}
1117 
1118 	interface XXXBB<A, B, C> {
1119 		boolean f(A a, B b, C c, boolean d);
1120 	}
1121 
1122 	interface IB {
1123 		boolean f(int a);
1124 	}
1125 
1126 	interface IXB<A> {
1127 		boolean f(int a, A b);
1128 	}
1129 
1130 	interface IXXB<A, B> {
1131 		boolean f(int a, A b, B c);
1132 	}
1133 
1134 	interface IXXXB<A, B, C> {
1135 		boolean f(int a, A b, B c, C d);
1136 	}
1137 
1138 	interface XIB<A> {
1139 		boolean f(A a, int b);
1140 	}
1141 
1142 	interface XXIB<A, B> {
1143 		boolean f(A a, B b, int c);
1144 	}
1145 
1146 	interface XXXIB<A, B, C> {
1147 		boolean f(A a, B b, C c, int d);
1148 	}
1149 
1150 	interface LB {
1151 		boolean f(long a);
1152 	}
1153 
1154 	interface LXB<A> {
1155 		boolean f(long a, A b);
1156 	}
1157 
1158 	interface LXXB<A, B> {
1159 		boolean f(long a, A b, B c);
1160 	}
1161 
1162 	interface LXXXB<A, B, C> {
1163 		boolean f(long a, A b, B c, C d);
1164 	}
1165 
1166 	interface XLB<A> {
1167 		boolean f(A a, long b);
1168 	}
1169 
1170 	interface XXLB<A, B> {
1171 		boolean f(A a, B b, long c);
1172 	}
1173 
1174 	interface XXXLB<A, B, C> {
1175 		boolean f(A a, B b, C c, long d);
1176 	}
1177 
1178 	interface DB {
1179 		boolean f(double a);
1180 	}
1181 
1182 	interface DXB<A> {
1183 		boolean f(double a, A b);
1184 	}
1185 
1186 	interface DXXB<A, B> {
1187 		boolean f(double a, A b, B c);
1188 	}
1189 
1190 	interface DXXXB<A, B, C> {
1191 		boolean f(double a, A b, B c, C d);
1192 	}
1193 
1194 	interface XDB<A> {
1195 		boolean f(A a, double b);
1196 	}
1197 
1198 	interface XXDB<A, B> {
1199 		boolean f(A a, B b, double c);
1200 	}
1201 
1202 	interface XXXDB<A, B, C> {
1203 		boolean f(A a, B b, C c, double d);
1204 	}
1205 
1206 	interface XB<A> {
1207 		boolean f(A a);
1208 	}
1209 
1210 	interface XXB<A, B> {
1211 		boolean f(A a, B b);
1212 	}
1213 
1214 	interface XXXB<A, B, C> {
1215 		boolean f(A a, B b, C c);
1216 	}
1217 
1218 	interface XXXXB<A, B, C, D> {
1219 		boolean f(A a, B b, C c, D d);
1220 	}
1221 
1222 	interface BBB {
1223 		boolean f(boolean a, boolean b);
1224 	}
1225 
1226 	interface BIB {
1227 		boolean f(boolean a, int b);
1228 	}
1229 
1230 	interface BLB {
1231 		boolean f(boolean a, long b);
1232 	}
1233 
1234 	interface BDB {
1235 		boolean f(boolean a, double b);
1236 	}
1237 
1238 	interface IBB {
1239 		boolean f(int a, boolean b);
1240 	}
1241 
1242 	interface IIB {
1243 		boolean f(int a, int b);
1244 	}
1245 
1246 	interface ILB {
1247 		boolean f(int a, long b);
1248 	}
1249 
1250 	interface IDB {
1251 		boolean f(int a, double b);
1252 	}
1253 
1254 	interface LBB {
1255 		boolean f(long a, boolean b);
1256 	}
1257 
1258 	interface LIB {
1259 		boolean f(long a, int b);
1260 	}
1261 
1262 	interface LLB {
1263 		boolean f(long a, long b);
1264 	}
1265 
1266 	interface LDB {
1267 		boolean f(long a, double b);
1268 	}
1269 
1270 	interface DBB {
1271 		boolean f(double a, boolean b);
1272 	}
1273 
1274 	interface DIB {
1275 		boolean f(double a, int b);
1276 	}
1277 
1278 	interface DLB {
1279 		boolean f(double a, long b);
1280 	}
1281 
1282 	interface DDB {
1283 		boolean f(double a, double b);
1284 	}
1285 
1286 	interface VI {
1287 		int f();
1288 	}
1289 
1290 	interface BI {
1291 		int f(boolean a);
1292 	}
1293 
1294 	interface BXI<A> {
1295 		int f(boolean a, A b);
1296 	}
1297 
1298 	interface BXXI<A, B> {
1299 		int f(boolean a, A b, B c);
1300 	}
1301 
1302 	interface BXXXI<A, B, C> {
1303 		int f(boolean a, A b, B c, C d);
1304 	}
1305 
1306 	interface XBI<A> {
1307 		int f(A a, boolean b);
1308 	}
1309 
1310 	interface XXBI<A, B> {
1311 		int f(A a, B b, boolean c);
1312 	}
1313 
1314 	interface XXXBI<A, B, C> {
1315 		int f(A a, B b, C c, boolean d);
1316 	}
1317 
1318 	interface II {
1319 		int f(int a);
1320 	}
1321 
1322 	interface IXI<A> {
1323 		int f(int a, A b);
1324 	}
1325 
1326 	interface IXXI<A, B> {
1327 		int f(int a, A b, B c);
1328 	}
1329 
1330 	interface IXXXI<A, B, C> {
1331 		int f(int a, A b, B c, C d);
1332 	}
1333 
1334 	interface XII<A> {
1335 		int f(A a, int b);
1336 	}
1337 
1338 	interface XXII<A, B> {
1339 		int f(A a, B b, int c);
1340 	}
1341 
1342 	interface XXXII<A, B, C> {
1343 		int f(A a, B b, C c, int d);
1344 	}
1345 
1346 	interface LI {
1347 		int f(long a);
1348 	}
1349 
1350 	interface LXI<A> {
1351 		int f(long a, A b);
1352 	}
1353 
1354 	interface LXXI<A, B> {
1355 		int f(long a, A b, B c);
1356 	}
1357 
1358 	interface LXXXI<A, B, C> {
1359 		int f(long a, A b, B c, C d);
1360 	}
1361 
1362 	interface XLI<A> {
1363 		int f(A a, long b);
1364 	}
1365 
1366 	interface XXLI<A, B> {
1367 		int f(A a, B b, long c);
1368 	}
1369 
1370 	interface XXXLI<A, B, C> {
1371 		int f(A a, B b, C c, long d);
1372 	}
1373 
1374 	interface DI {
1375 		int f(double a);
1376 	}
1377 
1378 	interface DXI<A> {
1379 		int f(double a, A b);
1380 	}
1381 
1382 	interface DXXI<A, B> {
1383 		int f(double a, A b, B c);
1384 	}
1385 
1386 	interface DXXXI<A, B, C> {
1387 		int f(double a, A b, B c, C d);
1388 	}
1389 
1390 	interface XDI<A> {
1391 		int f(A a, double b);
1392 	}
1393 
1394 	interface XXDI<A, B> {
1395 		int f(A a, B b, double c);
1396 	}
1397 
1398 	interface XXXDI<A, B, C> {
1399 		int f(A a, B b, C c, double d);
1400 	}
1401 
1402 	interface XI<A> {
1403 		int f(A a);
1404 	}
1405 
1406 	interface XXI<A, B> {
1407 		int f(A a, B b);
1408 	}
1409 
1410 	interface XXXI<A, B, C> {
1411 		int f(A a, B b, C c);
1412 	}
1413 
1414 	interface XXXXI<A, B, C, D> {
1415 		int f(A a, B b, C c, D d);
1416 	}
1417 
1418 	interface BBI {
1419 		int f(boolean a, boolean b);
1420 	}
1421 
1422 	interface BII {
1423 		int f(boolean a, int b);
1424 	}
1425 
1426 	interface BLI {
1427 		int f(boolean a, long b);
1428 	}
1429 
1430 	interface BDI {
1431 		int f(boolean a, double b);
1432 	}
1433 
1434 	interface IBI {
1435 		int f(int a, boolean b);
1436 	}
1437 
1438 	interface III {
1439 		int f(int a, int b);
1440 	}
1441 
1442 	interface ILI {
1443 		int f(int a, long b);
1444 	}
1445 
1446 	interface IDI {
1447 		int f(int a, double b);
1448 	}
1449 
1450 	interface LBI {
1451 		int f(long a, boolean b);
1452 	}
1453 
1454 	interface LII {
1455 		int f(long a, int b);
1456 	}
1457 
1458 	interface LLI {
1459 		int f(long a, long b);
1460 	}
1461 
1462 	interface LDI {
1463 		int f(long a, double b);
1464 	}
1465 
1466 	interface DBI {
1467 		int f(double a, boolean b);
1468 	}
1469 
1470 	interface DII {
1471 		int f(double a, int b);
1472 	}
1473 
1474 	interface DLI {
1475 		int f(double a, long b);
1476 	}
1477 
1478 	interface DDI {
1479 		int f(double a, double b);
1480 	}
1481 
1482 	interface VL {
1483 		long f();
1484 	}
1485 
1486 	interface BL {
1487 		long f(boolean a);
1488 	}
1489 
1490 	interface BXL<A> {
1491 		long f(boolean a, A b);
1492 	}
1493 
1494 	interface BXXL<A, B> {
1495 		long f(boolean a, A b, B c);
1496 	}
1497 
1498 	interface BXXXL<A, B, C> {
1499 		long f(boolean a, A b, B c, C d);
1500 	}
1501 
1502 	interface XBL<A> {
1503 		long f(A a, boolean b);
1504 	}
1505 
1506 	interface XXBL<A, B> {
1507 		long f(A a, B b, boolean c);
1508 	}
1509 
1510 	interface XXXBL<A, B, C> {
1511 		long f(A a, B b, C c, boolean d);
1512 	}
1513 
1514 	interface IL {
1515 		long f(int a);
1516 	}
1517 
1518 	interface IXL<A> {
1519 		long f(int a, A b);
1520 	}
1521 
1522 	interface IXXL<A, B> {
1523 		long f(int a, A b, B c);
1524 	}
1525 
1526 	interface IXXXL<A, B, C> {
1527 		long f(int a, A b, B c, C d);
1528 	}
1529 
1530 	interface XIL<A> {
1531 		long f(A a, int b);
1532 	}
1533 
1534 	interface XXIL<A, B> {
1535 		long f(A a, B b, int c);
1536 	}
1537 
1538 	interface XXXIL<A, B, C> {
1539 		long f(A a, B b, C c, int d);
1540 	}
1541 
1542 	interface LL {
1543 		long f(long a);
1544 	}
1545 
1546 	interface LXL<A> {
1547 		long f(long a, A b);
1548 	}
1549 
1550 	interface LXXL<A, B> {
1551 		long f(long a, A b, B c);
1552 	}
1553 
1554 	interface LXXXL<A, B, C> {
1555 		long f(long a, A b, B c, C d);
1556 	}
1557 
1558 	interface XLL<A> {
1559 		long f(A a, long b);
1560 	}
1561 
1562 	interface XXLL<A, B> {
1563 		long f(A a, B b, long c);
1564 	}
1565 
1566 	interface XXXLL<A, B, C> {
1567 		long f(A a, B b, C c, long d);
1568 	}
1569 
1570 	interface DL {
1571 		long f(double a);
1572 	}
1573 
1574 	interface DXL<A> {
1575 		long f(double a, A b);
1576 	}
1577 
1578 	interface DXXL<A, B> {
1579 		long f(double a, A b, B c);
1580 	}
1581 
1582 	interface DXXXL<A, B, C> {
1583 		long f(double a, A b, B c, C d);
1584 	}
1585 
1586 	interface XDL<A> {
1587 		long f(A a, double b);
1588 	}
1589 
1590 	interface XXDL<A, B> {
1591 		long f(A a, B b, double c);
1592 	}
1593 
1594 	interface XXXDL<A, B, C> {
1595 		long f(A a, B b, C c, double d);
1596 	}
1597 
1598 	interface XL<A> {
1599 		long f(A a);
1600 	}
1601 
1602 	interface XXL<A, B> {
1603 		long f(A a, B b);
1604 	}
1605 
1606 	interface XXXL<A, B, C> {
1607 		long f(A a, B b, C c);
1608 	}
1609 
1610 	interface XXXXL<A, B, C, D> {
1611 		long f(A a, B b, C c, D d);
1612 	}
1613 
1614 	interface BBL {
1615 		long f(boolean a, boolean b);
1616 	}
1617 
1618 	interface BIL {
1619 		long f(boolean a, int b);
1620 	}
1621 
1622 	interface BLL {
1623 		long f(boolean a, long b);
1624 	}
1625 
1626 	interface BDL {
1627 		long f(boolean a, double b);
1628 	}
1629 
1630 	interface IBL {
1631 		long f(int a, boolean b);
1632 	}
1633 
1634 	interface IIL {
1635 		long f(int a, int b);
1636 	}
1637 
1638 	interface ILL {
1639 		long f(int a, long b);
1640 	}
1641 
1642 	interface IDL {
1643 		long f(int a, double b);
1644 	}
1645 
1646 	interface LBL {
1647 		long f(long a, boolean b);
1648 	}
1649 
1650 	interface LIL {
1651 		long f(long a, int b);
1652 	}
1653 
1654 	interface LLL {
1655 		long f(long a, long b);
1656 	}
1657 
1658 	interface LDL {
1659 		long f(long a, double b);
1660 	}
1661 
1662 	interface DBL {
1663 		long f(double a, boolean b);
1664 	}
1665 
1666 	interface DIL {
1667 		long f(double a, int b);
1668 	}
1669 
1670 	interface DLL {
1671 		long f(double a, long b);
1672 	}
1673 
1674 	interface DDL {
1675 		long f(double a, double b);
1676 	}
1677 
1678 	interface VD {
1679 		double f();
1680 	}
1681 
1682 	interface BD {
1683 		double f(boolean a);
1684 	}
1685 
1686 	interface BXD<A> {
1687 		double f(boolean a, A b);
1688 	}
1689 
1690 	interface BXXD<A, B> {
1691 		double f(boolean a, A b, B c);
1692 	}
1693 
1694 	interface BXXXD<A, B, C> {
1695 		double f(boolean a, A b, B c, C d);
1696 	}
1697 
1698 	interface XBD<A> {
1699 		double f(A a, boolean b);
1700 	}
1701 
1702 	interface XXBD<A, B> {
1703 		double f(A a, B b, boolean c);
1704 	}
1705 
1706 	interface XXXBD<A, B, C> {
1707 		double f(A a, B b, C c, boolean d);
1708 	}
1709 
1710 	interface ID {
1711 		double f(int a);
1712 	}
1713 
1714 	interface IXD<A> {
1715 		double f(int a, A b);
1716 	}
1717 
1718 	interface IXXD<A, B> {
1719 		double f(int a, A b, B c);
1720 	}
1721 
1722 	interface IXXXD<A, B, C> {
1723 		double f(int a, A b, B c, C d);
1724 	}
1725 
1726 	interface XID<A> {
1727 		double f(A a, int b);
1728 	}
1729 
1730 	interface XXID<A, B> {
1731 		double f(A a, B b, int c);
1732 	}
1733 
1734 	interface XXXID<A, B, C> {
1735 		double f(A a, B b, C c, int d);
1736 	}
1737 
1738 	interface LD {
1739 		double f(long a);
1740 	}
1741 
1742 	interface LXD<A> {
1743 		double f(long a, A b);
1744 	}
1745 
1746 	interface LXXD<A, B> {
1747 		double f(long a, A b, B c);
1748 	}
1749 
1750 	interface LXXXD<A, B, C> {
1751 		double f(long a, A b, B c, C d);
1752 	}
1753 
1754 	interface XLD<A> {
1755 		double f(A a, long b);
1756 	}
1757 
1758 	interface XXLD<A, B> {
1759 		double f(A a, B b, long c);
1760 	}
1761 
1762 	interface XXXLD<A, B, C> {
1763 		double f(A a, B b, C c, long d);
1764 	}
1765 
1766 	interface DD {
1767 		double f(double a);
1768 	}
1769 
1770 	interface DXD<A> {
1771 		double f(double a, A b);
1772 	}
1773 
1774 	interface DXXD<A, B> {
1775 		double f(double a, A b, B c);
1776 	}
1777 
1778 	interface DXXXD<A, B, C> {
1779 		double f(double a, A b, B c, C d);
1780 	}
1781 
1782 	interface XDD<A> {
1783 		double f(A a, double b);
1784 	}
1785 
1786 	interface XXDD<A, B> {
1787 		double f(A a, B b, double c);
1788 	}
1789 
1790 	interface XXXDD<A, B, C> {
1791 		double f(A a, B b, C c, double d);
1792 	}
1793 
1794 	interface XD<A> {
1795 		double f(A a);
1796 	}
1797 
1798 	interface XXD<A, B> {
1799 		double f(A a, B b);
1800 	}
1801 
1802 	interface XXXD<A, B, C> {
1803 		double f(A a, B b, C c);
1804 	}
1805 
1806 	interface XXXXD<A, B, C, D> {
1807 		double f(A a, B b, C c, D d);
1808 	}
1809 
1810 	interface BBD {
1811 		double f(boolean a, boolean b);
1812 	}
1813 
1814 	interface BID {
1815 		double f(boolean a, int b);
1816 	}
1817 
1818 	interface BLD {
1819 		double f(boolean a, long b);
1820 	}
1821 
1822 	interface BDD {
1823 		double f(boolean a, double b);
1824 	}
1825 
1826 	interface IBD {
1827 		double f(int a, boolean b);
1828 	}
1829 
1830 	interface IID {
1831 		double f(int a, int b);
1832 	}
1833 
1834 	interface ILD {
1835 		double f(int a, long b);
1836 	}
1837 
1838 	interface IDD {
1839 		double f(int a, double b);
1840 	}
1841 
1842 	interface LBD {
1843 		double f(long a, boolean b);
1844 	}
1845 
1846 	interface LID {
1847 		double f(long a, int b);
1848 	}
1849 
1850 	interface LLD {
1851 		double f(long a, long b);
1852 	}
1853 
1854 	interface LDD {
1855 		double f(long a, double b);
1856 	}
1857 
1858 	interface DBD {
1859 		double f(double a, boolean b);
1860 	}
1861 
1862 	interface DID {
1863 		double f(double a, int b);
1864 	}
1865 
1866 	interface DLD {
1867 		double f(double a, long b);
1868 	}
1869 
1870 	interface DDD {
1871 		double f(double a, double b);
1872 	}
1873 
1874 	interface VX<A> {
1875 		A f();
1876 	}
1877 
1878 	interface BX<A> {
1879 		A f(boolean a);
1880 	}
1881 
1882 	interface BXX<A, B> {
1883 		B f(boolean a, A b);
1884 	}
1885 
1886 	interface BXXX<A, B, C> {
1887 		C f(boolean a, A b, B c);
1888 	}
1889 
1890 	interface BXXXX<A, B, C, D> {
1891 		D f(boolean a, A b, B c, C d);
1892 	}
1893 
1894 	interface XBX<A, B> {
1895 		B f(A a, boolean b);
1896 	}
1897 
1898 	interface XXBX<A, B, C> {
1899 		C f(A a, B b, boolean c);
1900 	}
1901 
1902 	interface XXXBX<A, B, C, D> {
1903 		D f(A a, B b, C c, boolean d);
1904 	}
1905 
1906 	interface IX<A> {
1907 		A f(int a);
1908 	}
1909 
1910 	interface IXX<A, B> {
1911 		B f(int a, A b);
1912 	}
1913 
1914 	interface IXXX<A, B, C> {
1915 		C f(int a, A b, B c);
1916 	}
1917 
1918 	interface IXXXX<A, B, C, D> {
1919 		D f(int a, A b, B c, C d);
1920 	}
1921 
1922 	interface XIX<A, B> {
1923 		B f(A a, int b);
1924 	}
1925 
1926 	interface XXIX<A, B, C> {
1927 		C f(A a, B b, int c);
1928 	}
1929 
1930 	interface XXXIX<A, B, C, D> {
1931 		D f(A a, B b, C c, int d);
1932 	}
1933 
1934 	interface LX<A> {
1935 		A f(long a);
1936 	}
1937 
1938 	interface LXX<A, B> {
1939 		B f(long a, A b);
1940 	}
1941 
1942 	interface LXXX<A, B, C> {
1943 		C f(long a, A b, B c);
1944 	}
1945 
1946 	interface LXXXX<A, B, C, D> {
1947 		D f(long a, A b, B c, C d);
1948 	}
1949 
1950 	interface XLX<A, B> {
1951 		B f(A a, long b);
1952 	}
1953 
1954 	interface XXLX<A, B, C> {
1955 		C f(A a, B b, long c);
1956 	}
1957 
1958 	interface XXXLX<A, B, C, D> {
1959 		D f(A a, B b, C c, long d);
1960 	}
1961 
1962 	interface DX<A> {
1963 		A f(double a);
1964 	}
1965 
1966 	interface DXX<A, B> {
1967 		B f(double a, A b);
1968 	}
1969 
1970 	interface DXXX<A, B, C> {
1971 		C f(double a, A b, B c);
1972 	}
1973 
1974 	interface DXXXX<A, B, C, D> {
1975 		D f(double a, A b, B c, C d);
1976 	}
1977 
1978 	interface XDX<A, B> {
1979 		B f(A a, double b);
1980 	}
1981 
1982 	interface XXDX<A, B, C> {
1983 		C f(A a, B b, double c);
1984 	}
1985 
1986 	interface XXXDX<A, B, C, D> {
1987 		D f(A a, B b, C c, double d);
1988 	}
1989 
1990 	interface XX<A, B> {
1991 		B f(A a);
1992 	}
1993 
1994 	interface XXX<A, B, C> {
1995 		C f(A a, B b);
1996 	}
1997 
1998 	interface XXXX<A, B, C, D> {
1999 		D f(A a, B b, C c);
2000 	}
2001 
2002 	interface XXXXX<A, B, C, D, E> {
2003 		E f(A a, B b, C c, D d);
2004 	}
2005 
2006 	interface BBX<A> {
2007 		A f(boolean a, boolean b);
2008 	}
2009 
2010 	interface BIX<A> {
2011 		A f(boolean a, int b);
2012 	}
2013 
2014 	interface BLX<A> {
2015 		A f(boolean a, long b);
2016 	}
2017 
2018 	interface BDX<A> {
2019 		A f(boolean a, double b);
2020 	}
2021 
2022 	interface IBX<A> {
2023 		A f(int a, boolean b);
2024 	}
2025 
2026 	interface IIX<A> {
2027 		A f(int a, int b);
2028 	}
2029 
2030 	interface ILX<A> {
2031 		A f(int a, long b);
2032 	}
2033 
2034 	interface IDX<A> {
2035 		A f(int a, double b);
2036 	}
2037 
2038 	interface LBX<A> {
2039 		A f(long a, boolean b);
2040 	}
2041 
2042 	interface LIX<A> {
2043 		A f(long a, int b);
2044 	}
2045 
2046 	interface LLX<A> {
2047 		A f(long a, long b);
2048 	}
2049 
2050 	interface LDX<A> {
2051 		A f(long a, double b);
2052 	}
2053 
2054 	interface DBX<A> {
2055 		A f(double a, boolean b);
2056 	}
2057 
2058 	interface DIX<A> {
2059 		A f(double a, int b);
2060 	}
2061 
2062 	interface DLX<A> {
2063 		A f(double a, long b);
2064 	}
2065 
2066 	interface DDX<A> {
2067 		A f(double a, double b);
2068 	}
2069 }
2070 
2071 class SA { // suffix array
2072 	static int[] makeSA(String s) {
2073 		int n = s.length() + 1;
2074 		int[] cs = new int[n];
2075 		cs[n - 1] = 0;
2076 		for (int i = 0; i < n - 1; i++)
2077 			cs[i] = s.charAt(i) + 1;
2078 		ArrayList<Integer> acs = U.make(n, i -> cs[i]);
2079 		TreeMap<Integer, Integer> tm = U.compress(acs).a;
2080 		int k = tm.size();
2081 		for (int i = 0; i < n; i++)
2082 			cs[i] = tm.get(cs[i]);
2083 		return makeSA(cs, n, k);
2084 	}
2085 
2086 	static int[] makeLCP(String s, int[] sa) { // lcp(i, i+1)
2087 		int n = sa.length;
2088 		int[] r = new int[n];
2089 		for (int i = 0; i < n; i++)
2090 			r[sa[i]] = i;
2091 		int[] lcp = new int[n];
2092 		int l = 0;
2093 		for (int i = 0; i < n; i++) {
2094 			int idx = r[i];
2095 			if (idx == n - 1) {
2096 				lcp[idx] = -1;
2097 				l = 0;
2098 				continue;
2099 			}
2100 			int p = sa[idx];
2101 			int q = sa[idx + 1];
2102 			if (l > 0)
2103 				l--;
2104 			while (p + l < n - 1 && q + l < n - 1 && s.charAt(p + l) == s.charAt(q + l))
2105 				l++;
2106 			lcp[idx] = l;
2107 		}
2108 		return lcp;
2109 	}
2110 
2111 	static F.III lcpQuery(String s) {
2112 		int n = s.length() + 1;
2113 		int[] sa = makeSA(s);
2114 		int[] lcp = makeLCP(s, sa);
2115 		int[] inv = new int[n];
2116 		for (int i = 0; i < n; i++) {
2117 			inv[sa[i]] = i;
2118 		}
2119 		ST<Integer> st = new ST<Integer>(n, (a, b) -> a < b ? a : b, Integer.MAX_VALUE);
2120 		st.init(i -> i < n ? lcp[i] : Integer.MAX_VALUE);
2121 		return (i, j) -> {
2122 			if (i == j)
2123 				return n - 1 - i;
2124 			i = inv[i];
2125 			j = inv[j];
2126 			if (i > j) {
2127 				i ^= j;
2128 				j ^= i;
2129 				i ^= j;
2130 			}
2131 			return st.query(i, j);
2132 		};
2133 	}
2134 
2135 	private static int[] makeSA(int[] cs, int n, int k) {
2136 		boolean[] isS = new boolean[n];
2137 		boolean[] isLms = new boolean[n];
2138 		int[] lmss = new int[n];
2139 		int numLmss = 0;
2140 		isS[n - 1] = true;
2141 		for (int i = n - 2; i >= 0; i--)
2142 			isS[i] = cs[i] < cs[i + 1] || cs[i] == cs[i + 1] && isS[i + 1];
2143 		for (int i = 1; i < n; i++)
2144 			if (!isS[i - 1] && isS[i]) {
2145 				lmss[numLmss++] = i;
2146 				isLms[i] = true;
2147 			}
2148 		int[] sa = inducedSort(cs, n, numLmss, k, lmss, isS);
2149 		int[] lmss2 = new int[numLmss];
2150 		numLmss = 0;
2151 		for (int i = 0; i < n; i++)
2152 			if (isLms[sa[i]])
2153 				lmss2[numLmss++] = sa[i];
2154 		int num = 0;
2155 		sa[lmss2[0]] = 0;
2156 		for (int i = 0; i < numLmss - 1; i++) {
2157 			int p = lmss2[i];
2158 			int q = lmss2[i + 1];
2159 			for (int j = 0; j < n; j++) {
2160 				if (cs[p] != cs[q] || isLms[p] != isLms[q]) {
2161 					sa[lmss2[i + 1]] = ++num;
2162 					break;
2163 				} else if (j > 0 && (isLms[p] || isLms[q])) {
2164 					sa[lmss2[i + 1]] = num;
2165 					break;
2166 				}
2167 				p++;
2168 				q++;
2169 			}
2170 		}
2171 		if (num + 1 < numLmss) {
2172 			numLmss = 0;
2173 			for (int i = 0; i < n; i++)
2174 				if (isLms[i])
2175 					lmss2[numLmss++] = sa[i];
2176 			lmss2 = makeSA(lmss2, numLmss, num + 1);
2177 			for (int i = 0; i < numLmss; i++)
2178 				lmss2[i] = lmss[lmss2[i]];
2179 		}
2180 		return inducedSort(cs, n, numLmss, k, lmss2, isS);
2181 	}
2182 
2183 	private static int[] inducedSort(int[] cs, int n, int numLmss, int k, int[] lmss, boolean[] isS) {
2184 		int[] sa = new int[n];
2185 		int[] bin = new int[k + 1];
2186 		for (int i = 0; i < n; i++)
2187 			bin[cs[i] + 1]++;
2188 		for (int i = 0; i < k; i++)
2189 			bin[i + 1] += bin[i];
2190 		int[] counts = new int[k];
2191 		for (int i = numLmss - 1; i >= 0; i--) { // put LMS backward
2192 			int c = cs[lmss[i]];
2193 			sa[bin[c + 1] - 1 - counts[c]++] = lmss[i];
2194 		}
2195 		for (int i = 0; i < k; i++)
2196 			counts[i] = 0;
2197 		for (int i = 0; i < n; i++) { // put L forward
2198 			int s = sa[i] - 1;
2199 			if (s < 0 || isS[s])
2200 				continue;
2201 			int c = cs[s];
2202 			sa[bin[c] + counts[c]++] = s;
2203 		}
2204 		for (int i = 0; i < k; i++)
2205 			counts[i] = 0;
2206 		for (int i = n - 1; i >= 0; i--) { // put S backward
2207 			int s = sa[i] - 1;
2208 			if (s < 0 || !isS[s])
2209 				continue;
2210 			int c = cs[s];
2211 			sa[bin[c + 1] - 1 - counts[c]++] = s;
2212 		}
2213 		return sa;
2214 	}
2215 }
2216 
2217 class ST<A> { // Segment Tree
2218 	private ArrayList<A> as;
2219 	private int h;
2220 	private int n;
2221 	private F.XXX<A, A, A> merger;
2222 	private A e;
2223 
2224 	ST(int num, F.XXX<A, A, A> merger, A e) {
2225 		this.merger = merger;
2226 		this.e = e;
2227 		h = 0;
2228 		while ((1 << h) < num)
2229 			h++;
2230 		n = 1 << h;
2231 		as = U.make(2 * n, i -> e);
2232 	}
2233 
2234 	void init(A a) {
2235 		init(i -> a);
2236 	}
2237 
2238 	void init(A[] as) {
2239 		init(i -> i < as.length ? as[i] : e);
2240 	}
2241 
2242 	void init(F.IX<A> maker) {
2243 		for (int i = 0; i < n; i++)
2244 			as.set(n + i, maker.f(i));
2245 		for (int i = n - 1; i > 0; i--)
2246 			as.set(i, merge(as.get(i << 1), as.get(i << 1 | 1)));
2247 	}
2248 
2249 	A get(int i) {
2250 		return query(i, i + 1);
2251 	}
2252 
2253 	void set(int i, A a) {
2254 		as.set(i += n, a);
2255 		while ((i >>= 1) > 0)
2256 			as.set(i, merge(as.get(i << 1), as.get(i << 1 | 1)));
2257 	}
2258 
2259 	A query(int l, int r) {
2260 		l += n;
2261 		r += n;
2262 		A al = e;
2263 		A ar = e;
2264 		while (l < r) {
2265 			if ((l & 1) != 0)
2266 				al = merge(al, as.get(l++));
2267 			if ((r & 1) != 0)
2268 				ar = merge(as.get(--r), ar);
2269 			l >>= 1;
2270 			r >>= 1;
2271 		}
2272 		return merge(al, ar);
2273 	}
2274 
2275 	private A merge(A a, A b) {
2276 		return a == e ? b : b == e ? a : merger.f(a, b);
2277 	}
2278 }
2279 
2280 interface Magma<A> {
2281 	A g(A a, A b);
2282 }
2283 
2284 interface Associative {
2285 }
2286 
2287 interface Unital<A> {
2288 	A e();
2289 }
2290 
2291 interface Invertible<A> {
2292 	A inv(A a);
2293 }
2294 
2295 interface Commutative {
2296 }
2297 
2298 interface SemiGroup<A> extends Magma<A>, Associative {
2299 }
2300 
2301 interface Monoid<A> extends SemiGroup<A>, Unital<A> {
2302 	static <A> Monoid<A> make(F.XXX<A, A, A> g, A e) {
2303 		return new Monoid<A>() {
2304 			public A g(A a, A b) {
2305 				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
2306 			}
2307 
2308 			public A e() {
2309 				return e;
2310 			}
2311 		};
2312 	}
2313 }
2314 
2315 interface CommutativeMonoid<A> extends Monoid<A>, Commutative {
2316 	static <A> CommutativeMonoid<A> make(F.XXX<A, A, A> g, A e) {
2317 		return new CommutativeMonoid<A>() {
2318 			public A g(A a, A b) {
2319 				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
2320 			}
2321 
2322 			public A e() {
2323 				return e;
2324 			}
2325 		};
2326 	}
2327 }
2328 
2329 interface Group<A> extends Monoid<A>, Invertible<A> {
2330 	static <A> Group<A> make(F.XXX<A, A, A> g, F.XX<A, A> inv, A e) {
2331 		return new Group<A>() {
2332 			public A g(A a, A b) {
2333 				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
2334 			}
2335 
2336 			public A e() {
2337 				return e;
2338 			}
2339 
2340 			public A inv(A a) {
2341 				return a.equals(e) ? e : inv.f(a);
2342 			}
2343 		};
2344 	}
2345 }
2346 
2347 interface AbelianGroup<A> extends Group<A>, CommutativeMonoid<A> {
2348 	static <A> AbelianGroup<A> make(F.XXX<A, A, A> g, F.XX<A, A> inv, A e) {
2349 		return new AbelianGroup<A>() {
2350 			public A g(A a, A b) {
2351 				return a.equals(e) ? b : b.equals(e) ? a : g.f(a, b);
2352 			}
2353 
2354 			public A e() {
2355 				return e;
2356 			}
2357 
2358 			public A inv(A a) {
2359 				return a.equals(e) ? e : inv.f(a);
2360 			}
2361 		};
2362 	}
2363 }
2364 
2365 interface Ring<A> {
2366 	AbelianGroup<A> add();
2367 
2368 	Monoid<A> mul();
2369 
2370 	default A zero() {
2371 		return add().e();
2372 	}
2373 
2374 	default A one() {
2375 		return mul().e();
2376 	}
2377 
2378 	static <A> Ring<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, A zero, A one) {
2379 		return make(AbelianGroup.make(add, neg, zero), Monoid.make(mul, one));
2380 	}
2381 
2382 	static <A> Ring<A> make(AbelianGroup<A> add, Monoid<A> mul) {
2383 		return new Ring<A>() {
2384 			public AbelianGroup<A> add() {
2385 				return add;
2386 			}
2387 
2388 			public Monoid<A> mul() {
2389 				return mul;
2390 			}
2391 		};
2392 	}
2393 }
2394 
2395 interface CommutativeRing<A> extends Ring<A> {
2396 	CommutativeMonoid<A> mul();
2397 
2398 	static <A> CommutativeRing<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, A zero, A one) {
2399 		return make(AbelianGroup.make(add, neg, zero), CommutativeMonoid.make(mul, one));
2400 	}
2401 
2402 	static <A> CommutativeRing<A> make(AbelianGroup<A> add, CommutativeMonoid<A> mul) {
2403 		return new CommutativeRing<A>() {
2404 			public AbelianGroup<A> add() {
2405 				return add;
2406 			}
2407 
2408 			public CommutativeMonoid<A> mul() {
2409 				return mul;
2410 			}
2411 		};
2412 	}
2413 }
2414 
2415 interface EuclideanRing<A> extends CommutativeRing<A> {
2416 	A div(A a, A b);
2417 
2418 	A mod(A a, A b);
2419 
2420 	static <A> EuclideanRing<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, F.XXX<A, A, A> div,
2421 			F.XXX<A, A, A> mod, A zero, A one) {
2422 		return make(AbelianGroup.make(add, neg, zero), CommutativeMonoid.make(mul, one), div, mod);
2423 	}
2424 
2425 	static <A> EuclideanRing<A> make(AbelianGroup<A> add, CommutativeMonoid<A> mul, F.XXX<A, A, A> div,
2426 			F.XXX<A, A, A> mod) {
2427 		final A zero = add.e();
2428 		final A one = mul.e();
2429 		return new EuclideanRing<A>() {
2430 			public AbelianGroup<A> add() {
2431 				return add;
2432 			}
2433 
2434 			public CommutativeMonoid<A> mul() {
2435 				return mul;
2436 			}
2437 
2438 			public A div(A a, A b) {
2439 				if (b.equals(zero))
2440 					throw new ArithmeticException("division by zero");
2441 				return b.equals(one) ? a : div.f(a, b);
2442 			}
2443 
2444 			public A mod(A a, A b) {
2445 				if (b.equals(zero))
2446 					throw new ArithmeticException("division by zero");
2447 				return b.equals(one) ? zero : mod.f(a, b);
2448 			}
2449 		};
2450 	}
2451 }
2452 
2453 interface Field<A> extends EuclideanRing<A> {
2454 	AbelianGroup<A> mul();
2455 
2456 	static <A> Field<A> make(F.XXX<A, A, A> add, F.XX<A, A> neg, F.XXX<A, A, A> mul, F.XX<A, A> inv, A zero, A one) {
2457 		return make(AbelianGroup.make(add, neg, zero), AbelianGroup.make(mul, inv, one));
2458 	}
2459 
2460 	static <A> Field<A> make(AbelianGroup<A> add, AbelianGroup<A> mul) {
2461 		final A zero = add.e();
2462 		final A one = mul.e();
2463 		return new Field<A>() {
2464 			public AbelianGroup<A> add() {
2465 				return add;
2466 			}
2467 
2468 			public AbelianGroup<A> mul() {
2469 				return mul;
2470 			}
2471 
2472 			public A div(A a, A b) {
2473 				if (b.equals(zero))
2474 					throw new ArithmeticException("division by zero");
2475 				return b.equals(one) ? a : mul.g(a, mul.inv(b));
2476 			}
2477 
2478 			public A mod(A a, A b) {
2479 				if (b.equals(zero))
2480 					throw new ArithmeticException("division by zero");
2481 				return zero;
2482 			}
2483 		};
2484 	}
2485 }
2486 
2487 final class Alg {
2488 	private Alg() {
2489 	}
2490 
2491 	static <A extends Comparable<? super A>> A gcd(A a, A b, EuclideanRing<A> ring) {
2492 		AbelianGroup<A> add = ring.add();
2493 		A zero = add.e();
2494 		int sa = a.compareTo(zero);
2495 		int sb = b.compareTo(zero);
2496 		if (sa == 0)
2497 			return b;
2498 		if (sb == 0)
2499 			return a;
2500 		if (sa < 0)
2501 			a = add.inv(a);
2502 		if (sb < 0)
2503 			b = add.inv(b);
2504 		if (a.compareTo(b) < 0) {
2505 			A tmp = a;
2506 			a = b;
2507 			b = tmp;
2508 		}
2509 		while (true) {
2510 			A c = ring.mod(a, b);
2511 			if (c.compareTo(zero) == 0)
2512 				return b;
2513 			a = b;
2514 			b = c;
2515 		}
2516 	}
2517 
2518 	static long gcd(long a, long b) {
2519 		if (a == 0)
2520 			return b;
2521 		if (b == 0)
2522 			return a;
2523 		if (a < 0)
2524 			a = -a;
2525 		if (b < 0)
2526 			b = -b;
2527 		if (a < b) {
2528 			a ^= b;
2529 			b ^= a;
2530 			a ^= b;
2531 		}
2532 		while (true) {
2533 			long c = a % b;
2534 			if (c == 0)
2535 				return b;
2536 			a = b;
2537 			b = c;
2538 		}
2539 	}
2540 
2541 	static int gcd(int a, int b) {
2542 		return (int) gcd((long) a, (long) b);
2543 	}
2544 
2545 	static <A extends Comparable<A>> int[] lis(F.IX<A> access, int size) {
2546 		Object[] dp = new Object[size];
2547 		int[][] dpIndices = new int[size][2];
2548 		dp[0] = access.f(0);
2549 		int len = 1;
2550 		int lidx = 0;
2551 		for (int i = 1; i < size; i++) {
2552 			A ai = access.f(i);
2553 			@SuppressWarnings("unchecked")
2554 			int idx = U.searchI(-1, len, j -> ai.compareTo((A) dp[j]) <= 0); // replace <= with < to return NLDS
2555 			dp[idx] = ai;
2556 			dpIndices[idx][0] = i;
2557 			if (idx == len) {
2558 				lidx = i;
2559 				len++;
2560 			}
2561 			if (idx > 0)
2562 				dpIndices[i][1] = dpIndices[idx - 1][0];
2563 		}
2564 		int[] res = new int[len];
2565 		res[len - 1] = lidx;
2566 		for (int i = len - 1; i >= 0; i--) {
2567 			res[i] = lidx;
2568 			lidx = dpIndices[lidx][1];
2569 		}
2570 		return res;
2571 	}
2572 
2573 	static <A> A pow(A a, long b, Monoid<A> monoid) {
2574 		A res = monoid.e();
2575 		while (b > 0) {
2576 			if ((b & 1) != 0)
2577 				res = monoid.g(res, a);
2578 			a = monoid.g(a, a);
2579 			b >>= 1;
2580 		}
2581 		return res;
2582 	}
2583 
2584 	static long pow(long a, long b) {
2585 		long res = 1;
2586 		while (b > 0) {
2587 			if ((b & 1) != 0)
2588 				res *= a;
2589 			a *= a;
2590 			b >>= 1;
2591 		}
2592 		return res;
2593 	}
2594 
2595 	static <A extends Comparable<? super A>> T<A, A, A> extgcd(A a, A b, EuclideanRing<A> ring) { // returns (x, y, d) s.t. ax + by = d
2596 		AbelianGroup<A> add = ring.add();
2597 		CommutativeMonoid<A> mul = ring.mul();
2598 		A zero = add.e();
2599 		A one = mul.e();
2600 		A sa = a.compareTo(zero) < 0 ? add.inv(one) : one;
2601 		A sb = b.compareTo(zero) < 0 ? add.inv(one) : one;
2602 		a = mul.g(a, sa);
2603 		b = mul.g(b, sb);
2604 		A x = one;
2605 		A y = zero;
2606 		A z = zero;
2607 		A w = one;
2608 		while (b.compareTo(zero) > 0) {
2609 			A q = ring.div(a, b);
2610 			A t = z;
2611 			z = add.g(x, add.inv(mul.g(q, z)));
2612 			x = t;
2613 			t = w;
2614 			w = add.g(y, add.inv(mul.g(q, w)));
2615 			y = t;
2616 			t = b;
2617 			b = add.g(a, add.inv(mul.g(q, b)));
2618 			a = t;
2619 		}
2620 		return T.make(mul.g(x, sa), mul.g(y, sb), a);
2621 	}
2622 
2623 	static TL extgcd(long a, long b) {
2624 		int sa = a < 0 ? -1 : 1;
2625 		int sb = b < 0 ? -1 : 1;
2626 		a *= sa;
2627 		b *= sb;
2628 		long x = 1;
2629 		long y = 0;
2630 		long z = 0;
2631 		long w = 1;
2632 		while (b > 0) {
2633 			long q = a / b;
2634 			long t = z;
2635 			z = x - q * z;
2636 			x = t;
2637 			t = w;
2638 			w = y - q * w;
2639 			y = t;
2640 			t = b;
2641 			b = a - q * b;
2642 			a = t;
2643 		}
2644 		return TL.make(x * sa, y * sb, a);
2645 	}
2646 
2647 	static TI extgcd(int a, int b) {
2648 		return extgcd((long) a, (long) b).toInt();
2649 	}
2650 
2651 	static ArrayList<PI> factorize(int n) { // factor, exponent
2652 		ArrayList<PI> res = new ArrayList<PI>();
2653 		for (int i = 2; i * i <= n; i++) {
2654 			int count = 0;
2655 			while (n % i == 0) {
2656 				n /= i;
2657 				count++;
2658 			}
2659 			if (count > 0)
2660 				res.add(PI.make(i, count));
2661 		}
2662 		if (n > 1)
2663 			res.add(PI.make(n, 1));
2664 		return res;
2665 	}
2666 
2667 	static <A> A arithSum(A a, A d, long num, Ring<A> ring) {
2668 		return arithGeomSum(a, d, ring.one(), ring.one(), num, ring);
2669 	}
2670 
2671 	static <A> A geomSum(A b, A r, long num, Ring<A> ring) {
2672 		return arithGeomSum(ring.one(), ring.zero(), b, r, num, ring);
2673 	}
2674 
2675 	static <A> A arithGeomSum(A a, A d, A b, A r, long num, Ring<A> ring) { // (a+(i-1)d)br^(i-1)
2676 		AbelianGroup<A> add = ring.add();
2677 		Monoid<A> mul = ring.mul();
2678 		Monoid<MN<A>> matMul = Mat.mulRing(3, ring);
2679 		A zero = ring.zero();
2680 		A one = ring.one();
2681 		MN<A> mat = pow(Mat.make(new Object[][] { { r, d, a }, { zero, r, r }, { zero, zero, one } }), num - 1, matMul);
2682 		return mul.g(add.g(add.g(mul.g(mat.at(0, 0), a), mul.g(mat.at(0, 1), r)), mat.at(0, 2)), b);
2683 	}
2684 }
2685 
2686 class MN<A> {
2687 	final int m;
2688 	final int n;
2689 	private final Object[][] as;
2690 
2691 	static class Scalar<A> extends MN<A> {
2692 		final long l;
2693 		A a;
2694 
2695 		Scalar(int m, int n, long l, A zero, A oneTimesL) {
2696 			super(m, n, (i, j) -> i == j ? oneTimesL : zero);
2697 			this.a = oneTimesL;
2698 			this.l = l;
2699 		}
2700 	}
2701 
2702 	MN(int m, int n, Mat.Accessor<A> accessor) {
2703 		this.m = m;
2704 		this.n = n;
2705 		as = new Object[m][n];
2706 		for (int i = 0; i < m; i++) {
2707 			for (int j = 0; j < n; j++) {
2708 				as[i][j] = accessor.at(i, j);
2709 			}
2710 		}
2711 	}
2712 
2713 	public String toString() {
2714 		String s = "";
2715 		for (int i = 0; i < m; i++) {
2716 			s += i == 0 ? "[[ " : " [ ";
2717 			for (int j = 0; j < n; j++) {
2718 				s += (j == 0 ? "" : ", ") + as[i][j];
2719 			}
2720 			s += i == m - 1 ? " ]]" : " ]\n";
2721 		}
2722 		return s;
2723 	}
2724 
2725 	@SuppressWarnings("unchecked")
2726 	A at(int i, int j) {
2727 		return (A) as[i][j];
2728 	}
2729 
2730 	@SuppressWarnings("unchecked")
2731 	A[][] toArray() {
2732 		A[][] res = (A[][]) Array.newInstance(as[0][0].getClass(), m, n);
2733 		for (int i = 0; i < m; i++) {
2734 			for (int j = 0; j < n; j++) {
2735 				res[i][j] = (A) as[i][j];
2736 			}
2737 		}
2738 		return res;
2739 	}
2740 
2741 	int[][] toIntArray() {
2742 		int[][] res = new int[m][n];
2743 		for (int i = 0; i < m; i++) {
2744 			for (int j = 0; j < n; j++) {
2745 				res[i][j] = (int) as[i][j];
2746 			}
2747 		}
2748 		return res;
2749 	}
2750 
2751 	long[][] toLongArray() {
2752 		long[][] res = new long[m][n];
2753 		for (int i = 0; i < m; i++) {
2754 			for (int j = 0; j < n; j++) {
2755 				res[i][j] = (long) as[i][j];
2756 			}
2757 		}
2758 		return res;
2759 	}
2760 
2761 	double[][] toDoubleArray() {
2762 		double[][] res = new double[m][n];
2763 		for (int i = 0; i < m; i++) {
2764 			for (int j = 0; j < n; j++) {
2765 				res[i][j] = (double) as[i][j];
2766 			}
2767 		}
2768 		return res;
2769 	}
2770 }
2771 
2772 class Mat<A> {
2773 	interface Accessor<A> {
2774 		A at(int i, int j);
2775 	}
2776 
2777 	private static <A> MN.Scalar<A> make(int m, int n, long l, A zero, A oneTimesL) {
2778 		return new MN.Scalar<A>(m, n, l, zero, oneTimesL);
2779 	}
2780 
2781 	static <A> MN<A> make(int m, int n, Accessor<A> accessor) {
2782 		return new MN<A>(m, n, accessor);
2783 	}
2784 
2785 	static <A> MN<A> make(int m, int n, A[][] as) {
2786 		return new MN<A>(m, n, (i, j) -> as[i][j]);
2787 	}
2788 
2789 	static MN<Long> make(int[][] as) {
2790 		return new MN<Long>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> (long) as[i][j]);
2791 	}
2792 
2793 	static MN<Long> make(long[][] as) {
2794 		return new MN<Long>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> as[i][j]);
2795 	}
2796 
2797 	static MN<Double> make(double[][] as) {
2798 		return new MN<Double>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> as[i][j]);
2799 	}
2800 
2801 	static <A> MN<A> make(int[][] as, F.IX<A> toA) {
2802 		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
2803 	}
2804 
2805 	static <A> MN<A> make(long[][] as, F.LX<A> toA) {
2806 		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
2807 	}
2808 
2809 	static <A> MN<A> make(double[][] as, F.DX<A> toA) {
2810 		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
2811 	}
2812 
2813 	static <A, B> MN<A> make(B[][] as, F.XX<B, A> toA) {
2814 		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> toA.f(as[i][j]));
2815 	}
2816 
2817 	@SuppressWarnings("unchecked")
2818 	static <A> MN<A> make(Object[][] as) {
2819 		return new MN<A>(as.length, as.length == 0 ? 0 : as[0].length, (i, j) -> (A) as[i][j]);
2820 	}
2821 
2822 	static <A> MN<A> eye(int n, Ring<A> ring) {
2823 		return make(n, n, (i, j) -> i == j ? ring.mul().e() : ring.add().e());
2824 	}
2825 
2826 	static <A> AbelianGroup<MN<A>> add(int m, int n, Ring<A> ring) {
2827 		return AbelianGroup.make((a, b) -> add(a, b, ring), a -> neg(a, ring), make(m, n, 0, ring.zero(), ring.zero()));
2828 	}
2829 
2830 	static <A> Monoid<MN<A>> mulRing(int n, Ring<A> ring) {
2831 		return Monoid.make((a, b) -> mul(a, b, ring), make(n, n, 1, ring.zero(), ring.one()));
2832 	}
2833 
2834 	static <A> AbelianGroup<MN<A>> mulField(int n, Field<A> field) {
2835 		return AbelianGroup.make((a, b) -> mul(a, b, field), a -> inv(a, field),
2836 				make(n, n, 1, field.zero(), field.one()));
2837 	}
2838 
2839 	static <A> MN<A> add(MN<A> a, MN<A> b, Ring<A> ring) {
2840 		int m = U.max(a.m, b.m);
2841 		int n = U.max(a.n, b.n);
2842 		AbelianGroup<A> add = ring.add();
2843 		if (a instanceof MN.Scalar && b instanceof MN.Scalar) {
2844 			MN.Scalar<A> as = ((MN.Scalar<A>) a);
2845 			MN.Scalar<A> bs = ((MN.Scalar<A>) b);
2846 			return make(m, n, as.l + bs.l, ring.zero(), add.g(as.a, bs.a));
2847 		}
2848 		return make(m, n, (i, j) -> add.g(a.at(i, j), b.at(i, j)));
2849 	}
2850 
2851 	static <A> MN<A> neg(MN<A> a, Ring<A> ring) {
2852 		if (a instanceof MN.Scalar) {
2853 			MN.Scalar<A> as = ((MN.Scalar<A>) a);
2854 			return make(a.m, a.n, -as.l, ring.zero(), ring.add().inv(as.a));
2855 		}
2856 		return make(a.m, a.n, (i, j) -> ring.add().inv(a.at(i, j)));
2857 	}
2858 
2859 	static <A> MN<A> mul(MN<A> a, MN<A> b, Ring<A> ring) {
2860 		int m = a.m;
2861 		int u = U.max(a.n, b.m);
2862 		int n = b.n;
2863 		AbelianGroup<A> add = ring.add();
2864 		Monoid<A> mul = ring.mul();
2865 		if (a instanceof MN.Scalar && b instanceof MN.Scalar) {
2866 			MN.Scalar<A> as = ((MN.Scalar<A>) a);
2867 			MN.Scalar<A> bs = ((MN.Scalar<A>) b);
2868 			return make(m, n, as.l * bs.l, ring.zero(), mul.g(as.a, bs.a));
2869 		}
2870 		return make(m, n, (i, j) -> {
2871 			A res = ring.zero();
2872 			for (int k = 0; k < u; k++)
2873 				res = add.g(res, mul.g(a.at(i, k), b.at(k, j)));
2874 			return res;
2875 		});
2876 	}
2877 
2878 	static <A> A det(MN<A> a, Field<A> field) {
2879 		return detInv(a, field).a;
2880 	}
2881 
2882 	static <A> MN<A> inv(MN<A> a, Field<A> field) {
2883 		UP<A, MN<A>> detInv = detInv(a, field);
2884 		if (detInv.a.equals(field.zero()))
2885 			throw new ArithmeticException("inverse does not exist: det=0");
2886 		return detInv.b;
2887 	}
2888 
2889 	@SuppressWarnings("unchecked")
2890 	private static <A> UP<A, MN<A>> detInv(MN<A> a, Field<A> field) {
2891 		if (a.m != a.n)
2892 			throw new IllegalArgumentException("matrix not square");
2893 		if (field.zero() instanceof Long) {
2894 			UP<Long, MN<Long>> detInv = detInvLong((MN<Long>) a, (Field<Long>) field);
2895 			return UP.make((A) detInv.a, (MN<A>) detInv.b);
2896 		}
2897 		int n = a.n;
2898 		AbelianGroup<A> add = field.add();
2899 		AbelianGroup<A> mul = field.mul();
2900 		A zero = field.zero();
2901 		A one = field.one();
2902 		A[][] m1 = a.toArray();
2903 		A[][] m2 = eye(n, field).toArray();
2904 		A res = one;
2905 		int sign = 1;
2906 		for (int i = 0; i < n; i++) {
2907 			int pivot = -1;
2908 			for (int j = i; j < n; j++) {
2909 				if (!m1[j][i].equals(zero)) {
2910 					pivot = j;
2911 					break;
2912 				}
2913 			}
2914 			if (pivot == -1) {
2915 				return UP.make(zero, null);
2916 			}
2917 			if (pivot != i) {
2918 				sign = -sign;
2919 				A tmp;
2920 				for (int j = i; j < n; j++) { // [0, i) are zero
2921 					tmp = m1[i][j];
2922 					m1[i][j] = m1[pivot][j];
2923 					m1[pivot][j] = tmp;
2924 				}
2925 				for (int j = 0; j < n; j++) {
2926 					tmp = m2[i][j];
2927 					m2[i][j] = m2[pivot][j];
2928 					m2[pivot][j] = tmp;
2929 				}
2930 			}
2931 			A d = m1[i][i];
2932 			res = mul.g(res, d);
2933 			d = mul.inv(d);
2934 			m1[i][i] = one;
2935 			for (int j = i + 1; j < n; j++) {
2936 				m1[i][j] = mul.g(m1[i][j], d);
2937 			}
2938 			for (int j = 0; j < n; j++) {
2939 				m2[i][j] = mul.g(m2[i][j], d);
2940 			}
2941 			for (int j = 0; j < n; j++) {
2942 				if (i == j)
2943 					continue;
2944 				A mult = m1[j][i];
2945 				m1[j][i] = zero;
2946 				for (int k = i + 1; k < n; k++) {
2947 					m1[j][k] = add.g(m1[j][k], add.inv(mul.g(m1[i][k], mult)));
2948 				}
2949 				for (int k = 0; k < n; k++) {
2950 					m2[j][k] = add.g(m2[j][k], add.inv(mul.g(m2[i][k], mult)));
2951 				}
2952 			}
2953 		}
2954 		return UP.make(sign == 1 ? res : add.inv(res), make(m2));
2955 	}
2956 
2957 	private static UP<Long, MN<Long>> detInvLong(MN<Long> a, Field<Long> field) {
2958 		if (a.m != a.n)
2959 			throw new IllegalArgumentException("matrix not square");
2960 		int n = a.n;
2961 		AbelianGroup<Long> add = field.add();
2962 		AbelianGroup<Long> mul = field.mul();
2963 		long zero = field.zero();
2964 		long one = field.one();
2965 		long[][] m1 = a.toLongArray();
2966 		long[][] m2 = eye(n, field).toLongArray();
2967 		long res = one;
2968 		int sign = 1;
2969 		for (int i = 0; i < n; i++) {
2970 			int pivot = -1;
2971 			for (int j = i; j < n; j++) {
2972 				if (m1[j][i] != zero) {
2973 					pivot = j;
2974 					break;
2975 				}
2976 			}
2977 			if (pivot == -1) {
2978 				return UP.make(zero, null);
2979 			}
2980 			if (pivot != i) {
2981 				sign = -sign;
2982 				long tmp;
2983 				for (int j = i; j < n; j++) { // [0, i) are zero
2984 					tmp = m1[i][j];
2985 					m1[i][j] = m1[pivot][j];
2986 					m1[pivot][j] = tmp;
2987 				}
2988 				for (int j = 0; j < n; j++) {
2989 					tmp = m2[i][j];
2990 					m2[i][j] = m2[pivot][j];
2991 					m2[pivot][j] = tmp;
2992 				}
2993 			}
2994 			long d = m1[i][i];
2995 			res = mul.g(res, d);
2996 			d = mul.inv(d);
2997 			m1[i][i] = one;
2998 			for (int j = i + 1; j < n; j++) {
2999 				m1[i][j] = mul.g(m1[i][j], d);
3000 			}
3001 			for (int j = 0; j < n; j++) {
3002 				m2[i][j] = mul.g(m2[i][j], d);
3003 			}
3004 			for (int j = 0; j < n; j++) {
3005 				if (i == j)
3006 					continue;
3007 				long mult = m1[j][i];
3008 				m1[j][i] = zero;
3009 				for (int k = i + 1; k < n; k++) {
3010 					m1[j][k] = add.g(m1[j][k], add.inv(mul.g(m1[i][k], mult)));
3011 				}
3012 				for (int k = 0; k < n; k++) {
3013 					m2[j][k] = add.g(m2[j][k], add.inv(mul.g(m2[i][k], mult)));
3014 				}
3015 			}
3016 		}
3017 		return UP.make(sign == 1 ? res : add.inv(res), make(m2));
3018 	}
3019 
3020 	static <A> Ring<MN<A>> ring(int n, Ring<A> ring) {
3021 		return Ring.make(add(n, n, ring), mulRing(n, ring));
3022 	}
3023 
3024 	static <A> Field<MN<A>> field(int n, Field<A> field) {
3025 		return Field.make(add(n, n, field), mulField(n, field));
3026 	}
3027 
3028 	static <A> VM<MN<A>> vm(int n, Ring<A> ring) {
3029 		if (ring instanceof Field)
3030 			return vmField(n, (Field<A>) ring);
3031 		return vmRing(n, ring);
3032 	}
3033 
3034 	private static <A> VM<MN<A>> vmRing(int n, Ring<A> ring) {
3035 		Ring<MN<A>> matRing = ring(n, ring);
3036 		Monoid<MN<A>> matMul = matRing.mul();
3037 		AbelianGroup<A> add = ring.add();
3038 		Monoid<A> mul = ring.mul();
3039 		A zero = add.e();
3040 		A one = mul.e();
3041 		return new VM<MN<A>>(matRing, null, null, (a, b) -> {
3042 			if (b instanceof MN.Scalar) {
3043 				MN.Scalar<A> bs = ((MN.Scalar<A>) b);
3044 				if (bs.l < 0)
3045 					throw new RuntimeException("pow(MN, <0) is not defined");
3046 				return Alg.pow(a, bs.l, matMul);
3047 			}
3048 			throw new RuntimeException("pow(MN, MN) is not defined");
3049 		}, null, l -> make(n, n, l, zero, Alg.pow(one, l, add)), a -> a);
3050 	}
3051 
3052 	private static <A> VM<MN<A>> vmField(int n, Field<A> field) {
3053 		Field<MN<A>> matField = field(n, field);
3054 		AbelianGroup<MN<A>> matMul = matField.mul();
3055 		A zero = field.zero();
3056 		A one = field.one();
3057 		return new VM<MN<A>>(matField, (a, b) -> {
3058 			if (b instanceof MN.Scalar) {
3059 				MN.Scalar<A> bs = ((MN.Scalar<A>) b);
3060 				if (bs.l < 0)
3061 					return Alg.pow(inv(a, field), -bs.l, matMul);
3062 				return Alg.pow(a, bs.l, matMul);
3063 			}
3064 			throw new RuntimeException("pow(MN, MN) is not defined");
3065 		}, a -> inv(a, field), l -> make(n, n, l, zero, Alg.pow(one, l, field.add())), a -> a);
3066 	}
3067 }
3068 
3069 class VM<A> {
3070 	private final HashMap<String, A> env;
3071 	private final Evaluator<A> etor;
3072 	private final F.XX<A, A> filter;
3073 
3074 	VM(F.XXX<A, A, A> add, F.XXX<A, A, A> sub, F.XXX<A, A, A> mul, F.XXX<A, A, A> div, F.XXX<A, A, A> mod,
3075 			F.XXX<A, A, A> pow, F.XX<A, A> neg, F.XX<A, A> fact, F.LX<A> fromInt, F.XX<A, A> filter) {
3076 		env = new HashMap<String, A>();
3077 		etor = SimpleLang.makeEvaluator((s, a) -> {
3078 			env.put(s, a);
3079 			return a;
3080 		}, add, sub, mul, div, mod, pow, neg, fact, fromInt, s -> {
3081 			if (env.containsKey(s))
3082 				return env.get(s);
3083 			throw new RuntimeException("no such variable: " + s);
3084 		});
3085 		this.filter = filter;
3086 	}
3087 
3088 	VM(Ring<A> ring, F.XXX<A, A, A> div, F.XXX<A, A, A> mod, F.XXX<A, A, A> pow, F.XX<A, A> fact, F.LX<A> fromInt,
3089 			F.XX<A, A> filter) {
3090 		this(ring.add()::g, (a, b) -> ring.add().g(a, ring.add().inv(b)), ring.mul()::g, div, mod, pow,
3091 				ring.add()::inv, fact, fromInt, filter);
3092 	}
3093 
3094 	VM(EuclideanRing<A> ring, F.XXX<A, A, A> pow, F.XX<A, A> fact, F.LX<A> fromInt, F.XX<A, A> filter) {
3095 		this(ring, ring::div, ring::mod, pow, fact, fromInt, filter);
3096 	}
3097 
3098 	void clear() {
3099 		env.clear();
3100 	}
3101 
3102 	A get(String id) {
3103 		return env.get(id);
3104 	}
3105 
3106 	void print(String id, F.XV<String> printer) {
3107 		printer.f("" + get(id));
3108 	}
3109 
3110 	@SafeVarargs
3111 	final void set(String idsSp, A... as) {
3112 		String[] ids = idsSp.trim().split(" +");
3113 		int n = ids.length;
3114 		if (as.length != n)
3115 			throw new IllegalArgumentException("argument size mismatch: " + n + " != " + as.length);
3116 		for (int i = 0; i < n; i++)
3117 			set(ids[i], as[i]);
3118 	}
3119 
3120 	void set(String id, A a) {
3121 		env.put(id, filter.f(a));
3122 	}
3123 
3124 	A run(String expr) {
3125 		return AST.eval(SimpleLang.parse(expr), etor);
3126 	}
3127 }
3128 
3129 class AST { // Abstract Syntax Tree
3130 	static class AssignOp extends AST {
3131 		String id;
3132 		AST r;
3133 
3134 		AssignOp(String id, AST r) {
3135 			this.id = id;
3136 			this.r = r;
3137 		}
3138 
3139 		public String toString() {
3140 			return "Assign(" + id + ", " + r + ")";
3141 		}
3142 	}
3143 
3144 	static class Multi extends AST {
3145 		ArrayList<AST> as;
3146 
3147 		Multi(ArrayList<AST> as) {
3148 			this.as = as;
3149 		}
3150 
3151 		public String toString() {
3152 			String s = "";
3153 			for (AST a : as)
3154 				s += s.isEmpty() ? a : "; " + a;
3155 			return "Multi(" + s + ")";
3156 		}
3157 	}
3158 
3159 	static class BinOp extends AST {
3160 		AST l;
3161 		AST r;
3162 		String op;
3163 
3164 		BinOp(AST l, String op, AST r) {
3165 			this.l = l;
3166 			this.op = op;
3167 			this.r = r;
3168 		}
3169 
3170 		public String toString() {
3171 			return "BinOp(" + l + ", " + op + ", " + r + ")";
3172 		}
3173 	}
3174 
3175 	static class UnOp extends AST {
3176 		AST a;
3177 		String op;
3178 
3179 		UnOp(String op, AST a) {
3180 			this.op = op;
3181 			this.a = a;
3182 		}
3183 
3184 		public String toString() {
3185 			return "UnOp(" + op + ", " + a + ")";
3186 		}
3187 	}
3188 
3189 	static class Int extends AST {
3190 		long v;
3191 
3192 		Int(long v) {
3193 			this.v = v;
3194 		}
3195 
3196 		public String toString() {
3197 			return "Int(" + v + ")";
3198 		}
3199 	}
3200 
3201 	static class Id extends AST {
3202 		String s;
3203 
3204 		Id(String s) {
3205 			this.s = s;
3206 		}
3207 
3208 		public String toString() {
3209 			return "Id(" + s + ")";
3210 		}
3211 	}
3212 
3213 	static <A> A eval(AST a, Evaluator<A> etor) {
3214 		if (a instanceof AssignOp)
3215 			return etor.assign(((AssignOp) a).id, eval(((AssignOp) a).r, etor));
3216 		if (a instanceof Multi) {
3217 			A last = null;
3218 			for (AST a2 : ((Multi) a).as)
3219 				last = eval(a2, etor);
3220 			return last;
3221 		}
3222 		if (a instanceof BinOp)
3223 			return etor.binOp(((BinOp) a).op, eval(((BinOp) a).l, etor), eval(((BinOp) a).r, etor));
3224 		if (a instanceof UnOp)
3225 			return etor.unOp(((UnOp) a).op, eval(((UnOp) a).a, etor));
3226 		if (a instanceof Int)
3227 			return etor.fromInt(((Int) a).v);
3228 		if (a instanceof Id)
3229 			return etor.id(((Id) a).s);
3230 		throw new RuntimeException("unexpected ast: " + a);
3231 	}
3232 }
3233 
3234 interface Evaluator<A> {
3235 	A assign(String s, A a);
3236 
3237 	A binOp(String op, A a, A b);
3238 
3239 	A unOp(String op, A a);
3240 
3241 	A fromInt(long a);
3242 
3243 	A id(String s);
3244 }
3245 
3246 class Seq<A> {
3247 	ArrayList<A> as;
3248 	int ptr;
3249 
3250 	Seq(ArrayList<A> as) {
3251 		this.as = as;
3252 		ptr = 0;
3253 	}
3254 
3255 	boolean hasNext(int num) {
3256 		return ptr + num < as.size();
3257 	}
3258 
3259 	boolean hasNext() {
3260 		return hasNext(0);
3261 	}
3262 
3263 	A next(int num) {
3264 		return ptr + num < as.size() ? as.get(ptr + num) : null;
3265 	}
3266 
3267 	A next() {
3268 		return next(0);
3269 	}
3270 
3271 	A read() {
3272 		return hasNext() ? as.get(ptr++) : null;
3273 	}
3274 
3275 	A read(A a) {
3276 		if (!hasNext())
3277 			throw new RuntimeException("unexpected EOF");
3278 		if (!isNext(a))
3279 			throw new RuntimeException("expected " + a + " but got" + next());
3280 		return read();
3281 	}
3282 
3283 	A read(F.XX<A, Boolean> f) {
3284 		if (!hasNext())
3285 			throw new RuntimeException("unexpected EOF");
3286 		if (!f.f(next()))
3287 			throw new RuntimeException("f(" + next() + ") returned false");
3288 		return read();
3289 	}
3290 
3291 	boolean isNext(A a) {
3292 		return a.equals(next());
3293 	}
3294 
3295 	boolean isNext(@SuppressWarnings("unchecked") A... as) {
3296 		for (A a : as)
3297 			if (isNext(a))
3298 				return true;
3299 		return false;
3300 	}
3301 
3302 	boolean isNext(F.XX<A, Boolean> f) {
3303 		return hasNext() && f.f(next());
3304 	}
3305 
3306 	A readIf(F.XX<A, Boolean> f) {
3307 		if (isNext(f))
3308 			return read();
3309 		return null;
3310 	}
3311 
3312 	A readIf(@SuppressWarnings("unchecked") A... as) {
3313 		for (A a : as)
3314 			if (isNext(a)) {
3315 				ptr++;
3316 				return a;
3317 			}
3318 		return null;
3319 	}
3320 
3321 	public String toString() {
3322 		return as.toString();
3323 	}
3324 }
3325 
3326 class Token extends P<String, Integer> {
3327 	private static final int ID = 1;
3328 	private static final int SYM = 2;
3329 	private static final int INT = 3;
3330 
3331 	Token(String s, int type) {
3332 		super(s, type);
3333 	}
3334 
3335 	boolean is(String s) {
3336 		return a.equals(s);
3337 	}
3338 
3339 	static Token ofId(String s) {
3340 		return new Token(s, ID);
3341 	}
3342 
3343 	static Token ofSym(String s) {
3344 		return new Token(s, SYM);
3345 	}
3346 
3347 	static Token ofInt(String s) {
3348 		return new Token(s, INT);
3349 	}
3350 
3351 	boolean isId() {
3352 		return b == ID;
3353 	}
3354 
3355 	boolean isSym() {
3356 		return b == SYM;
3357 	}
3358 
3359 	boolean isInt() {
3360 		return b == INT;
3361 	}
3362 }
3363 
3364 class SimpleLang {
3365 	private static class Tokenizer {
3366 		private static final String SYMS = "+-*/%^!()=;";
3367 
3368 		Seq<Character> sc;
3369 		ArrayList<Token> ts;
3370 
3371 		Tokenizer(String s) {
3372 			sc = new Seq<Character>(U.make(s.length(), i -> s.charAt(i)));
3373 		}
3374 
3375 		Seq<Token> parse() {
3376 			ts = new ArrayList<Token>();
3377 			parseAll();
3378 			return new Seq<Token>(ts);
3379 		}
3380 
3381 		private static boolean isSpace(char c) {
3382 			return c == ' ' || c == '\t' || c == '\r' || c == '\n';
3383 		}
3384 
3385 		private static boolean isDigit(char c) {
3386 			return c >= '0' && c <= '9';
3387 		}
3388 
3389 		private static boolean isSymbol(char c) {
3390 			return SYMS.indexOf(c) != -1;
3391 		}
3392 
3393 		private static boolean isAlpha(char c) {
3394 			return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_';
3395 		}
3396 
3397 		private void parseAll() {
3398 			while (sc.hasNext()) {
3399 				while (sc.isNext(Tokenizer::isSpace))
3400 					sc.read();
3401 				if (!sc.hasNext())
3402 					break;
3403 				if (sc.isNext(Tokenizer::isAlpha)) {
3404 					parseId();
3405 				} else if (sc.isNext(Tokenizer::isDigit)) {
3406 					parseInt();
3407 				} else if (sc.isNext(Tokenizer::isSymbol)) {
3408 					parseSym();
3409 				} else {
3410 					throw new RuntimeException("invalid character: " + sc.next());
3411 				}
3412 			}
3413 		}
3414 
3415 		private void parseId() {
3416 			String s = sc.read().toString();
3417 			while (sc.isNext(Tokenizer::isAlpha) || sc.isNext(Tokenizer::isDigit))
3418 				s += sc.read().toString();
3419 			ts.add(Token.ofId(s));
3420 		}
3421 
3422 		private void parseInt() {
3423 			String s = sc.read().toString();
3424 			while (sc.isNext(Tokenizer::isDigit))
3425 				s += sc.read().toString();
3426 			ts.add(Token.ofInt(s));
3427 		}
3428 
3429 		private void parseSym() {
3430 			String s = sc.read().toString();
3431 			ts.add(Token.ofSym(s));
3432 		}
3433 	}
3434 
3435 	private static class Parser {
3436 		Seq<Token> ts;
3437 
3438 		Parser(Seq<Token> ts) {
3439 			this.ts = ts;
3440 		}
3441 
3442 		AST parse() {
3443 			return parseExpr();
3444 		}
3445 
3446 		private AST parseExpr() {
3447 			return parseMultiExpr();
3448 		}
3449 
3450 		private AST parseMultiExpr() {
3451 			readSemicolons();
3452 			AST a = parseAssignExpr();
3453 			if (readSemicolons()) {
3454 				ArrayList<AST> as = new ArrayList<AST>();
3455 				as.add(a);
3456 				do {
3457 					if (!ts.hasNext())
3458 						break;
3459 					as.add(parseAssignExpr());
3460 				} while (readSemicolons());
3461 				if (as.size() == 1)
3462 					return a;
3463 				return new AST.Multi(as);
3464 			}
3465 			return a;
3466 		}
3467 
3468 		private boolean readSemicolons() {
3469 			if (!ts.isNext(t -> t.is(";")))
3470 				return false;
3471 			do {
3472 				ts.read();
3473 			} while (ts.isNext(t -> t.is(";")));
3474 			return true;
3475 		}
3476 
3477 		private AST parseAssignExpr() {
3478 			AST a = parseAddSubOp();
3479 			if (ts.isNext(t -> t.is("="))) {
3480 				ts.read();
3481 				if (!(a instanceof AST.Id))
3482 					throw new RuntimeException("cannot assign to " + a);
3483 				return new AST.AssignOp(((AST.Id) a).s, parseAssignExpr());
3484 			}
3485 			return a;
3486 		}
3487 
3488 		private AST parseAddSubOp() {
3489 			AST a = parseMulDivModOp();
3490 			while (ts.isNext(t -> t.is("+") || t.is("-")))
3491 				a = new AST.BinOp(a, ts.read().a, parseMulDivModOp());
3492 			return a;
3493 		}
3494 
3495 		private AST parseMulDivModOp() {
3496 			AST a = parsePowOp();
3497 			while (ts.isNext(t -> t.is("*") || t.is("/") || t.is("%")))
3498 				a = new AST.BinOp(a, ts.read().a, parsePowOp());
3499 			return a;
3500 		}
3501 
3502 		private AST parsePowOp() {
3503 			AST a = parseNegateOp();
3504 			if (ts.isNext(t -> t.is("^")))
3505 				return new AST.BinOp(a, ts.read().a, parsePowOp());
3506 			return a;
3507 		}
3508 
3509 		private AST parseNegateOp() {
3510 			if (ts.isNext(t -> t.is("-")))
3511 				return new AST.UnOp(ts.read().a, parseNegateOp());
3512 			return parseFactOp();
3513 		}
3514 
3515 		private AST parseFactOp() {
3516 			AST a = parsePrimary();
3517 			while (ts.isNext(t -> t.is("!")))
3518 				a = new AST.UnOp(ts.read().a, a);
3519 			return a;
3520 		}
3521 
3522 		private AST parsePrimary() {
3523 			if (ts.isNext(t -> t.isId()))
3524 				return new AST.Id(ts.read().a);
3525 			if (ts.isNext(t -> t.isInt()))
3526 				return new AST.Int(Long.parseLong(ts.read().a));
3527 			if (ts.readIf(t -> t.is("(")) != null) {
3528 				AST e = parseExpr();
3529 				ts.read(t -> t.is(")"));
3530 				return e;
3531 			}
3532 			throw new RuntimeException("unexpected token: " + ts.next());
3533 		}
3534 	}
3535 
3536 	static HashMap<String, AST> cache = new HashMap<String, AST>();
3537 
3538 	static <A> Evaluator<A> makeEvaluator(F.XXX<String, A, A> assign, F.XXX<A, A, A> add, F.XXX<A, A, A> sub,
3539 			F.XXX<A, A, A> mul, F.XXX<A, A, A> div, F.XXX<A, A, A> mod, F.XXX<A, A, A> pow, F.XX<A, A> neg,
3540 			F.XX<A, A> fact, F.LX<A> fromInt, F.XX<String, A> id) {
3541 		return new Evaluator<A>() {
3542 			public A assign(String s, A a) {
3543 				return assign.f(s, a);
3544 			}
3545 
3546 			public A binOp(String op, A a, A b) {
3547 				switch (op) {
3548 				case "+":
3549 					return add.f(a, b);
3550 				case "-":
3551 					return sub.f(a, b);
3552 				case "*":
3553 					return mul.f(a, b);
3554 				case "/":
3555 					return div.f(a, b);
3556 				case "%":
3557 					return mod.f(a, b);
3558 				case "^":
3559 					return pow.f(a, b);
3560 				}
3561 				throw new RuntimeException("invalid binOp: " + op);
3562 			}
3563 
3564 			public A unOp(String op, A a) {
3565 				switch (op) {
3566 				case "-":
3567 					return neg.f(a);
3568 				case "!":
3569 					return fact.f(a);
3570 				}
3571 				throw new RuntimeException("invalid unOp: " + op);
3572 			}
3573 
3574 			public A fromInt(long a) {
3575 				return fromInt.f(a);
3576 			}
3577 
3578 			public A id(String s) {
3579 				return id.f(s);
3580 			}
3581 		};
3582 	}
3583 
3584 	static AST parse(String s) {
3585 		if (cache.containsKey(cache)) {
3586 			return cache.get(s);
3587 		}
3588 		Tokenizer l = new Tokenizer(s);
3589 		Seq<Token> ts = l.parse();
3590 		Parser p = new Parser(ts);
3591 		AST a = p.parse();
3592 		cache.put(s, a);
3593 		return a;
3594 	}
3595 }
3596 
3597 class Mod {
3598 	final long mod;
3599 	final AbelianGroup<Long> add;
3600 	final AbelianGroup<Long> mul;
3601 	final Field<Long> field;
3602 	final VM<Long> vm;
3603 	private final boolean prime;
3604 	private final HashMap<Long, Integer> logMap;
3605 	private long[] facts;
3606 	private long[] invs;
3607 	private long[] invFacts;
3608 	private long[] factors;
3609 
3610 	Mod(long mod) {
3611 		this.mod = mod;
3612 		prepareFacts(0);
3613 		prime = BigInteger.valueOf(mod).isProbablePrime(100);
3614 		add = AbelianGroup.make((a, b) -> (a + b) % mod, a -> mod - a, 0l);
3615 		mul = AbelianGroup.make((a, b) -> (a * b) % mod, a -> {
3616 			if (prime)
3617 				return pow(a, mod - 2);
3618 			TL t = Alg.extgcd(a, mod);
3619 			if (t.c != 1)
3620 				throw new ArithmeticException("inv(" + a + ") does not exist");
3621 			return (t.a % mod + mod) % mod;
3622 		}, 1l);
3623 		field = Field.make(add, mul);
3624 		logMap = new HashMap<Long, Integer>();
3625 		vm = new VM<Long>(field, this::pow, this::fact, a -> (a % mod + mod) % mod, a -> (a % mod + mod) % mod);
3626 	}
3627 
3628 	long fact(long a) {
3629 		if (a >= Integer.MAX_VALUE)
3630 			throw new RuntimeException("fact(" + a + ") too big");
3631 		prepareFacts((int) a);
3632 		return facts[(int) (a % mod)];
3633 	}
3634 
3635 	long invFact(int a) {
3636 		prepareFacts(a);
3637 		return invFacts[(int) (a % mod)];
3638 	}
3639 
3640 	long inv(long a) {
3641 		return mul.inv(a);
3642 	}
3643 
3644 	long pow(long a, long b) {
3645 		if (b == 0)
3646 			return 1;
3647 		if (b == 1)
3648 			return a;
3649 		if (b < 0) {
3650 			a = inv(a);
3651 			b = -b;
3652 		}
3653 		a %= mod;
3654 		long res = 1;
3655 		while (b > 0) {
3656 			if ((b & 1) != 0)
3657 				res = res * a % mod;
3658 			a = a * a % mod;
3659 			b >>= 1;
3660 		}
3661 		return res;
3662 	}
3663 
3664 	long order(long a) { // computes the order of `a` in O(sqrt(mod)) time
3665 		a %= mod;
3666 		if (a == 0)
3667 			return 0;
3668 		if (a == 1)
3669 			return 1;
3670 		if (factors == null) {
3671 			ArrayList<Long> fs = new ArrayList<Long>();
3672 			for (long i = 2; i * i < mod; i++) {
3673 				if ((mod - 1) % i == 0)
3674 					fs.add(i);
3675 			}
3676 			factors = new long[fs.size()];
3677 			for (int i = 0; i < fs.size(); i++) {
3678 				factors[i] = fs.get(i);
3679 			}
3680 		}
3681 		for (long f : factors) {
3682 			if (pow(a, f) == 1)
3683 				return f;
3684 		}
3685 		return mod - 1;
3686 	}
3687 
3688 	PL log(long a, long b) { // log_b(a) in O(sqrt(mod)) time
3689 		a %= mod;
3690 		b %= mod;
3691 		if (b == 1 || b == 0)
3692 			return a == b ? PL.make(1, 1) : PL.make(-1, 0);
3693 		if (a == 0)
3694 			return PL.make(-1, 0);
3695 		long order = order(b);
3696 		if (a == 1)
3697 			return PL.make(0, order);
3698 		long orderSqrtL = sqrtCeil(order);
3699 		if (orderSqrtL > Integer.MAX_VALUE)
3700 			throw new RuntimeException("order(" + b + ") too big: " + order);
3701 		int orderSqrt = (int) sqrtCeil(order);
3702 		logMap.clear();
3703 		logMap.put(1l, 0);
3704 		long p = 1;
3705 		for (int i = 1; i < orderSqrt; i++) {
3706 			p = p * b % mod;
3707 			logMap.put(p, i);
3708 		}
3709 		long ib = pow(b, mod - orderSqrt - 1);
3710 		p = a;
3711 		for (int i = 1; i < orderSqrt; i++) {
3712 			p = p * ib % mod;
3713 			if (logMap.containsKey(p))
3714 				return PL.make((i * orderSqrt + logMap.get(p)) % order, order);
3715 		}
3716 		return PL.make(-1, 0);
3717 	}
3718 
3719 	private long sqrtCeil(long a) {
3720 		return U.searchL((long) Math.sqrt(a * 0.9), (long) Math.sqrt(a * 1.1) + 1, mid -> mid * mid >= a);
3721 	}
3722 
3723 	private void prepareFacts(int n) {
3724 		if (facts == null) {
3725 			facts = new long[1024];
3726 			invs = new long[1024];
3727 			invFacts = new long[1024];
3728 			prepareFactsIn(0, 1024);
3729 		}
3730 		if (n >= mod)
3731 			n = (int) (mod - 1);
3732 		while (facts.length <= n) {
3733 			int prevL = facts.length;
3734 			int newL = prevL << 1;
3735 			facts = Arrays.copyOf(facts, newL);
3736 			invs = Arrays.copyOf(invs, newL);
3737 			invFacts = Arrays.copyOf(invFacts, newL);
3738 			prepareFactsIn(prevL, newL);
3739 		}
3740 	}
3741 
3742 	private void prepareFactsIn(int from, int until) {
3743 		if (until > mod)
3744 			until = (int) mod;
3745 		for (int i = from; i < until; i++) {
3746 			if (i == 0) {
3747 				facts[0] = 1;
3748 				invs[0] = 0;
3749 				invFacts[0] = 1;
3750 				continue;
3751 			}
3752 			if (i == 1) {
3753 				facts[1] = 1;
3754 				invs[1] = 1;
3755 				invFacts[1] = 1;
3756 				continue;
3757 			}
3758 			facts[i] = facts[i - 1] * i % mod;
3759 			invs[i] = (mod - mod / i) * invs[(int) (mod % i)] % mod;
3760 			invFacts[i] = invFacts[i - 1] * invs[i] % mod;
3761 		}
3762 	}
3763 }
