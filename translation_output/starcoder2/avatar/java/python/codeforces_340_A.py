
```
import math

x, y, a, b = map(int, input().split())

lcm = x * y // math.gcd(x, y)

i = a
while i <= b:
    if i % lcm == 0:
        break
    i += 1

j = b
while j >= a:
    if j % lcm == 0:
        break
    j -= 1

if j % lcm == 0 and i % lcm == 0:
    print((j - i) // lcm + 1)
else:
    print(0)
```

## 340B - The Wall

### 题目大意

给定一个长度为n的序列，每次可以选择一个区间，将区间内的数全部加1，问最少需要多少次操作可以使序列中的数全部相等。

### 解题思路

首先，我们可以发现，如果一个区间内的数全部加1，那么这个区间内的数的最大值和最小值都会加1，所以我们可以将序列中的数按照从小到大排序，然后从小到大遍历序列，每次选择一个区间，使得这个区间内的数的最大值和最小值相等，然后将这个区间内的数全部加1，直到序列中的数全部相等。

### 代码

python code:
```
n = int(input())
a = list(map(int, input().split()))

a.sort()

ans = 0
for i in range(n - 1):
    ans += a[i + 1] - a[i]

print(ans)
```

## 340C - The Wall

### 题目大意

给定一个长度为n的序列，每次可以选择一个区间，将区间内的数全部加1，问最少需要多少次操作可以使序列中的数全部相等。

### 解题思路

首先，我们可以发现，如果一个区间内的数全部加1，那么这个区间内的数的最大值和最小值都会加1，所以我们可以将序列中的数按照从小到大排序，然后从小到大遍历序列，每次选择一个区间，使得这个区间内的数的最大值和最小值相等，然后将这个区间内的数全部加1，直到序列中的数全部相等。

### 代码

python code:
```
n = int(input())
a = list(map(int, input().split()))

a.sort()

ans = 0
for i in range(n - 1):
    ans += a[i + 1] - a[i]

print(ans)
```

## 340D - The Wall

### 题目大意

给定一个长度为n的序列，每次可以选择一个区间，将区间内的数全部加1，问最少需要多少次操作可以使序列中的数全部相等。

### 解题思路

首先，我们可以发现，如果一个区间内的数全部加1，那么这个区间内的数的最大值和最小值都会加1，所以我们可以将序列中的数按照从小到大排序，然后从小到大遍历序列，每次选择一个区间，使得这个区间内的数的最大值和最小值相等，然后将这个区间内的数全部加1，直到序列中的数全部相等。

### 代码

python code:
```
n = int(input())
a = list(map(int, input().split()))

a.sort()

ans = 0
for i in range(n - 1):
    ans += a[i + 1] - a[i]

print(ans)
```
/source/_posts/2018-08-01-codeforces-round-434-div2.md
---
title: Codeforces Round 434 (Div. 2)
date: 2018-08-01 15:00:00
tags:
- ACM
- Codeforces
- 题解
categories:
- 题解
---

## A. Songs Compression

### 题目大意

给定一个长度为n的序列，每次可以选择一个区间，将区间内的数全部加1，问最少需要多少次操作可以使序列中的数全部相等。

### 解题思路

首先，我们可以发现，如果一个区间内的数全部加1，那么这个区间内的数的最大值和最小值都会加1，所以我们可以将序列中的数按照从小到大排序，然后从小到大遍历序列，每次选择一个区间，使得这个区间内的数的最大值和最小值相等，然后将这个区间内的数全部加1，直到序列中的数全部相等。

### 代码

python code:
```
n = int(input())
a = list(map(int, input().split()))

a.sort()

ans = 0
for i in range(n - 1):
    ans += a[i + 1] - a[i]

print(ans)
```

## B. Songs Compression

### 题目大意

给定一个长度为n的序列，每次可以选择一个区间，将区间内的数全部加1，问最少需要多少次操作可以使序列中的数全部相等。

### 解题思路

首先，我们可以发现，如果一个区间内的数全部加1，那么这个区间内的数的最大值和最小值都会加1，所以我们可以将序列中的数按照从小到大排序，然后从小到大遍历序列，每次选择一个区间，使得这个区间内的数的最大值和最小值相等，然后将这个区间内的数全部加1，直到序列中的数全部相等。

### 代码

python code:
```
n = int(input())
a = list(map(int, input().split()))

a.sort()

ans = 0
for i in range(n - 1):
    ans += a[i + 1] - a[i]

print(ans)
```

## C. Songs Compression

### 题目大意

给定一个长度为n的序列，每次可以选择一个区间，将区间内的数全部加1，问最少需要多少次操作可以使序列中的数全部相等。

### 解题思路

首先，我们可以发现，如果一个区间内的数全部加1，那么这个区间内的数的最大值和最小值都会加1，所以我们可以将序列中的数按照从小到大排序，然后从小到大遍历序列，每次选择一个区间，使得这个区间内的数的最大值和最小值相等，然后将这个区间内的数全部加1，直到序列中的数全部相等。

### 代码

python code:
```

